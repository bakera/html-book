＜タイトル＞
ルート要素と文書のメタデータ
＜リード＞
ここでは、HTML文書でもっとも上位となるルート要素と、HTML文書自身の情報を表すメタデータについて見ていきます。

＜中見出し＞
html要素
＜本文＞
html要素はHTML文書でもっとも上位に出現する要素です。他のすべての要素は、この要素の子孫となります。このように、文書の最上位に出現する要素を「ルート要素」（root element）といいます。
Chapter2-1で触れたように、HTML文書はDOCTYPEで始まります。通常は、その直後に<html>タグが出現することになります。〓01〓のように、コメントを間に挟むこともできます。

〓01〓html要素の記述例
＜コード＞
<!DOCTYPE html>
<!-- HTMLのコード例。`...`は内容が省略されていることを表す -->
<html>
  <head>...</head>
  <body>...</body>
</html>

＜小見出し＞
内容モデル
＜本文＞
html要素の内容モデルは、head要素1つ、その後に続いてbody要素1つとなります。

＜小見出し＞
属性
＜本文＞
html要素の属性には以下のようなものがあります。

＜丸見出し＞
lang属性
＜本文＞
lang属性は、要素内の言語（自然言語）を指定するグローバル属性です。詳細はChapter4-1を参照してください。
html要素のlang属性はページ全体の言語を指定するため、特に重要です。〓02〓のように指定します。

〓02〓lang属性の記述例
＜コード＞
<html lang="ja"><!-- ページ全体の言語が日本語であることを表す -->

＜memo＞
仕様上はこの属性を省略できますが、WCAG 2.1達成基準3.1.1「ページの言語」でページの言語を指定することが要求されています。そのため、html要素のlang属性の指定は事実上必須に近いといえます。
Success Criterion 3.1.1 Language of Page
https://www.w3.org/TR/WCAG21/#language-of-page

＜丸見出し＞
xmlns属性
＜本文＞
Chapter1-3で触れたように、HTML文書はXML構文としても記述できます。この場合、〓03〓のようにxmlns属性を指定します。これは名前空間宣言と呼ばれ、XMLの要素や属性がどのマークアップ言語由来なのかを区別するためのものです。

＜memo＞
Chapter1-6で触れたように、MIMEタイプapplication/xhtml+xmlでHTML文書を配信するとXML構文であるとみなされます。MIMEタイプtext/htmlで配信される通常のHTML構文では、xmlns属性は不要です。指定自体は可能ですが、属性値として"http://www.w3.org/1999/xhtml"以外を指定した場合はエラーになります。

〓03〓xmlns属性の記述例
＜コード＞
<html xmlns="http://www.w3.org/1999/xhtml">
  ...
  <title></title><!-- これはHTMLのtitle要素 -->
  ...
  <svg xmlns="http://www.w3.org/2000/svg">
    ...
    <title></title><!-- これはSVGのtitle要素 -->
    ...
  </svg>

＜本文＞
"http://www.w3.org/1999/xhtml"はHTMLの名前空間で、この要素と子孫がHTMLの要素であることを表します。

＜memo＞
HTML仕様で扱う名前空間はInfra Standardで定義されています。通常、名前空間を意識する必要はありません。
8. Namespaces
https://infra.spec.whatwg.org/#namespaces

＜中見出し＞
head要素
＜本文＞
head要素は文書に関するメタデータの集合を表すものです。子要素にはさまざまなメタデータを含みます。

＜memo＞
「メタデータ」（metadata）とは、「データのデータ」という意味で、ここではHTML文書についての各種の情報を指します。HTML文書はそれ自体がデータであり、その文書に関するデータはデータのデータであることからメタデータと呼ばれます。

＜小見出し＞
内容モデル
＜本文＞
head要素の内容モデルはMetadataです。主にlink要素、meta要素、script要素、style要素を入れることができます。また、原則としてtitle要素を必ず1つ含まなければなりません。

＜中見出し＞
title要素
＜本文＞
title要素はページのタイトルを表すものです。原則として、この要素はhead要素内に必ず1つ存在しなければなりません。

＜memo＞
上位プロトコルでタイトルが示されている場合は例外となります。たとえば、電子メールの本文をHTMLで記述する場合、電子メールのタイトルはHTMLの外で別途指定されているため、title要素は不要です。

＜本文＞
ページのタイトルは、ブラウザーのタブなどに表示されたり、検索エンジンによる検索結果のリンクテキストに使われたりします。

＜小見出し＞
内容モデル
＜本文＞
title要素の内容はテキストのみです。子要素を持つことはできず、タグを書いてもテキストとして扱われます。〓04〓のようにbr要素を入れようとすると、タイトルに<br>という文字列が入ります。

〓04〓title要素の記述例
＜コード＞
<title>改行されている<br>タイトル</title>

〓05〓ブラウザーによる〓04〓の表示例

＜memo＞
タグだけでなく、コメントの記述も同様にテキストとして扱われ、コメント扱いされません。

＜本文＞
ただし、文字参照は展開されます。たとえば〓06〓の場合、&amp;は展開されて「タイトル&タイトル」というタイトルになります。

〓06〓title要素内に文字参照がある場合の記述例
＜コード＞
<title>タイトル &amp; タイトル</title>

＜小見出し＞
title要素の指針
＜本文＞
ユーザーにとって、ページタイトルは重要です。現在どのページを見ているのかがわかるように、ウェブサイト内の個々のページにはそれぞれ異なるタイトルを付けるとよいでしょう。

＜memo＞
WCAG 2.1達成基準2.4.2「ページタイトル」でも、ページの主題、または目的を説明するタイトルを付けることを求めています。
Success Criterion 2.4.2 Page Titled
https://www.w3.org/TR/WCAG21/#page-titled

＜本文＞
慣習として、タイトルにはページ自身の名前に加えて、サイト名やカテゴリー名を含めることがあります。〓07〓はその一例です。

〓07〓 サイト名を含むタイトルの例
＜コード＞
<title>CGWORLD vol. 248 （2019年4月号） | ボーンデジタル</title>

＜本文＞
サイト名を前に置くこともありますが、スマートフォンやブラウザーのタブにタイトルが表示される場合、表示領域はかなり狭く、タイトルが長い場合は前半しか表示されません。それぞれのページのタイトルが区別できるように、共通の名称は後ろに置くとよいでしょう。

＜中見出し＞
base要素
＜本文＞
base要素を利用すると、基準URLや、リンク先を表示するデフォルトのウィンドウターゲットを指定できます。この要素はなくても構いませんが、存在する場合、1つしか存在してはなりません。

＜memo＞
実際のところ、base要素を使う機会はほとんどないでしょう。使い方の例としては、ウェブ上にあるHTMLをダウンロードしてローカルで閲覧する際に、base要素を書き加え、元あったURLを基準URLにするというものがあります。こうすると、相対URLで指定されたサブリソースを簡単に読み込めます。

＜小見出し＞
内容モデル
＜本文＞
base要素の内容モデルはNothingで、内容を持つことはできません。また、終了タグを書くこともできません。

＜小見出し＞
属性
＜本文＞
base要素の属性には以下のようなものがあります。

＜丸見出し＞
href属性
＜本文＞
href属性で、基準となるURLを指定します。〓08〓のように記述すると、ページ内の相対URLはhttps://example.com/を基準として解決されます。この例の場合、a要素のhref属性にpage.htmlという相対URLが書かれていますが、HTMLが存在している閲覧URLに関係なく、https://example.com/page.htmlへのリンクとして振る舞います。

〓08〓href属性の記述例
＜コード＞
<base href="https://example.com/">
...
<a href="page.html">ページ</a>

＜丸見出し＞
target属性
＜本文＞
target属性は、デフォルトのウィンドウ表示位置を指定します。属性値の詳細は、a要素のtarget属性（P000）を参照してください。たとえば〓09〓のように記述すると、タブブラウザーであれば常に新しいタブでリンクを開くように指定できます。

〓09〓target属性の記述例
＜コード＞
<base target="_blank">

＜memo＞
ユーザーに対して事前に知らせることなく新しいタブやウィンドウを開くと、ユーザーを混乱させることがあります。WCAG 2.1達成基準3.2.5「要求による変化」では、ユーザーの要求なしに新しいウィンドウを開かないようにすることを求めています。
Success Criterion 3.2.5 Change on Request
https://www.w3.org/TR/WCAG21/#change-on-request

＜中見出し＞
link要素
＜本文＞
link要素は、HTML文書と別のリソースとのつながりを表現します。href属性が必須で、属性に対象リソースのURLを指定します。
link要素の詳細はChapter3-5で紹介します。

＜中見出し＞
meta要素
＜本文＞
meta要素は、他の要素では表現できないさまざまな種類のメタデータを表します。

＜小見出し＞
内容モデル
＜本文＞
link要素の内容モデルはNothingで、内容を持つことはできません。また、終了タグを書くこともできません。

＜小見出し＞
属性
＜本文＞
meta要素には、次の4つの属性のうち、少なくとも1つを指定する必要があります。

・charset：HTMLの文字エンコーディングを表します
・http-equiv：HTTPでウェブサーバーから与えられる情報と等価な情報を表します
・name：文書レベルのメタデータを表します
・itemprop：microdataによるメタデータを表します

charset属性を指定した場合を除き、content属性も同時に指定しなければなりません。
なお、meta要素のname属性については、仕様に記載されている「標準メタデータ名」と、WHATWG Wiki MetaExtensions pageに登録される「他のメタデータ名」があります。本書ではこのうちのいくつかについて取り上げていきます。

＜memo＞
WHATWG Wiki MetaExtensions page
https://wiki.whatwg.org/wiki/MetaExtensions

＜丸見出し＞
charset属性
＜本文＞
charset属性を利用すると、HTML文書の文字エンコーディングを宣言できます。この用法を「文字エンコーディング宣言（character encoding declaration）」と呼び、〓10〓のように指定します。

〓10〓charset属性の記述例
＜コード＞
<meta charset="utf-8">

＜memo＞
文字エンコーディングについてはChapter2-5を参照してください。

＜本文＞
Chapter2-5で触れたように、現在のHTML仕様は文字エンコーディングとしてUTF-8を要求するため、charset属性の値は、utf-8としなければなりません（大文字小文字は区別しませんので、UTF-8と書いても問題ありません）。

＜memo＞
ユーザーエージェントは互換性のため、UTF-8以外のレガシーエンコーディングも解釈できます。これはあくまで互換性のためのものです。新規でHTMLを作成する場合、コンテンツ制作者はUTF-8を指定しなければなりません。

＜本文＞
ブラウザーがHTML文書を正しく読むためには、文書の文字エンコーディングが判断できるようになっている必要があります。
そこでブラウザーは、HTMLをパースするのではなく、簡素なパターンマッチングで文字エンコーディング宣言を検出します。そのため、文字エンコーディング宣言を書く際には以下のような制約があります。

- 文字参照を使用してはならない
- HTML文書の先頭から1024バイト以内に文字エンコーディング宣言の全体が含まれていなければならない

加えて、文字エンコーディング宣言は複数回出現してはならないという制限もあります。

＜memo＞
ここでいう簡素なパターンマッチングは、prescan a byte stream to determine its encodingアルゴリズムの一部です。
https://html.spec.whatwg.org/multipage/parsing.html#prescan-a-byte-stream-to-determine-its-encoding
Chapter2-5の文字エンコーディングの判定もあわせて参照してください。

＜memo＞
文字エンコーディング宣言より前に長いコメントを記述したり、html要素のclass属性に大量の値を記述したりすると、先頭から1024バイト以内に入らない場合があります。特に、ソースコードの冒頭に（お洒落で）アスキーアートのコメントを入れる場合は注意が必要です。

＜丸見出し＞
http-equiv属性
＜本文＞
http-equiv属性を利用すると、HTTPレスポンスヘッダーと同等の情報を指定できます。

＜memo＞
http-equivとは、HTTPと等価という意味です。この属性で示される情報は、基本的にHTTPレスポンスヘッダーでも示すことができます。ウェブ上でHTMLコンテンツを提供する場合、HTMLのmeta要素で指定するよりも、サーバー側の設定によるHTTPレスポンスヘッダーで指定するほうが望ましいでしょう。

＜本文＞
http-equiv属性は列挙型属性であり、決められた値しか指定できません。詳細は仕様の4.2.5.3 Pragma directivesを参照してください。ここでは、代表的なものに絞って説明します。

＜memo＞
4.2.5.3 Pragma directives
https://html.spec.whatwg.org/multipage/semantics.html#pragma-directives

・文字エンコーディング宣言（http-equiv="content-type"）
文字エンコーディング宣言は、http-equiv属性を利用して〓11〓のように書くこともできます。

〓11〓content属性を用いた宣言の記述例
＜コード＞
<meta http-equiv="content-type" content="text/html; charset=utf-8">

＜本文＞
この場合、content属性の値は、text/html; charset=で始まらなければなりません（大文字小文字は区別しません）。
http-equiv属性による文字エンコーディングの宣言は、charset属性による宣言の単なる代替です。効果や制約事項は、charset属性を利用した場合と同様です。charsetによる文字エンコーディング宣言と重複して宣言してはなりません。

・ページのリフレッシュ（http-equiv="refresh"）
http-equiv="refresh"を指定して、content属性に負ではない整数を指定すると、指定秒数後にページを自動的に再読み込みするよう指示します。〓12〓は、300秒後にページを再読み込みする例です。

〓12〓300秒後にページを再読み込みする記述例
＜コード＞
<meta http-equiv="Refresh" content="300">

＜本文＞
また、指定秒数後にそのURLへリダイレクトする動作を指示できます。〓13〓のように秒数とリダイレクト先URLとの間に文字列"; URL="を書きます。〓13〓の例では30秒後にhttps://www.example.net/に移動します。

〓13〓30秒後に移動する記述例
＜コード＞
<meta http-equiv="Refresh" content="30; URL=https://www.example.net/">

＜本文＞
ページが再読み込みされたり、リダイレクトが行われたりした場合、ユーザーの操作は強制的に中断されることに注意してください。WCAG 2.1達成基準3.2.5「要求による変化」では、ユーザーの要求なしに再読み込みするのを避けるように求めています。

＜memo＞
Success Criterion 3.2.5 Change on Request
https://www.w3.org/TR/WCAG21/#change-on-request

＜memo＞
ブラウザーの設定により、この再読み込みの動作を無効にできる場合もあります。

＜本文＞
〓14〓のように秒数として0を指定した場合、ユーザーがページを読んでいる途中でリダイレクトが発生することはなく、即時にリダイレクトするため、WCAGの観点からは問題ありません。

〓14〓0秒でリダイレクトを設定した場合の記述例
＜コード＞
<meta http-equiv="Refresh" content="0; URL=https://www.example.net/">

＜memo＞
即時のリダイレクトは、サーバー側での設定も可能です。Googleもサーバー側のリダイレクトを最初の候補として案内しています。
リダイレクトと Google検索
https://developers.google.com/search/docs/advanced/crawling/301-redirects?hl=ja

＜本文＞
・CSPの指定（http-equiv="content-security-policy"）
http-equiv="content-security-policy"を指定すると、「CSP（Content Security Policy）」を指定できます。CSPを指定すると、ページ上でのJavaScriptの動作を制限できます。これにより、クロスサイトスクリプティングの攻撃を受けにくくなります。
CSPについても他のhttp-equiv属性で指定するものと同様に、基本的にはHTTPレスポンスヘッダーで指定できます。サーバー側での設定が難しい場合や、個別のページに試験的に適用する場合などには、meta要素を使用してもよいでしょう。
CSPの詳細については本書では触れません。2021年時点でCSP2の仕様がW3C勧告となっており、CSP3が策定中となっています。

＜memo＞
Content Security Policy Level 2
https://www.w3.org/TR/CSP2/

Content Security Policy Level 3
https://www.w3.org/TR/CSP3/

＜丸見出し＞
name属性
＜本文＞
name属性は、任意のメタデータを表現します。content属性でメタデータとなるテキストを指定し、name属性で任意の名前を付けます。
よく使われる名前は、仕様で標準メタデータ名として説明されています。ここでは、そのいくつかを紹介します。

＜memo＞
4.2.5.1 Standard metadata names
https://html.spec.whatwg.org/multipage/semantics.html#standard-metadata-names

・ページコンテンツの説明（name="description"）
name="description"を指定すると、content属性の値はページコンテンツの説明（ディスクリプション）となります。検索エンジンはこの説明文を検索結果ページに表示することがあります。
〓15〓はサイトトップページの記述例です。基本的には、サイトの個々のページごとに異なる説明文を提供すべきです。ほとんどの場合、検索エンジンはページの内容から説明文を生成できます。適切な説明文を提供するのが難しいのであれば、指定を省略してしまうのがよいでしょう。

〓15〓ディスクリプションの記述例
＜コード＞
<meta name="description" content="ボーンデジタルはデジタルクリエイターを支援するサービスカンパニーです。ソフトウェア・ハードウェア・書籍・雑誌・セミナー・トレーニングなどさまざまなサービスで学びを提供しています。">

＜本文＞
・ページのキーワード（name="keywords"）
name="keywords"は、ページに関連するキーワードをカンマ区切りで記述するものです。しかし、検索エンジンスパムに濫用された経緯があり、現在ではほとんどの検索エンジンがこれを無視します。ウェブ上で指定する必要性はほとんどないでしょう。

＜memo＞
スペルは複数形の"keywords"であり、"keyword"ではないという注意点もありますが、いずれにせよ現在ではほとんど利用されません。

＜本文＞
・ビューポート（name="viewport"）
name="viewport"は、主に画面の小さなモバイルブラウザーに対して、ウェブページの表示制御に関する情報を伝えます。たとえば〓16〓のように記述します。

〓16〓ビューポートの記述例
<meta name="viewport" content="width=device-width, initial-scale=1">

＜本文＞
とりうる値は、CSS Device Adaptation仕様を参照してください。

＜memo＞
9. Viewport <META> element
https://www.w3.org/TR/2016/WD-css-device-adapt-1-20160329/#viewport-meta
不幸なことに、2021年時点で規範的な定義ではありません。以下のissueで議論が継続されています。
https://github.com/w3c/csswg-drafts/issues/331

＜本文＞
maximum-scale=1.0、user-scalable=noのようなズームを禁止する設定は、ウェブアクセシビリティに悪影響を与えるため、避けるべきです。

＜memo＞
WCAG 2.1達成基準1.4.4「テキストのサイズ変更」では、ユーザーがテキストを拡大できるようにすることを求めています。
Success Criterion 1.4.4 Resize text
https://www.w3.org/TR/WCAG21/#resize-text

＜コラム＞
meta要素がbody要素内に出現する場合
＜本文＞
meta要素は典型的にはhead要素内に出現しますが、microdataとして記載する場合に限って、〓01〓のようにbody内に記載できます。

〓01〓body内のmeta要素
＜コード＞
<span itemscope><meta
  itemprop="name"
  content="The Castle"></span>
<figure>
  <img src="castle.jpeg">
  <figcaption>The Castle
  (1986)</figcaption>
</figure>

＜本文＞
もっとも、実際にbody内でmeta要素が使用されることは稀です。
＜/コラム＞

＜中見出し＞
style要素
＜本文＞
style要素は、CSSスタイルシートを埋め込む要素です。
link要素（<link rel="stylesheet">）が外部のスタイルシートを参照するのに対し、style要素は要素の内容にスタイルを記述します。link要素についてはChapter3-5を参照してください。

＜memo＞
一般に、link要素で指定されたスタイルシートを「外部スタイルシート」、style要素に記述されたスタイルシートを「埋め込みスタイルシート」と呼びます。

＜本文＞
典型的なウェブサイトでは、メンテナンス性の観点から、外部スタイルシートを用いることが一般的です。特定ページだけに一時的にスタイルを適用するような場合には、style要素が便利です。

＜小見出し＞
内容モデル
＜本文＞
styleの内容モデルはテキストです。このテキストは、CSSの構文として適切なものでなければなりません。
かつては〓17〓のように、style要素の中でHTMLコメントを書いてコメントアウトする手法が使われたこともありました。この場合、<!--はHTMLのコメントとしては解釈されず、そのままの形でCSSを解析するエンジンに渡されます。そして、CSSの処理としてコメント扱いされます（<!--という文字列はCSSの構文でもコメント扱いになります）。
この書き方は、style要素を解釈しないブラウザーへの対策です。極めて古い話であり、現在ではこのように書く必要はありません。

〓17〓style要素内のコメント（古い記述例）
＜コード＞
<style type="text/css">
<!--
...
-->
</style>

＜小見出し＞
属性
＜本文＞
現在ではstyle要素に属性を指定することは稀です。HTML4ではtype属性が必須でしたが、現在では廃止されています。

＜memo＞
style要素と同じ名前の属性である、style属性も存在します。style属性はグローバル属性で、Chapter4-1で説明しています。

＜丸見出し＞
廃止された属性：type属性
＜本文＞
style要素のtype属性はスタイルシート言語のMIMEタイプを指定するものでした。現在のHTMLでは、利用可能なスタイルシート言語はCSSのみであり、type属性がなくても、デフォルトのスタイルシート言語はCSSとなります。そのため、この属性は不要です。

＜memo＞
type属性は廃止されていますが、値が"text/css"の場合（大文字小文字は区別しません）のみ、「旧式だが適合する機能（Obsolete but conforming）」として仕様に適合します。

＜コラム＞
style要素はbody要素内に出現できるか
＜本文＞
〓01〓のように、style要素をbody要素の子孫として記述しているケースを見ることがあります。過去にはこのような書き方を許すべきという提案もあり、現に廃止されたHTML 5.2では仕様に適合するとされていました。実際、ブラウザーはこのようなstyle要素を解釈して、スタイルを適用します。
しかし、body要素内にスタイルを記述すると、ページの再描画や再レイアウトを引き起こし、パフォーマンスに悪影響を及ぼします。よってHTML Standardでは、古いHTML4と同様に、引き続き仕様に適合しないものとしています。
なお、body要素の内部に<link rel="stylesheet">を記述して外部スタイルシートを参照することは許されています。CMSの都合などでbody要素内でスタイルシートを設定したい場合は、link要素を利用するとよいでしょう。

〓01〓style要素をbody要素の子孫として記述した例
＜コード＞
<body>
  <div>
    <!-- スタイルが適用される -->
  </div>
  ...
  <style>
    div {
      /* スタイルシートの記述 */
    }
  </style>
</body>
＜/コラム＞
