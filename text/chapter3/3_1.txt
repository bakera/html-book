＜タイトル＞
ルート要素と文書のメタデータ
＜リード＞
ここでは、HTML文書でもっとも上位となるルート要素と、HTML文書自身の情報を表すメタデータについて見ていきます。

＜中見出し＞
html要素
＜本文＞
html要素はHTML文書でもっとも上位に出現する要素です。他のすべての要素は、この要素の子孫となります。このように、文書の最上位に出現する要素を「ルート要素」（root element）といいます。
Chapter2-1で触れたように、HTML文書はDOCTYPEで始まります。通常は、その直後に<html>タグが出現することになります。〓01〓のように、コメントを間に挟むこともできます。

〓01〓html要素の記述例
＜コード＞
<!DOCTYPE html>
<!-- HTMLのコード例。`...`は内容が省略されていることを表す -->
<html>
  <head>...</head>
  <body>...</body>
</html>

＜小見出し＞
内容モデル
＜本文＞
html要素の内容モデルは、head要素1つ、その後に続いてbody要素1つとなります。

＜小見出し＞
属性
＜本文＞
html要素の属性には以下のようなものがあります。

＜丸見出し＞
lang属性
＜本文＞
lang属性は、要素内の言語（自然言語）を指定するグローバル属性です。詳細はChapter4-1を参照してください。
html要素のlang属性はページ全体の言語を指定するため、特に重要です。〓02〓のように指定します。

〓02〓lang属性の記述例
＜コード＞
<html lang="ja"><!-- ページ全体の言語が日本語であることを表す -->

＜memo＞
仕様上はこの属性を省略できますが、WCAG 2.1達成基準3.1.1「ページの言語」でページの言語を指定することが要求されています。そのため、html要素のlang属性の指定は事実上必須に近いといえます。
Success Criterion 3.1.1 Language of Page
https://www.w3.org/TR/WCAG21/#language-of-page

＜丸見出し＞
xmlns属性
＜本文＞
Chapter1-3で触れたように、HTML文書はXML構文としても記述できます。この場合、〓03〓のようにxmlns属性を指定します。これは名前空間宣言と呼ばれ、XMLの要素や属性がどのマークアップ言語由来なのかを区別するためのものです。

＜memo＞
Chapter1-6で触れたように、MIMEタイプapplication/xhtml+xmlでHTML文書を配信するとXML構文であるとみなされます。MIMEタイプtext/htmlで配信される通常のHTML構文では、xmlns属性は不要です。指定自体は可能ですが、属性値として"http://www.w3.org/1999/xhtml"以外を指定した場合はエラーになります。

〓03〓xmlns属性の記述例
＜コード＞
<html xmlns="http://www.w3.org/1999/xhtml">
  ...
  <title></title><!-- これはHTMLのtitle要素 -->
  ...
  <svg xmlns="http://www.w3.org/2000/svg">
    ...
    <title></title><!-- これはSVGのtitle要素 -->
    ...
  </svg>

＜本文＞
"http://www.w3.org/1999/xhtml"はHTMLの名前空間で、この要素と子孫がHTMLの要素であることを表します。

＜memo＞
HTML仕様で扱う名前空間はInfra Standardで定義されています。通常、名前空間を意識する必要はありません。
8. Namespaces
https://infra.spec.whatwg.org/#namespaces

＜中見出し＞
head要素
＜本文＞
head要素は文書に関するメタデータの集合を表すものです。子要素にはさまざまなメタデータを含みます。

＜memo＞
「メタデータ」（meta data）とは、「データのデータ」という意味で、ここでは、HTML文書についての各種の情報を指します。HTML文書はそれ自体がデータであり、その文書に関するデータはデータのデータであることからメタデータと呼ばれます。

＜小見出し＞
内容モデル
＜本文＞
head要素の内容モデルはMetadataです。主にlink要素、meta要素、script要素、style要素を入れることができます。また、原則としてtitle要素を必ず1つ含まなければなりません。

＜中見出し＞
title要素
＜本文＞
title要素はページのタイトルを表すものです。原則として、head要素内にはこの要素が必ず1つ存在しなければなりません。

＜memo＞
上位プロトコルでタイトルが示されている場合は例外となります。たとえば、電子メールの本文をHTMLで記述する場合、電子メールのタイトルはHTMLの外で別途指定されているため、title要素は不要です。

＜本文＞
ページのタイトルは、ブラウザーのタブなどに表示されたり、検索エンジンによる検索結果のリンクテキストに使われたりします。

＜小見出し＞
内容モデル
＜本文＞
title要素の内容はテキストのみです。子要素を持つことはできず、タグを書いてもテキストとして扱われます。〓04〓のようにbr要素を入れようとすると、タイトルに<br>という文字列が入ります。

〓04〓title要素の記述例
＜コード＞
<title>改行されている<br>タイトル</title>

〓05〓 〓04〓の表示例

＜memo＞
タグだけでなく、コメントの記述も同様にテキストとして扱われ、コメント扱いされません。

＜本文＞
ただし、文字参照は展開されます。たとえば〓06〓の場合、&amp;は展開されて「タイトル&タイトル」というタイトルになります。

〓06〓title要素内に文字参照がある場合の記述例
＜コード＞
<title>タイトル &amp; タイトル</title>

＜小見出し＞
title要素の指針
＜本文＞
ユーザーにとって、ページタイトルは重要です。WCAG 2.1達成基準2.4.2「ページタイトル」でも、ページの主題、または目的を説明するタイトルを付けることを求めています。

＜memo＞
Success Criterion 2.4.2 Page Titled
https://www.w3.org/TR/WCAG21/#page-titled

現在どのページを見ているのかがわかるように、ウェブサイト内の個々のページにはそれぞれ異なるタイトルを付けるとよいでしょう。
慣習として、タイトルにはページ自身の名前に加えて、サイト名やカテゴリー名を含めることがあります。〓07〓はその一例です。

〓07〓タイトル例
＜コード＞
<title>CGWORLD vol. 248 （2019年4月号） | ボーンデジタル</title>

＜本文＞
サイト名を前に置くこともありますが、スマートフォンやブラウザーのタブにタイトルが表示される場合、表示領域はかなり狭く、タイトルが長い場合は前半しか表示されません。それぞれのページのタイトルが区別できるように、共通の名称は後ろに置くとよいでしょう。

＜中見出し＞
base要素
＜本文＞
base要素を利用すると、基準URLや、リンク先を表示するデフォルトのウィンドウターゲットを指定できます。この要素はなくても構いませんが、存在する場合、1つしか存在してはなりません。

＜memo＞
実際のところ、base要素を使う機会はほとんどないでしょう。使い方の例としては、ウェブ上にあるHTMLをダウンロードしてローカルで閲覧する際に、base要素を書き加え、元あったURLを基準URLにするというものがあります。こうすると、相対URLで指定されたサブリソースを簡単に読み込めます。

＜小見出し＞
内容モデル
＜本文＞
base要素の内容モデルはNothingで、内容を持つことはできません。また、終了タグを書くこともできません。

＜小見出し＞
属性
＜本文＞
base要素の属性には以下のようなものがあります。

＜丸見出し＞
href属性
＜本文＞
href属性で、基準となるURLを指定します。〓08〓のように記述すると、ページ内の相対URLはhttps://example.com/を基準として解決されます。この例の場合、a要素のhref属性にpage.htmlという相対URLが書かれていますが、HTMLが存在している閲覧URLに関係なく、https://example.com/page.htmlへのリンクとして振る舞います。

〓08〓href属性の記述例
＜コード＞
<base href="https://example.com/">
...
<a href="page.html">ページ</a>

＜丸見出し＞
target属性
＜本文＞
target属性は、デフォルトのウィンドウ表示位置を指定します。属性値の詳細は、a要素のtarget属性を参照してください。たとえば〓09〓のように記述すると、タブブラウザーであれば常に新しいタブでリンクを開くように指定できます。

〓09〓target属性の記述例
＜コード＞
<base target="_blank">

＜memo＞
ただし、ユーザーに対して事前に知らせることなく新しいタブやウィンドウを開くと、ユーザーを混乱させることがあります。WCAG 2.1達成基準3.2.5「要求による変化」では、ユーザーの要求なしに新しいウィンドウを開かないようにすることを求めています。
Success Criterion 3.2.5 Change on Request
https://www.w3.org/TR/WCAG21/#change-on-request

＜中見出し＞
link要素
＜本文＞
link要素は、HTML文書と別のリソースとのつながりを表現します。href属性が必須で、属性に対象リソースのURLを指定します。
link要素の詳細はChapter3-5で紹介します。

＜中見出し＞
meta要素
＜本文＞
meta要素は、他の要素では表現できないさまざまな種類のメタデータを表します。

＜小見出し＞
内容モデル
＜本文＞
link要素の内容モデルはNothingで、内容を持つことはできません。また、終了タグを書くこともできません。

＜小見出し＞
属性
＜本文＞
meta要素には、次の4つの属性のうち、少なくとも1つを指定する必要があります。

・charset：HTMLの文字エンコーディングを表します
・http-equiv：HTTPでウェブサーバーから与えられる情報と等価な情報を表します
・name：文書レベルのメタデータを表します
・itemprop：microdataによるメタデータを表します

charset属性を指定した場合を除き、content属性も同時に指定しなければなりません。
なお、meta要素のname属性については、仕様に記載されている「標準メタデータ名」と、WHATWG Wiki MetaExtensions pageに登録される「他のメタデータ名」があります。本書ではこのうちのいくつかについて取り上げていきます。

＜memo＞
WHATWG Wiki MetaExtensions page
https://wiki.whatwg.org/wiki/MetaExtensions

＜丸見出し＞
文字エンコーディング宣言（charset、http-equiv="content-type"）
＜本文＞
meta要素でもっともよく使用されるのが「文字エンコーディング宣言（character encoding declaration）」です。通常、charset属性を用いて〓10〓のように指定します。

〓10〓charset属性の記述例
＜コード＞
<meta charset="utf-8">

＜本文＞
charset属性の値は、utf-8でなければなりません（大文字小文字は区別しません。つまり、UTF-8と書いても問題ありません）。また、charset属性の代わりに、http-equiv="content-type"とともに〓11〓のようにも宣言できます。

〓11〓content属性を用いた宣言の記述例
＜コード＞
<meta http-equiv="content-type" content="text/html; charset=utf-8">

＜本文＞
この場合、content属性の値は、text/html; charset=で始まらなければなりません（大文字小文字は区別しません）。charset属性と同様、charset=の直後は、UTF-8でなければなりません。なお、UTF-8は文字エンコーディングと呼ばれるものです。
ところで、過去との互換性から、ユーザーエージェントはUTF-8以外の文字エンコーディングを解釈できます。UTF-8以外の文字エンコーディングはレガシーエンコーディングと呼ばれます（Chapter2-5も参照）。日本語を扱えるよく知られているものとしては、Shift_JIS、EUC-JP、ISO-2022-JPが存在します。これはあくまで互換性のためのものであり、現在のコンテンツ制作者はUTF-8を指定しなければなりません。
文字エンコーディング宣言を使用する場合、複数回宣言してはなりません。つまり、charset属性とhttp-equiv="content-type"属性の両方を同時に使用してはなりません。charset属性を選択するのがモダンな書き方です。
また、文字エンコーディング宣言が存在する場合、先頭から1024バイト以内に出現しなければなりません。HTML文書の文字エンコーディングの判定については、Chapter2-5を参照してください。

＜memo＞
言い換えると、文字エンコーディング宣言は、HTML文書のなるべく先頭に書く必要があるわけです。典型的なHTML文書において、head要素の最初の子要素として文字エンコーディング宣言が書かれるのは、このような背景によるものです。

＜丸見出し＞
http-equiv属性を指定する場合
＜本文＞
http-equiv属性を指定すると、これはプラグマ（Pragma）と解釈されます。http-equivという属性名は、HTTPと等価という意味です。つまり、通常はHTTPレスポンスヘッダーで与えられる情報の代わりに指定しているもの、ということを意味します。
言い換えると、http-equiv属性で示される情報は、基本的にHTTPレスポンスヘッダーでも示すことができます。ウェブ上でHTMLコンテンツを提供する場合は、HTMLのmeta要素で指定するよりも、サーバー側の設定によるHTTPレスポンスヘッダーで指定するほうが望ましいでしょう。
前述の文字エンコーディング宣言も、HTTPレスポンスヘッダーで文字符号化方式を提供していれば、省略可能です。ただし、省略することで、ローカルにダウンロードしてHTMLを閲覧した場合などに文字化けすることがあるため、保険として指定しておくとよいでしょう。
http-equiv属性は列挙型属性であり、決められた値しか指定できません。詳細は仕様の4.2.5.3 Pragma directivesを参照してください。ここでは、代表的なものに絞って説明します。

＜memo＞
4.2.5.3 Pragma directives
https://html.spec.whatwg.org/multipage/semantics.html#pragma-directives

＜丸見出し＞
ページのリフレッシュ（http-equiv="refresh"）
＜本文＞
http-equiv="refresh"を指定して、content属性に負ではない整数を指定すると、ページはその秒数で自動的に再読み込みされます。〓12〓は、300秒後にページを再読み込みする例です。

〓12〓300秒後にページを再読み込みする記述例
＜コード＞
<meta http-equiv="Refresh" content="300">

＜本文＞
また、content属性に負でない整数と、セミコロン、スペース、文字列URL=（大文字小文字は区別しません）、最後にURLを順番通りに書くことで、指定秒数後にそのURLへリダイレクトする動作を指定できます。〓13〓は30秒後に移動する例です。

〓13〓30秒後に移動する記述例
＜コード＞
<meta http-equiv="Refresh" content="30; URL=https://www.example.net/">

＜本文＞
しかし、いずれもユーザーの意図しないタイミングでページが再読み込みされて、行動の妨げとなることがあるため勧められません。WCAG 2.1達成基準3.2.5「要求による変化」では、ユーザーの要求なしに再読み込みするのを避けるように求めています。また、ブラウザーの設定でこの再読み込みの動作を無効にできる場合もあります。
リダイレクト指定の際、秒数として0も指定できます。0を設定した場合、ページを表示することなく即時にリダイレクトします〓14〓。
この場合、ユーザーがページを読んでいる途中でリダイレクトが発生することはないため、WCAGの観点からは問題ありません。なお、この即時のリダイレクトはサーバー側で同等の設定が可能です。Googleもサーバー側のリダイレクトを最初の候補として案内しています。

＜memo＞
リダイレクトと Google検索
https://developers.google.com/search/docs/advanced/crawling/301-redirects?hl=ja

＜本文＞
〓14〓リダイレクト指定を0に設定した場合の記述例
＜コード＞
<meta http-equiv="Refresh" content="0; URL=https://www.example.net/">

＜memo＞
Success Criterion 3.2.5 Change on Request
https://www.w3.org/TR/WCAG21/#change-on-request

＜丸見出し＞
CSP（http-equiv="content-security-policy"）
＜本文＞
http-equiv="content-security-policy"を指定すると、「CSP（Content Security Policy）」を指定できます。CSPを指定すると、ページ上でのJavaScriptの動作を制限できます。これにより、クロスサイトスクリプティングの攻撃を受けにくくなります。
CSPについても他のhttp-equiv属性で指定するものと同様に、基本的にはHTTPレスポンスヘッダーで指定できます。サーバー側での設定が難しい場合や、個別のページに試験的に適用する場合などには、meta要素を使用してもよいでしょう。
CSPの詳細については本書では触れません。2021年時点でCSP2の仕様がW3C勧告となっており、CSP3が策定中となっています。

＜memo＞
Content Security Policy Level 2
https://www.w3.org/TR/CSP2/

Content Security Policy Level 3
https://www.w3.org/TR/CSP3/

＜丸見出し＞
name属性を指定する場合
＜本文＞
name属性を指定した場合、name属性値の指定した名前と、content属性で指定した値を持つメタデータを表現します。別の言い方をすると、メタデータとなるテキストをcontent属性で指定し、name属性で任意の名前を付けて表現できます。
name属性には任意の値を指定できますが、よく使われるものは仕様で標準メタデータ名として説明されています。
ここでは、そこからさらに絞っていくつかを紹介します。

＜memo＞
4.2.5.1 Standard metadata names
https://html.spec.whatwg.org/multipage/semantics.html#standard-metadata-names

・ページコンテンツの説明（name="description"）
name="description"を指定すると、content属性の値はページコンテンツの説明（ディスクリプション）となります。検索エンジンはこの値を読み、検索結果ページに表示することがあります〓15〓。
通常は、サイトのページごとに、そのページの内容を適切に説明する文を提供するようにします。この値がない場合でも、検索エンジンはページの内容から説明文を生成して問題なく検索結果を表示できることがほとんどです。無理に不適切な値を指定するならば、むしろ指定しないという判断をするのもありでしょう。

〓15〓ディスクリプションの記述例
＜コード＞
<meta name="description" content="ボーンデジタルはデジタルクリエイターを支援するサービスカンパニーです。ソフトウェア・ハードウェア・書籍・雑誌・セミナー・トレーニングなどさまざまなサービスで学びを提供しています。">

＜本文＞
・ページのキーワード（name="keywords"）
name="keywords"は、ページに関連するキーワードをカンマ区切りで記述するものです。しかし、検索エンジンスパムに濫用された経緯があり、現在ではほとんどの検索エンジンがこれを無視します。ウェブ上で指定する必要性はほとんどないでしょう。

＜memo＞
"keywords"は複数形で、"keyword"とスペルミスしないようにという注意点も昔はありました。

＜本文＞
・ビューポート（name="viewport"）
name="viewport"は、主に画面の小さなモバイルブラウザーに対して、ウェブページの表示方法を制御します〓16〓。

〓16〓ビューポートの記述例
<meta name="viewport" content="width=device-width, initial-scale=1">

＜本文＞
とりうる値については、CSS Device Adaptation仕様で参照されています。maximum-scale=1.0、user-scalable=noのようなズームする機能を禁止する設定は、ウェブアクセシビリティに悪影響を与えるため、避けるべきです。WCAG 2.1達成基準1.4.4「テキストのサイズ変更」では、テキストの拡大ができることを求めています。

＜memo＞
9. Viewport <META> element
https://www.w3.org/TR/2016/WD-css-device-adapt-1-20160329/#viewport-meta
不幸なことに、2021年時点で規範的な定義ではありません。以下のissueで議論が継続されています。
https://github.com/w3c/csswg-drafts/issues/331

＜memo＞
Success Criterion 1.4.4 Resize text
https://www.w3.org/TR/WCAG21/#resize-text

＜コラム＞
meta要素がbody要素内に出現する場合
＜本文＞
meta要素は典型的にはhead要素内に出現しますが、microdataとして記載する場合に限って、body要素内に書くことができます。
実際のウェブページにおいてbody内のmeta要素の使用は稀ですが、仕様上は特定の条件の下で〓01〓のようにmeta要素を記載できます。

〓01〓body内のmeta要素
＜コード＞
<span itemscope><meta
  itemprop="name"
  content="The Castle"></span>
<figure>
  <img src="castle.jpeg">
  <figcaption>The Castle
  (1986)</figcaption>
</figure>

＜/コラム＞

＜中見出し＞
style要素
＜本文＞
style要素は、CSSスタイルシートを埋め込む要素です。link要素（<link rel="stylesheet">）と異なり、style要素は内容として直接CSSの記述をします。link要素についてはChapter3-5を参照してください。
一般に、link要素で指定されたスタイルシートを「外部スタイルシート」、style要素に記述されたスタイルシートを「埋め込みスタイルシート」と呼びます。典型的なウェブサイトでは、複数ページで同じスタイルシートを使い回すことが多く、またHTMLとCSSと別々に編集したいことが多いため、メンテナンス性の観点から外部スタイルシートを用いることが一般的です。style要素は、一時的に特定ページだけにスタイルを適用するような場合に使われることがあります。

＜小見出し＞
内容モデル
＜本文＞
styleの内容モデルはテキストです。このテキストは、CSSの構文として適切なものでなければなりません。
かつては、style要素の中でHTMLコメントを書いてコメントアウトする手法が使われたこともありました。
〓17〓の場合、<!--はHTMLのコメントとしては解釈されず、そのままの形でCSSを解析するエンジンに渡されます。そして、CSSの処理としてコメント扱いされます（<!--という文字列はCSSの構文でもコメント扱いになります）。
この書き方は、style要素を解釈しないブラウザーへの対策です。極めて古い話であり、現在ではこのように書く必要はありません。

〓17〓style要素内のコメント（古い記述例）
＜コード＞
<style type="text/css">
<!--
...
-->
</style>

＜小見出し＞
属性
＜本文＞
style要素と似た働きをするstyle属性が別に存在します。style属性についてはChapter4-1を参照してください。

＜丸見出し＞
廃止された属性：type属性
＜本文＞
style要素のtype属性はスタイルシート言語のMIMEタイプを指定するものでしたが、現在のHTMLで利用可能なスタイルシート言語はCSSのみであるため、廃止されています。
なお、type属性の値が"text/css"の場合（大文字小文字は区別しません）のみ、「旧式だが適合する機能（Obsolete but conforming）」として仕様に適合します。type属性を指定しなくても、デフォルトのスタイルシート言語はCSSとなりますので、指定は不要です。指定しないようにしましょう。

＜コラム＞
style要素はbody要素内に出現できるか
＜本文＞
style要素をbody要素の子孫として記述しているケースを見ることがあります。
過去には、〓01〓のような書き方を許すべきという提案もあり、現に廃止されたHTML 5.2では仕様に適合するとされていました。また、このように記述してもブラウザーはstyle要素を解釈して、実際にスタイルを適用します。
しかし、body要素内に記述するのは、ページの再描画や再レイアウトを引き起こすなど、パフォーマンスに悪影響を及ぼすことが知られています。よってHTML Standardでは、古いHTML4と同様に、引き続き仕様に適合しないものとしています。
CMSの都合などのためにbody要素内でスタイルシートを設定したい場合は、対象の要素にstyle属性を設定するか、body要素の内部で<link rel="stylesheet">を記述して外部スタイルシートを参照するようにします。

〓01〓style要素をbody要素の子孫として記述した例
＜コード＞
<body>
  <div>
    <!-- スタイルが適用される -->
  </div>
  ...
  <style>
    div {
      /* スタイルシートの記述 */
    }
  </style>
</body>

＜/コラム＞
