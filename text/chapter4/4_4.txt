＜タイトル＞
WAI-ARIAの実践
＜リード＞
ここでは、実際にウェブでよく使われるウィジェットの事例を通じて、WAI-ARIAをどのように利用するのか、その検討の過程や考え方について紹介します。

＜中見出し＞
事例1： ハンバーガーメニューを改良する
＜本文＞
モバイル用のページでは、通常はメニューを隠しておき、ボタンを押すことでメニューが開く仕組みがよく見られます。〓01〓のように、メニューを開くボタンが3本の横棒で表現されたものは「ハンバーガーメニュー」と呼ばれます。一般的なハンバーガーメニューは、以下のような機能を持ちます。

・ユーザーがボタンを押すと、メニューが出現する
・メニューにはサイト内の主要なコンテンツへのリンクが含まれる
・メニューはコンテンツに覆いかぶさるような形で現れ、メニューが開いている間はメニューの外のコンテンツは利用できない
・メニューが出現すると、メニューを開くボタンはメニューを閉じるボタンに変化する
・閉じるボタンを押すとメニューは消え、元の状態に戻る

＜memo＞
詳細なコード例については「WAI-ARIA Authoring Practicesなどを参照してください。
https://www.w3.org/TR/wai-aria-practices/

〓01〓一般的なハンバーガーメニューの例

ウェブ制作者にとってはおなじみのパーツですが、アクセシビリティ上の留意点がいくつかあります。深く考えずに作られたハンバーガーメニューは、たとえば〓02〓のようなマークアップになっていることがあります。

〓02〓ハンバーガーメニューのマークアップ例
＜コード＞
<div class="hamburgerMenu">
  <div class="button">
    <!-- 閉じている場合にのみ表示され、開くとdisplay:noneになる -->
    <span class="menu-icon"></span>
    <!-- 開いている場合にのみ表示され、閉じるとdisplay:noneになる -->
    <span class="close-icon"></span>
  </div>
  <ul>
    <li><a href="/">ホーム</a></li>
    <!-- メニュー -->
  </ul>
</div>

＜memo＞
参考サイト
「マクドナルド公式サイト」（権利関係要確認）
https://www.mcdonalds.co.jp/

<div class="button">がボタンに相当します。中に入っている2つのspan要素は、それぞれハンバーガーアイコンと閉じるアイコンに相当し、CSSのbackground-imageを使用してアイコン画像を表示します。そして、〓02〓のようなJavaScriptでdivにclickイベントのイベントハンドラーを付け、動くようにします。

〓02〓ハンバーガーメニューのJavaScript
＜コード＞
const hamburgerMenu = document.querySelector('.hamburgerMenu');
const hamburgerMenuButton = hamburgerMenu.querySelector('.button');
hamburgerMenuButton.addEventListener('click', event => {
    hamburgerMenu.classList.toggle('js-opened');
});

さまざまなJavaScriptの実装方法が考えられますが、ここでは単純に、外側のdiv要素にjs-opendクラスを付けたり外したりしています。そして、〓03〓のようなCSSでメニュー項目のul要素を非表示にし、js-openedクラスが付いたときだけ表示されるようにします。

〓03〓ハンバーガーメニューのCSS
＜コード＞
.hamburgerMenu ul{
    display: none;
}
.hamburgerMenu.js-opened ul{
    display: block;
}
/* 実際には別のスタイル定義も必要だが省略 */

これでメニューボタンは動作しますが、このメニューにはアクセシビリティ上の問題点が複数あります。ここでは、このマークアップで作成されたメニューが既に存在すると仮定して、アクセシビリティを向上していく過程の考え方を紹介します。

＜memo＞
アクセシビリティを向上する手段の代表例がWAI-ARIAですが、Chapter4-3で紹介したように、WAI-ARIAを利用することが必ずしも望ましいとは限りません。ここでは、AI-ARIAを利用する方法、しない方法の両方を含めて検討していきます。

＜小見出し＞
キーボード操作を可能にする
＜本文＞
このメニューの最大の問題は、キーボードで操作できないことです。メニューボタンはdiv要素で実装されています。clickイベントを付けているため、マウスでのクリックやタップには反応します。しかし、キーボードでは、そもそもボタンにフォーカスを当てることができません。
キーボード操作を可能にする方法はいくつかあります。

＜memo＞
キーボード操作は、WCAG 2.1の達成基準2.1.1「キーボード」で要求されているアクセシビリティ上の重要事項です。
https://www.w3.org/TR/WCAG21/#keyboard
Chapter4-3の「マウスやタッチで操作可能なものはキーボードでも操作可能にする」も参照してください。

＜太字黒見出し＞
方法1：button要素を使用する
＜本文＞
Chapter4-3でも触れたきたように、WAI-ARIAを使う前に、まずHTMLのネイティブ機能が使えないか検討すべきです。ここでは〓03〓のように、HTMLのbutton要素を使うことができます。

〓03〓
＜コード＞
<button>
  <span class="menu-icon"></span>
  <span class="close-icon"></span>
</button>

これだけでキーボード操作が可能になります。role属性もtabindex属性もkeypressイベントも必要ありません。button要素はそれらの機能を既に備えているからです。

＜太字黒見出し＞
方法2：a要素を使用する（非推奨）
＜本文＞
お勧めはしませんが、a要素でもフォーカスを受け取ることはできます。a要素にrole=buttonを指定すると、ボタンであると宣言することができます。
role属性の指定は単に役割を宣言するだけです。role=buttonを指定しても、ボタンと同じ挙動にはならないことに注意してください。
a要素はbutton要素とは動作が異なります。たとえば、button要素ではフォーカスした後に「<kbd>スペース</kbd>」キーでボタンを押すことができますが、a要素ではできません。可能であればbutton要素を利用するべきです。

＜太字黒見出し＞
方法3：divのままキーボード操作可能にする（非推奨）
＜本文＞
まったくお勧めしませんが、何らかの理由でbutton要素が利用できない場合、div要素のままキーボード操作を可能にする方法もあります。〓04〓のように、tabindex=0とrole=buttonを指定すると、フォーカスが当たるようになり、スクリーンリーダーでも「ボタン」と読み上げられます。

〓04〓tabindex=0を指定した例
＜コード＞
<div class="button" role="button" tabindex="0">
  <span class="menu-icon"></span>
  <span class="close-icon"></span>
</div>


さらに、キーボード操作に対応するために、〓05〓のようなJavaScriptでkeypressイベントを付けます。

〓05〓keypressイベントをJavaScriptで追記
＜コード＞
hamburgerMenuButton.addEventListener('keypress', event => {
  // Enterキーやスペースキーでボタンが押せ、かつTabキーではボタンが押されないような実装...
});

このイベント内では、押されたキーを判定して、「<kbd>Enter</kbd>」キーや「<kbd>スペース</kbd>」キーならばボタンが押されるように、かつ「<kbd>Tab</kbd>」キーなどの操作を横取りしないように実装します。
繰り返しになりますが、この方法はお勧めしません。複雑で労力がかかる上に、考慮すべきことが多数あるために、考慮漏れも生じやすくなります。基本的にbutton要素を使うべきです。

＜小見出し＞
何のボタンかわかるようにする
＜本文＞
button要素を利用すると、スクリーンリーダーを使ってボタンにフォーカスを当てたとき、「ボタン」と読み上げられます。しかし、単に「ボタン」と言われても、これが何をするボタンかはわかりません。
何のボタンかわかるようにするために、ボタンにラベルを与える必要があります。たとえば、「メニュー」というラベルを与えると、「メニュー ボタン」などと読み上げられ、何のボタンか伝わります。
ボタンにラベルを与える方法はいくつかあります。

＜太字黒見出し＞
方法1：画像をimg要素にしてaltでテキストを指定する
＜本文＞
Chapter3-9で紹介したとおり、button要素は、内容に含まれるテキストをラベルとして扱います。アイコンをCSSの背景画像で実装することをやめて、〓06〓のように`img`要素の`alt`属性で代替テキストを提供すれば、ラベルとして扱われることになります。

〓06〓alt属性でテキストを指定
＜コード＞
<button>
  <!-- 閉じている場合にのみ表示され、開くとdisplay:noneになる -->
  <span class="menu-icon"><img src="menu.png" alt="メニュー"></span>
  <!-- 開いている場合にのみ表示され、閉じるとdisplay:noneになる -->
  <span class="close-icon"><img src="close.png" alt="閉じる"></span>
</button>

＜memo＞
「メニュー」や「閉じる」アイコンは意味を持つ画像コンテンツと考えられます。WCAG 2.1達成基準1.1.1「非テキストコンテンツ」では、テキストによる代替を提供することが求められています。
https://www.w3.org/TR/WCAG21/#non-text-content

＜memo＞
img要素のalt属性については、Chapter3-7も参照してください。

＜本文＞
このようにすると、スクリーンリーダーで読み上げられることに加え、画像が表示できないケースや、通信速度の問題で画像を表示しないようにしている場合などに代替テキストが利用されることが期待されます。ただし、ブラウザーによっては代替テキストを表示しないこともあります。
なお、img要素を用いるこの方法は、サイトの高速化を意図した「CSSスプライト」と呼ばれる技法と相性が悪いという問題があります。最近はCSSスプライトが使われることも少なくなってきましたが、CSSスプライトの利用が必須である場合は、他の方法を考えましょう。

＜太字黒見出し＞
方法2：スクリーンリーダー用テキストを入れる
＜本文＞
button要素の中にテキストかあれば、ラベルとして扱われます。それは必ずしも、視覚的に見えている必要はありません。〓07〓のように、スクリーンリーダーで読み上げさせる専用のテキストを入れる方法もあります。

〓07〓スクリーンリーダー用テキストを記述
＜コード＞
<button>
  <span class="visually-hidden">メニュー</span>
  <span class="menu-icon"></span>
  <span class="close-icon"></span>
</button>

visually-hiddenは、視覚環境で表示されず、かつスクリーンリーダーでは読み上げられるようなスタイルを定義したクラスです。詳細は
Chapter4-3の「スクリーンリーダー向けテキストを提供する」を参照してください。
なお、単純にCSSのdisplay:noneの指定を用いると、スクリーンリーダーからも参照できなくなり、読まれなくなるため注意が必要です。

＜太字黒見出し＞
方法3：aria-label属性を利用する
＜本文＞
別の選択肢として、〓09〓のようにaria-label属性を利用する方法もあります。

〓09〓aria-label属性の記述例
＜コード＞
<button aria-label="メニュー">
  <span class="menu-icon"></span>
  <span class="close-icon"></span>
</button>

このようにすると、aria-labelに対応しているスクリーンのリーダーでは「メニュー ボタン」と読み上げることが期待できます。
ただし、aria-labelで指定したラベルは、支援技術の利用者にしか伝わらないという問題があります。視覚環境において、何らかの理由でCSSが無効になった場合、方法1や方法2ではボタンのアイコンやラベルが見えますが、この方法ではボタンの内容が全く表示されなくなります。
aria-labelの利用はスマートな方法に見えますが、強くおすすめできるものではありません。

＜太字黒見出し＞
方法4：aria-haspopup属性を利用する
＜本文＞
ボタンの意味を伝える方法には、ボタンにラベルを与える以外のアプローチもあります。〓10〓は、メニューボタンにaria-haspopup属性を指定した例です。

〓10〓aria-haspopup属性を指定する記述例
＜コード＞
<button aria-haspopup="menu">
  <span class="menu-icon"></span>
  <span class="close-icon"></span>
</button>

こうすると、aria-haspopupに対応したスクリーンリーダーでは、「ボタン メニュー ポップアップ」などと読み上げられます。ボタンにラベルはありませんが、押せばポップアップメニューが出現することは伝わります。

＜memo＞
aria-haspopupは、あくまでポップアップが現れることを知らせる者です。メニューがポップアップするのではなく、他の方法で出現する場合は、aria-haspopupを使用するべきではありません。

＜本文＞
ボタンにラベルがある場合、それもあわせて読み上げられます。ラベルが「メニュー」の場合は、「メニュー ボタン メニュー ポップアップ」と読み上げられます（「メニュー」が2回出現しますが、前者はボタンのラベル、後者はaria-haspopup属性の値です）。これは冗長になるため、ボタンのラベルだけで動作が十分に伝わる場合は、aria-haspopupを指定すべきでないという考え方もあります。
なお、このボタンが閉じるボタンに変化する場合、「メニュー ポップアップ」と読み上げられると混乱を招くため、動作にあわせてaria-haspopup属性を削除する必要があります。

＜小見出し＞
メニューの開閉状態がわかるようにする
＜本文＞
ここまでで、キーボード操作ができ、ボタンも「メニュー ボタン」と読み上げられるようになりました。これで、メニューボタンを利用できる最低限の条件は満たしています。
メニューを開いた際、視覚的には、メニューが開いたことは一目瞭然です。しかし、スクリーンリーダーのユーザーには、メニューが開いたかどうかはわかりません。
今回はボタンに「メニュー」というラベルを付けましたから、メニューが開いただろうと想像はできるでしょう。しかし、実際にどこがどう変化したかはわかりませんし、メニューの開閉状態、つまりメニューが開いているのか、閉じているのかもわかりません。
この問題について、対応を検討していきましょう。

＜太字黒見出し＞
方法1：開いたメニューにフォーカスを移す
＜本文＞
メニューが開いたことを伝える方法の1つは、開いたメニューにキーボードフォーカスを移してしまうことです。先のスクリプトにあったボタンクリック時のイベントに、〓11〓のようなフォーカス移動の処理を追加します。

〓11〓先頭のa要素にフォーカスを移動
＜コード＞
hamburgerMenuButton.addEventListener('click', event => {
    hamburgerMenu.classList.toggle('js-opened');
    hamburgerMenu.querySelector('ul a').focus(); // この行を追加 
});

こうすると、メニューを開くと同時に、メニューの先頭の項目にフォーカスが移動します。スクリーンリーダーはメニューの先頭の項目を読み上げ始めますから、メニューが開いたことは間違いなく伝わるでしょう。
この方法はわかりやすい反面、フォーカスを強制的に移動させる点に注意が必要です。HTMLソースコード上で、ボタンの直後にメニューが存在する場合は、直後の要素にフォーカスが移るだけ、元の位置に戻ることもできます大きな問題はありません。

＜memo＞
WCAG 2.1の達成基準 3.2.5「要求による変化」では、フォーカス移動のようなコンテキストの変化は、ユーザーの要求によってだけ生じるようにすることが望ましいとされています。この例では、ユーザーが「メニュー」というボタンを押すことによってフォーカスが移動しますから、この達成基準は抵触しません。
https://waic.jp/docs/WCAG21/#change-on-request

＜本文＞
メニューがボタンから離れている場合は、慎重な設計が必要です。メニューを開いたあと、ユーザーは「<kbd>Shift+Tab</kbd>」キーでフォーカスを戻そうとするかもしれません。フォーカス移動先がHTMLのDOMツリー上で離れた位置にあると、「<kbd>Shift+Tab</kbd>」キーの操作では元に戻れない場合があります。出現するメニューは、メニューボタンの直後に置くことが望ましいでしょう。

＜memo＞
HTMLソースコード上、メニューがボタンとかけ離れた場所にある場合、WCAG 2.1達成基準1.3.2「意味のある順序」の観点でも問題となる場合があります。
https://www.w3.org/TR/WCAG21/#meaningful-sequence

＜太字黒見出し＞
方法2：ボタンのラベルで状態を伝える
＜本文＞
フォーカスを移さない場合、ボタンのラベルで現在の状態を伝える方法もあります。たとえば〓12〓のように、メニューが開くと同時にボタンのラベルを「メニューを閉じる」に変えるようにします。

〓12〓ボタンのラベルを変更
＜コード＞
<button>
  <!-- 閉じている場合にのみ表示され、開くとdisplay:noneになる -->
  <span class="menu-icon"><img src="menu.png" alt="メニュー"></span>

  <!-- 開いている場合にのみ表示され、閉じるとdisplay:noneになる -->
  <span class="close-icon"><img src="close.png" alt="メニューを閉じる"></span>
</button>


こうすると、ボタンを再度読み上げさせれば「メニューを閉じる ボタン」と読み上げられ、現在メニューが開いている（だから閉じることができる）と推測できるでしょう。
ただし、メニューが開いたことがわかっても、実際にメニューに移動できるかどうかは別の話です。HTMLソースコード上、ボタンの直後にメニューを挿入するか、前述の方法1のように、フォーカスを制御するとよいでしょう。

＜memo＞
見た目上はボタンの隣にメニューが表示され、しかしHTMLソースコード上ではボタンと離れた場所にメニューが存在する場合、フォーカス移動先が予想外の要素になることがあります。その場合、WCAG 2.1達成基準2.4.3「フォーカス順序」の問題も生じます。
https://www.w3.org/TR/WCAG21/#focus-order

＜太字黒見出し＞
方法3：aria-expanded属性を利用する
＜本文＞
WAI-ARIAには開閉状態を通知するaria-expanded属性があります。メニューが開いた際、〓13〓のように「aria-expanded=true」を追加します。

〓13〓aria-expanded属性を利用する例
＜コード＞
<button aria-expanded="true">


こうすると「メニュー ボタン 開いています」などと読み上げられます。同様に、メニューが閉じた際に「aria-expanded=false」を指定すると「メニュー ボタン 閉じています」などと読み上げられます（「隠されました」などと読み上げることもあります）。
aria-haspopup属性と同様、ボタンのラベルとあわせて読み上げることに注意してください。メニューが既に開いていて、ボタンのラベルが「メニューを閉じる」となっている場合、aria-expanded=trueを指定すると、「メニューを閉じる ボタン 開いています」と読み上げられます。これは冗長ですし、むしろ混乱を招くことがあります。
初期状態ではaria-expanded属性を付けないようにしておき、開いた時だけ「aria-expanded=true」を付ける方法もあります。この場合、メニューが閉じている時は「メニュー ボタン」と読み上げられ、開いている時は「メニュー ボタン 開いています」と読み上げられるようになります。

＜memo＞
実際にユーザーに伝わるかどうかは、文脈にもよります。ボタンのラベルや他のARIA属性も合わせた状態で実際に読み上げさせて、ボタンの挙動が伝わるか、逆に冗長になりぎていないかを検討するとよいでしょう。

＜本文＞
なお、この方法でも、開いたメニューがページ内のどこに存在するかはわかりません。`aria-controls`属性で制御対象を明示する方法もありますが、`aria-controls`属性で示した要素に移動するような機能を提供するいる支援技術は少数です。
`aria-controls`属性を指定すること自体は望ましいことですが、その機能に頼るべきではありません。基本的に、出現するメニューはメニューボタンの直後に置くことが望ましいでしょう。

＜memo＞
スクリーンリーダーのJAWSはaria-controls属性を認識し、ユーザーが特定の組み合わせのキーを押すことで、関連づけられた要素に移動することができます。ただし、移動先から元の要素に戻る機能は提供されていません。

＜小見出し＞
メニューの裏側にフォーカスが当たらないようにする
＜本文＞
一般的に、メニューを開いたとき、視覚環境ではメニューがコンテンツに覆いかぶさります。コンテンツはメニューの裏側に隠れて見えなくなり、メニューに隠されない部分があっても、暗転して操作できない状態になります。
しかしキーボード操作の場合、メニューが開いた状態でも背後のコンテンツにフォーカスを移せてしまう場合があります。メニューの裏側の要素にフォーカスが移ると、視覚環境のキーボードユーザーはフォーカスを見失い、混乱することがあります（スクリーンリーダーのユーザーの場合、メニューが開いたままであることに気づかず、普通に利用できてしまうことが多いでしょう）。

＜memo＞
見えない要素にフォーカスが当たってしまう状況は、ユーザーにとって予想外のフォーカス移動になるため、WCAG 2.1の達成基準達成基準 2.4.3「フォーカス順序」の問題となります。
https://www.w3.org/TR/WCAG21/#focus-order

＜本文＞
このようなフォーカス順序の問題を避ける方法を検討していきます。

＜太字黒見出し＞
方法1：メニューの外の要素をすべてフォーカス不可能にする
＜本文＞
メニューが開いたときに、メニューの外の要素をすべてフォーカス不可能にするという方法です。実装方法は複数存在しますが、ここでは方針だけ紹介します。

・メニューの外側のフォーカス可能な要素すべてにtabindex=-1を指定する
・メニューの外側の要素すべてをdisplay: none;やvisibility: hiddenなどで削除する
・メニューをdialog要素として実装し、showModal()メソッドで呼び出す

＜memo＞
dialog要素については、Chapter3-9のdialog要素の項を参照してください。また、詳細な実装方法についてはWAI-ARIA Authoring Practicesを参照してください。

＜本文＞
なお、aria-hiddenはこの目的では利用できないことに注意してください。aria-hiddenを指定してもフォーカス移動には影響せず、フォーカスを受け取ってしまいます。スクリーンリーダーのユーザーは読み上げられない要素にフォーカスを奪われ、混乱することになります。

＜太字黒見出し＞
方法2：フォーカス移動するときにメニューの先頭に戻す
＜本文＞
メニューからフォーカスが外に出るのは、メニューの最後の要素からさらにフォーカス移動しようとした時です。そのタイミングで「<kbd>Tab</kbd>」キーの挙動をフックして、メニューの先頭に戻してしまえば、フォーカスはメニューの外に出られなくなます。
メニューの最後の要素にkeypressイベントを付けてフックする方法もありますが、フォーカストラップを利用する方法もあります。たとえば〓15〓のように、メニューの前後にtabindex属性を指定したdivを挿入します。


〓15〓tabindex属性を指定したdivを挿入
<コード＞
<div tabindex="0"></div>
  <ul id="menu01">
      <li><a href="/">ホーム</a></li>
      <!-- メニュー -->
  </ul>
<div tabindex="0"></div>

キーボード操作でメニューの外にフォーカスを出そうとした際、このdiv要素にフォーカスが当たります。このdiv要素にfocusイベントを付けておき、フォーカスが当たった時にフォーカスをメニューの先頭、もしくは末尾に移動します。
この際、フォーカスが脱出不能にならないように注意してください。メニューを閉じるボタンが押せなくなると、キーボードユーザーは操作不可能になってしまいます。

＜memo＞
フォーカスが脱出不能になると、WCAG 2.1達成基準2.1.2「キーボードトラップなし」の要件を満たせなくなります。これはレベルAの要求で、「非干渉」の条件にもなっている重要な基準です。
https://www.w3.org/TR/WCAG21/#no-keyboard-trap

＜本文＞
また、ユーザーはブラウザーのアドレスバーにフォーカスしたい場合に「<kbd>Shift+Tab</kbd>」キーで戻ることもあります。先頭の要素から前に戻ろうとすることは許容してもよいでしょう。

＜memo＞
スクリーンリーダーのユーザーは「<kbd>Tab</kbd>」キーを使用せずにフォーカスを移動できる場合もあります。また、フォーカスを移動せずに外の要素を読み上げられることもあります。もっとも、スクリーンリーダーのユーザーは視覚的にフォーカスを見失っても困らないため、そこまで気にしなくてもよいでしょう。

＜太字黒見出し＞
方法3：フォーカス移動しようとした場合にメニューを自動的に閉じる
＜本文＞
方法2と似ていますが、フォーカスをメニューの先頭に戻すかわりに、メニューを閉じるという方法もあります。実装方法は基本的に方法2と同様で、フォーカスをトラップした際の処理をメニューを閉じる処理に変更するだけです。
ただし、メニュー項目にフォーカスしたままメニューを閉じると、フォーカスが行方不明になってしまうため、メニューを閉じた際には、フォーカスを適切な場所に移動する必要があります。通常は、メニューを開く直前にフォーカスがあった場所、つまりメニューボタンにフォーカスを戻すとよいでしょう。
ただし、この方法には欠点もあります。ユーザーはメニューが閉じることを予測できませんし、メニューが閉じたことに気づかないことがあります。これは混乱の原因になります。たとえば、メニューが閉じた後で<kbd>Shift+Tab</kbd>キーを押しても、直前のメニュー項目に戻ることはできず、予想外の場所にフォーカスが移ってしまいます。
また、メニューが長い場合、閉じてしまったメニューを開き直した上で、またメニュー項目を先頭から読み上げていくことになります。ユーザーが大きなストレスを感じることもあるでしょう。

＜中見出し＞
事例2：カルーセルのライブラリを選定する
＜本文＞
「カルーセル（Carousel）」とは、回転木馬、メリーゴーランドの意味です。ウェブでは、画像やカードなどが横に並び、左右にスライドして順繰りに表示されるようなコンポーネントを指します。スライドショーと呼ばれたり、イメージローテーターと呼ばれることもあります〓16〓。

〓16〓左右のスライドが見切れているカルーセルの例

カルーセルにはさまざまなパターンが見られますが、一般的には以下のような機能を持ちます。

・複数の「スライド（slide）」を持ち、順番に表示することができる。スライドには画像やカードなど、視覚的に提示される項目が含まれる
・1度に表示するスライドは1つだけ（ただし、左右に見切れた状態で前後のスライドが表示されることはある）
・ユーザーの操作により、次のスライド、前のスライドを表示させることができる。多くの場合、カルーセル領域の左右に矢印状のボタンが表示される
・表示されているスライドをクリックすると、そのスライドに対応するリンク先に遷移する。

また、これらに加えて以下の機能を持つケースも見られます。

・「スライドピッカーコントロール（Slide Picker Controls）」を持つ。これはスライドが全部で何枚あり、現在表示中のものが何番目かを示すインジケータであり、インジケータ部分をクリックすると、対応するスライドを直接表示させることもできる。多くの場合、カルーセル領域の下部に、円が横に並んだ形で表示される
・ページが読み込まれると同時に自動的にカルーセルの回転が始まる
・スライドにマウスポインターが乗った場合や、キーボードフォーカスが移った場合に、カルーセルの自動回転を停止する
・「ローテーションコントロール（Rotation Control）」を持つ。これは、カルーセルの自動回転を停止・再開できる機能で、多くの場合、オーディオ機器の一時停止・再生ボタンを模したボタンで表現される

カルーセルは多数の機能を持つ複雑なものです。これらのすべてを自前で実装するのはかなり大変です。実際にカルーセルを扱う場合、専用のライブラリを利用するケースが多いでしょう。カルーセルのライブラリには、アクセシビリティに配慮したものもあれば、していないものもあります。ここでは、ライブラリを選定するときに注意したいポイントを見ていくことにしましょう。
なお、すべてを自前で実装する必要がある場合は、WAI-ARIA Authoring Practicesの3.6 Carousel （Slide Show or Image Rotator）やWeb Accessibility TutorialsのCarouselを参考にするとよいでしょう。

＜memo＞
3.6 Carousel (Slide Show or Image Rotator)
https://www.w3.org/TR/wai-aria-practices/#carousel

＜memo＞
Web Accessibility Tutorials Carousel
https://www.w3.org/WAI/tutorials/carousels/

＜小見出し＞
キーボード操作が可能か
＜本文＞
カルーセルもキーボードで操作できなければなりません。ライブラリ選定時には、動作サンプルをキーボードで実際に操作してみるとよいでしょう。特に問題になりやすいのは以下の点です。

・現在表示されているスライドにフォーカスし、リンクを辿ることができるか
・隠れているスライドにフォーカスがあたってしまい、フォーカスが行方不明になることはないか
・次のスライド/前のスライドボタンにフォーカスし、操作できるか
・スライドピッカーコントロールにフォーカスし、操作できるか
・ローテーションコントロールにフォーカスし、操作できるか

キーボードフォーカスが見えなくなっていて事実上操作できないケースもよく見かけます。フォーカスが明確に見えるかどうかも確認しましょう。

＜太字黒見出し＞
フォーカス時の自動停止
＜本文＞
カルーセルが自動回転する場合、スライドにフォーカスを移したタイミングでスライドが動くと、フォーカスが行方不明になることがあります。多くのカルーセル実装では、スライドにフォーカスしたときに自動回転を止めることで、これを防いでいます。
同様に、マウスポインタがスライドに乗ったときにも自動回転を止めることが一般的です。スライドをクリックする瞬間にスライドが切り替わると、意図しない遷移先に移動してしまうためです。このような配慮がなされているかどうかも確認しておきましょう。

＜小見出し＞
スクリーンリーダーで操作できるか
＜本文＞
視覚環境だけでなく、スクリーンリーダーで問題なく操作できるかどうかを確認しましょう。

・現在表示されているスライドが適切に読み上げられるか
・各種のボタンにラベルが付けられているか
・隠れているスライドが読み上げられて混乱することはないか

実装方法によっては、隠れているスライドまで読み上げれてしまうことがあります。スライドの内容によっては大きな問題ないケースもありますが、場合によっては混乱を招くこともあるので注意しましょう。自前で実装する場合は、隠れているスライドにaria-hiddenを適用するのも一つの方法です。ただし、aria-hiddenだけではキーボードフォーカスは当たってしまうことに注意してください。

＜太字黒見出し＞
他の箇所の読み上げを妨害しないか
＜本文＞
カルーセルが自動回転する場合、一つ重要な注意点があります。他の箇所を読み上げている場合にカルーセルの自動回転が起きたとき、どのように読み上げられるかという点です。
カルーセルのライブラリの中には、カルーセル領域をライブリージョンとして実装するものがあります。たとえば、Slickというライブラリの古いバージョンでは、〓17〓のようにカルーセル領域にaria-live="polite"を指定していました。

＜memo＞
Slick
https://kenwheeler.github.io/slick/

〓17〓カルーセル領域にaria-live="polite"を指定
＜コード＞
<div aria-live="polite" class="slick-list draggable">
  <!-- カルーセル領域 -->
</div>

カルーセルのスライドが切り替わると、その都度、内容が読み上げられます。カルーセルを手動で操作した時に読み上げられるのは問題ありませんが、ユーザーが他の場所を読んでいる場合でも、カルーセルが自動回転したタイミングで読み上げられることになります。
「aria-live=polite」の指定は、現在の読み上げに即座に割り込むのではなく、読み上げが一段落したところで割り込む指定となります。そのため理論上は、現在の読み上げは妨害されないことになっています。しかし実際には、ライブリージョンが読まれるとき、多くのスクリーンリーダーは単に内容を読み上げるだけで、それがライブリージョンであることは伝えません。ユーザーには、現在の場所と異なる場所が読まれたことがわからない場合があります。たとえば、見出しを読み上げているときにカルーセルが切り替わると、見出しのテキストに続けてそのままカルーセルの内容が読み上げられ、ひと続きの内容であるように聞こえます。これはユーザーを大いに混乱させる要因になります。
カルーセルにライブリージョンを採用しているライブラリを使わざるを得ない場合、スライドのテキストを工夫して、これがスライドであると明確にわかるようにするとよいでしょう。たとえば、テキストの頭に「【広告】」と入れる、といった方法です。
カルーセルを自前で実装する場合、ライブリージョンを使う必要があるかどうかは慎重に検討してください。どうしても利用する必要がある場合は、ユーザーがカルーセル領域から離れたときに「aria-live=off」に切り替えるか、カルーセルの自動回転を止めるようにするとよいでしょう。

小見出し＞
ローテーションコントロールがあるか
＜本文＞
ローテーションコントロールは、自動回転するカルーセルを停止する機能です。自動でスライドが切り替わり続けるカルーセルは多く見られますが、その一方で、スライドを停止する機能が提供されないことがあります。カルーセルが自動回転する場合、ローテーションコントロールが提供されていること、それがアクセシブルであることを確認しましょう。
WCAG 2.1の達成基準2.2.2 Pause, Stop, Hideは、動き続けるコンテンツが停止できることを求めています。これはレベルAの要求で、「非干渉」の条件にもなっている重要な基準です。WCAGへの対応が求められる場合には、この基準を必ず満たさなければなりません。

＜memo＞
2.2.2 Pause, Stop, Hide
https://www.w3.org/TR/WCAG21/#pause-stop-hide

＜中見出し＞
事例3：タブのマークアップを検討する
＜本文＞
「タブ（Tabs）」は、複数のコンテンツを切り替えて表示する機能です。典型的には、パーツ一式の上部に「タブリスト（Tab List）」があり、下部にコンテンツが入る「タブパネル（Tab Panel）」があります。タブリストの中には「タブ（Tab）」が並び、いずれかのタブを選択すると、タブパネルが対応するものに切り替わります〓18〓。

〓18〓タブの例（WAI-ARIA Authoring Practicesより）

タブは以下のような機能を持ちます。

・複数のタブとタブパネルから構成される。タブとタブパネルは一対一対応している
・タブリスト内のすべてのタブは見えている状態になっており、初期状態ではいずれか一つのタブが選択されている
・タブパネルは、選択されているタブに対応したものだけが表示され、他のタブパネルは見えない
・他のタブをクリックすると、そのタブが選択状態になり、選択したタブに対応するタブパネルが表示される。他のタブパネルは表示されなくなる

タブがキーボード操作を受け付ける場合、以下のような操作になるのが一般的です。

・タブリストにフォーカスを移すと、選択されているタブがアクティブになる
・キーボードの左右キーを押すと、左右にある他のタブを選択することができる

キーボードの左右キーによる操作は、他のウェブコンポーネントではあまり見られない、独自のものとなっています。これは、OSが提供するタブコントロールの操作に合わせたものです。
ウェブコンテンツでは、タブのような見せ方は頻繁に使われます。実際に現場でマークアップを行う機会も多いでしょう。ここでは、タブのマークアップについていくつかのパターンを検討しながら、考え方の過程を見ていきます。

＜小見出し＞
タブのマークアップと実装
＜本文＞
HTMLにはタブを表現する要素がありませんが、WAI-ARIAでは、タブの部品に対応するロールが用意されています。

・タブ ：tab
・タブリスト：tablist
・タブパネル：tabpanel

各部品にこれらのロールを適用していきます。では、実際にどのようなマークアップにするべきか検討していきましよう。

＜太字黒見出し＞
タブ
＜本文＞
タブはユーザーの操作の対象となる要素です。タブをクリックしたとき、タブパネルが切り替わるようにする必要があります。また、キーボードフォーカスを受け取る必要もあります。これらの機能をすべて自前で実装することも不可能ではありませんが、お勧めしません。フォーカスを受け取れる要素、a要素かbutton要素のいずれかを使うべきでしょう。WAI-ARIA Authoring Practicesのタブの例ではbutton要素を使用していますが、a要素が使われることもあります。

＜memo＞
WAI-ARIA Authoring Practices tabpanel
https://www.w3.org/TR/wai-aria-practices/#tabpanel

タブにはaria-controls属性を指定して、このタブに対応するタブパネルを示すようにします。一部のスクリーンリーダーでは、対応するタブパネルにジャンプできるようになります。
id属性を指定しておくと、タブのラベルをaria-labelledbyで参照できるようになります。これは後述のタブパネルで利用します。
また、JavaScriptで以下の属性を付けます。これらの値は、タブが切り替わったときに動的に変化する想定です。

・aria-selected属性 : このタブが現在選択されているかどうかを示します。選択されているタブには"true"、そうでないタブには"false"を指定します。
・tabindex属性 : 選択されていないタブに「tabindex=-1」を指定します。前述のように、キーボード操作ではタブにフォーカスしてから左右キーでタブを切り替える想定となるため、選択されていないタブには直接フォーカスが当たらないようにします。

タブが3つある場合、たとえば〓19〓のようなマークアップになります。aria-selectedとtabindexはJavaScriptで動的に付けられている想定です。

〓19〓3つのタブがある場合のマークアップ
＜コード＞
<button type="button" role="tab" id="tab01" aria-controls="tabpanel01"
 aria-selected="true">タブその1</button>
<button type="button" role="tab" id="tab02" aria-controls="tabpanel02"
 aria-selected="false" tabindex="-1">タブその2</button>
<button type="button" role="tab" id="tab03" aria-controls="tabpanel03"
 aria-selected="false" tabindex="-1">タブその3</button>

タブには必ずラベルを付けるようにしてください。上記の例のように、要素の中にラベルテキストが入っていれば問題ありません。タブにテキストを持たせられないような場合は、aria-labelでラベルを与えることを検討しましょう。タブパネルに見出しが含まれており、その見出しのテキストをそのままタブのラベルにできるならば、その見出しにIDを付けてaria-labelledbyで参照してもよいでしょう。

＜太字黒見出し＞
タブリスト
＜本文＞
タブリストは、タブが列挙される部分です。tablistロールを適用しますが、どのHTML要素を採用するかは議論の余地があります。
ARIA in HTMLでは、menu、ol、ul、nav要素にtablistロールが適用できることになっています。他にも、すべてのロール（Any role）が適用可能とされている要素にはtablistロールを適用できます。候補としてはpやdivなどがあります。なお、dl要素にはtablistロールを指定することができないため、候補にはなりません。
タブリストにはタブが複数列挙されますし、名前に「リスト」とついていますから、ulは有力候補です。しかし、WAI-ARIAのtablistロールはlistロールと派生関係になく、listitemの親にはなれません。ulのロールをtablistに変更すると、li要素のlistitemロールが宙に浮くことになります。liにtabロールを指定することも可能ですが、先に述べたようにtabロールはbuttonかaに指定したほうがよいでしょう。そうすると、liにはrole=presentationを指定することになります
ulを使っても、結局はリストの意味を失わせることになりますので、最初からdivを使うという考え方も有力です。実際、WAI-ARIA Authoring Practicesのタブの例ではdiv要素を使用しています。どちらが正解というわけでもなく、前後の文脈や互換性など、周辺の事情を考えて採用するとよいでしょう。後述の「タブと他の見せ方を切り替える」の項も参照してください。

＜太字黒見出し＞
タブパネル
＜本文＞
タブパネルは実際に表示される内容を含む部分で、tabpanelロールを適用します。
tabpanelロールは、ARIA in HTMLではsection要素に適用可能とされています。そのほか、任意のロールを適用可能な要素で利用できますが、タブパネルの中にさまざまな要素が入る可能性を考えるとp要素などは使いにくく、事実上section要素とdiv要素のどちらかになります。タブパネルの中に見出しが入ってセクションとして成立しているならばsection要素、そうでなければdiv要素を利用するのがよいでしょう。

＜memo＞
WAI-ARIA Authoring Practicesのタブの例ではdiv要素を使用しています。

タブからaria-controlsで参照するために、タブパネルにはid属性を指定します。
タブパネルをフォーカス可能にする場合、タブパネルにはラベルを付けるべきです。通常は、タブのラベルをそのまま使えるはずなので、タブにIDを付けてaria-labelledbyで参照するとよいでしょう。タブパネルの中に見出しが含まれる場合は、見出しにIDを付けて参照してもよいでしょう。ラベルにふさわしいテキストがどこにもない場合は、aria-labelでラベルを付けることも可能です。
タブパネルはたとえば〓20〓のようなマークアップになります。

〓20〓タブパネルのマークアップ
＜コード＞
<div tabindex="0" role="tabpanel" id="tabpanel01" aria-labelledby="tab01">
<!-- タブパネルの内容 -->
</div>
<div tabindex="0" role="tabpanel" id="tabpanel02" aria-labelledby="tab02" hidden>
<!-- タブパネルの内容 -->
</div>
<div tabindex="0" role="tabpanel" id="tabpanel03" aria-labelledby="tab03" hidden>
<!-- タブパネルの内容 -->
</div>


表示されていないタブパネルは、JavaScriptでhidden属性を指定して非表示にします。CSSの優先度によっては、hidden属性で要素を隠せないこともあるかもしれません。その場合は、class属性にクラス名を与えてCSSで非表示にしてもよいでしょう。
通常、aria-hiddenを利用する必要はありません。非表示のタブパネルは視覚環境からも隠されるべきもので、典型的にはCSSのdisplay:noneを適用して、視覚環境とスクリーンリーダーの双方から隠されるようにします。演出上の都合など何らかの理由でdisplay:noneを適用できず、非表示のタブパネルがスクリーンリーダーで読み上げられてしまうような場合には、aria-hiddenの利用を検討してもよいでしょう。

＜太字黒見出し＞
スクリプト実装
＜本文＞
これでマークアップは完成です。あとは、JavaScriptを実装して動作するようにします。
具体的なコード例についてはWAI-ARIA Authoring Practicesに譲りますが、タブがクリックされた場合だけでなく、タブにフォーカスしたときのキーボード操作も忘れずに実装します。keypressイベントではカーソルキーの操作を取得できないので、keydownイベントとkeyupイベントを利用します。

＜小見出し＞
タブと他の見せ方を切り替える
＜本文＞
インターフェイスを導入する大きな目的の一つは、画面スペースの節約です。タブ操作によって表示を切り替える仕組みを導入することで、狭いスペース内で多くの情報を見せることができるようになります。
逆に言えば、画面スペースによっては、必ずしもタブインターフェイスが最適ではないかもしれません。たとえば、レスポンシブデザインを採用して、画面が狭い時にはタブで表現し、広い時にはすべてを展開して見せたいと考えるケースもあるでしょう。
タブインターフェイスを構成する要素は、ページ内リンクの目次と相性がよいことが知られています。タブリストは目次のリスト、タブは目次内のリンク、タブパネルはリンク先のセクションに対応します〓21〓。

〓21〓タブインターフェイスの記述例
＜コード＞
<ul>
  <li><a href="#section01">セクション1</a></li>
  <li><a href="#section02">セクション2</a></li>
  <li><a href="#section03">セクション3</a></li>
</ul>
<section>
  <h2 id="section01">セクション1</h1>
  <p>セクション1の内容...</p>
</section>
<section>
  <h2 id="section02">セクション2</h1>
  <p>セクション2の内容...</p>
</section>
<section>
  <h2 id="section03">セクション3</h1>
  <p>セクション2の内容...</p>
</section>


このようなページ内リンクをタブに仕立て上げることができます。JavaScriptでrole属性を付与して〓22〓のようにします。

〓22〓role属性を付与
＜コード＞
<ul role="tablist">
  <li role="none"><a role="tab" href="#section01">セクション1</a></li>
  <li role="none"><a role="tab" href="#section02">セクション2</a></li>
  <li role="none"><a role="tab" href="#section03">セクション3</a></li>
</ul>
<section role="tabpanel" aria-labelledby="section01">
  <h2 id="section01">セクション1</h1>
  <p>セクション1の内容...</p>
</section>
<section role="tabpanel" aria-labelledby="section02">
  <h2 id="section02">セクション2</h1>
  <p>セクション2の内容...</p>
</section>
<section role="tabpanel" aria-labelledby="section03">
  <h2 id="section03">セクション3</h1>
  <p>セクション2の内容...</p>
</section>


他にも細かい属性やイベントを付ける必要がありますが、タブとして成立することはわかるでしょう。このようにすると、状況によってページ内リンクの見せ方とタブの見せ方とを切り替えることが可能になります。また、JavaScriptが動作しない環境でも、ページ内リンクとして成立させることができます。

＜太字黒見出し＞
タブの操作方法をあえて実装しない選択
＜本文＞
上記の例ではページ内リンクをタブの見せ方にするだけでなく、タブ関連のロールと機能を適用して、実際にタブとして動作させることを想定しています。タブになると、キーボードでの操作方法は変化します。ページ内リンクだった場合は、「<kdb>Tab</kbd>」キーでリンクに次々とフォーカスしていき、希望のリンクを選択するという方法でした。タブになると、現在選択されているタブにフォーカスし、左右キーでタブを選ぶという方法になります。
しかし、この操作方法の変更は本当に必要なのでしょうか。見せ方だけ変えて操作は変えず、ロールも変えず、そのままページ内リンクとして操作させるという考え方もあります。タブを提供するコンテンツがウェブアプリケーションである場合は、デスクトップアプリケーションと同じ操作感が求められることがあります。その場合には、タブはタブとして操作できた方がよいでしょう。そうではなく、単に単に省スペースを目的としてタブの見せ方にしているだけであれば、ページ内リンクの操作方法でも問題ないことが多いでしょう。
ただし、リンクをクリックした場合の挙動には注意してください。ページ内リンクの場合、リンクをクリックすると該当箇所までスクロールし、明確に画面が変化するのが基本の動作です。しかし、タブの見せ方にした場合、リンクを押しても画面がスクロールしない場合があります。画面を拡大しているユーザーの場合、タブの部分を画面いっぱいに拡大していると、その外で起きた変化に気づかず、何が起きたかわからないことがあります。リンクを押したときに、対応する見出しにフォーカスを移すなどして対応するとよいでしょう。

＜中見出し＞
事例4：モーダルダイアログ
＜本文＞
「ダイアログ（dialog）」は、ウェブコンテンツの上に覆いかぶさるように出現するウィンドウ領域です。基本的には、ユーザーに対して注意を促したり、何かを入力させるために用います。ダイアログには、大きく分けて2つのモードがあります。

・モーダルダイアログ（modal dialog）：ダイアログが出現するとダイアログに対して操作を行うモードになり、その間、ダイアログ以外の要素を操作できくなるもの
・モードレスダイアログ（modeless dialog）：ダイアログが出ても他のコンテンツを引き続き操作できるもの

モーダルダイアログの場合、他のコンテンツが操作できないことがわかるように、ダイアログの外を暗くする演出が一般的です〓23〓。

〓23〓モーダルダイアログのイメージ図

ウェブではモードレスダイアログはあまり利用されません。他のコンテンツを引き続き操作できる場合、ダイアログではない見せ方をすることが多いでしょう。モーダルダイアログはしばしば利用されます。ここでは、モーダルダイアログの実装についていくつかの方法をとりあげ、内容を見ていくことにします。

＜小見出し＞
window.confirmによる簡易なダイアログ
＜本文＞
簡易なダイアログであれば、JavaScriptの機能だけで簡単に実装することができます。window.confirm()を利用すると、ユーザーにOKかキャンセルかの2択を問うモーダルダイアログを出すことができます。〓24〓は、フォームをリセットする場合に警告のダイアログを出す例です。表示例は〓25〓となります。

〓24〓警告のダイアログの例
＜コード＞
<form onreset="return confirm('フォームの内容を全て初期化します。よろしいですか?')">
    <input value="初期値">
    <button>送信</button>
    <button type="reset">リセット</button>
</form>


〓25〓24〓の表示例

ユーザーがキャンセルボタンを押した場合はconfirm()の戻り値がfalseとなり、return falseが実行されてリセットの動作がキャンセルされる仕組みになっています。イベントハンドラー属性の項も参照してください。
このダイアログはブラウザの機能でできているため、ダイアログの見た目を制御することができません。見た目はブラウザによって異なりますが、ほとんどの場合は非常にシンプルな見た目になります。とはいえユーザーに対して簡潔にYes/Noを問うだけでよいシーンでは機能として十分でしょう。

＜小見出し＞
dialog要素によるダイアログ
＜本文＞
HTMLには、ダイアログを表示するためのdialog要素が用意されています。showModal()メソッドを呼ぶとモーダルダイアログとして呼ぶことができます〓26〓。表示例は〓27〓となります。


〓26〓dialog要素によるダイアログの例
＜コード＞
<dialog id="dialog1">
  <form method="dialog">
    <p>OKですか?</p>
    <button type="submit" value="OK">OK</button>
    <button type="submit" value="Cancel">Cancel</button>
  </form>
</dialog>
<script>
  const d = document.getElementById('dialog1');
  const dialogOpen = () =>{
      d.showModal();
      d.onclose = () => {alert (d.returnValue)};
  }
</script>
<button type="button" onclick="dialogOpen()">ダイアログを開く</button>

〓27〓〓26〓の表示例

単にこれだけで、モーダルダイアログの外にある要素を暗く表示し、操作できないようにするところまで実現します。dialog要素にはダイアログとしてのネイティブのセマンティクスもあるため、role属性を追加する必要もありません。
なお、初期状態でダイアログを隠す処理も実現されていますが、単にユーザーエージェントのスタイルシートで「dialog:not([open]){display:none;}」というスタイルが与えられているだけです。より強いセレクターでdisplayプロパティを上書きすると、ダイアログが表示されてしまうこともあるので注意してください。
dialog要素は非常に便利なのですが、残念なことにブラウザによるサポートはまだ不十分です。2021年8月現在、iOSとmacOSのSafariがdialog要素をサポートしていません。

＜memo＞
MDN Web Docs ダイアログ要素
https://developer.mozilla.org/ja/docs/Web/HTML/Element/dialog

ブラウザの種類を限定できる業務アプリでは問題なく利用できるかもしれませんが、そうでない場合、Safariでサポートされていない機能を採用することは難しいでしょう。

＜小見出し＞
WAI-ARIAを駆使した実装
＜本文＞
dialog要素をサポートしないブラウザーを想定すると、他の要素とWAI-ARIAを組み合わせて自前でダイアログを実装する選択肢が現実的になります。ダイアログのマークアップは、たとえば〓28〓のようになります。

〓28〓ダイアログのマークアップ例
＜コード＞
<div id="dialog_layer" class="dialogs">
  <div tabindex="0"></div>
  <div id="dialog4" class="dialog"
    role="dialog"
    aria-labelledby="dialog_label"
    aria-describedby="dialog_desc"
    aria-modal="true">
    <h2 id="dialog_label">ダイアログの見出し</h2>
    <p id="dialog_desc">
      ダイアログのメッセージ...
    </p>
    <!-- その他さまざまな中身が入る -->
    <button type="button"
      id="dialog_close_button">
      <img src="close.png" alt="閉じる">
    </button>
  </div>
  <div tabindex="0"></div>
</div>

div要素にdialogロールを指定して、ダイアログであることを示します。ダイアログが警告やエラーを表示する場合は、かわりにalertdialogロールを指定します。
aria-labelledby属性で見出しを、aria-describedby属性でメッセージを提供しています。これにより、ダイアログにフォーカスすると、スクリーンリーダーで見出しとメッセージが読み上げらるようになります。この例ではダイアログの内部に見える形で見出しと説明文があるため、それらを利用して結びつけています。見える形のテキストラベルがない場合は、aria-label属性などを利用してもよいでしょう。
「aria-modal="true"」により、このダイアログがモーダルであることを示しています。aria-modalに対応した支援技術の場合、これだけでモーダルの外の要素を操作できないようにする場合があります。とはいえ、この処理は仕様上必須とはされておらず、対応していない支援技術もあるため、モーダルダイアログの外の要素が読まれないようにしたり、キーボードフォーカスを制御する処理の実装も必要です。
キーボードフォーカスの制御のために、ダイアログの前後に<div tabindex="0"></div>を挿入しています。これは、ハンバーガーメニューの事例で紹介したフォーカストラップです。JavaScriptによるDOM操作でdivを挿入してfocusイベントを付けておき、フォーカスをトラップする制御を行います。
モーダルダイアログの内部には、閉じるボタンを置きます。aria-modalを指定するとダイアログの外側にアクセスできなくなることがあるため、ダイアログを開いたボタンをトグルさせたい場合などは、ボタンが必ずダイアログの内部に来るように配慮してください。また、「<kbd>Esc</kbd>」キーが押されたときにダイアログが閉じるようにしておくとよいでしょう。
あとはJavaScriptで動作を制御するだけですが、コードは長くなるため、ここでは紹介しません。具体的なJavaScriptのコードやその他の細部については、WAI-ARIA Authoring Practicesのdialogの例を参考にしてください。

＜memo＞
WAI-ARIA Authoring Practices dialog
＜本文＞
https://www.w3.org/TR/wai-aria-practices/examples/dialog-modal/dialog.html


＜中見出し＞
事例5：インラインSVGのアクセシビリティを担保する
＜本文＞
SVGは、XML形式のデータでベクター形式の画像を表現する技術です。img要素のsrc属性でSVGファイルを参照すれば画像として扱うことができますが、HTMLのsvg要素を利用すると、HTMLコンテンツにインラインでSVGを埋め込むことが可能になります。こうすると、JavaScriptからのDOM操作でSVGの内容も制御することができます。
このような利用法をする場合、SVGのアクセシビリティについて考える必要があります。ここでは、svg要素を利用してSVGをインラインで記述する場合のアクセシビリティの考慮点について見ていきます。

＜小見出し＞
svg要素のロール
＜本文＞
SVGの用途は様々ですが、ウェブコンテンツでは、純粋に画像として利用するケースが多いでしょう。img要素でSVG画像を埋め込む代わりに、インラインのsvg要素を利用するという使い方です。
この場合、svg要素のロールがimg要素とは異なる点に注意が必要です。SVG2の仕様、およびARIA in HTML仕様では、svg要素はデフォルトでgraphics-documentロールを持つとされています。このロールはWAI-ARIA仕様ではなく、WAI-ARIA Graphics Module仕様で定義されています。

＜memo＞
5.13.4. Implicit and Allowed ARIA Semantics
https://www.w3.org/TR/SVG2/struct.html#implicit-aria-semantics

＜memo＞
WAI-ARIA graphics-document
https://w3c.github.io/graphics-aria/#graphics-document

graphics-documentロールをは文書を表すdocumentロールから派生したもので、画像よりも文書に近い性質を持つものです。SVGにはテキストを含めこともでき、テキストをレイアウトして配置するような使い方も可能で、それ単独でドキュメントとして成立することもあります。つまり、iframe要素に近い性質を持つものと捉えられているのです。
ウェブコンテンツでSVGを利用する場合、SVGの用途を確認しましょう。単に画像として扱っている場合は、role=imgを指定して、明示的にimgロールを付与するとよいでしょう。

＜小見出し＞
画像の代替テキストと説明を提供する
＜本文＞
意味のある画像には代替テキストを与える必要があります。img要素のsrc属性でSVGファイルを参照した場合には、alt属性で代替テキストを与えます。
svg要素を使ってインラインでSVGを記述した場合、alt属性を利用することはできません。svg要素にはtitle属性も指定できません。
インラインSVGの場合、svg要素直下のtitle要素がアクセシブルな名前として利用されることになっています〓29〓。

〓29〓インラインSVGの記述例
＜コード＞
<svg role="img">
  <title>図: XX会社の組織図</title>
  ...
</svg>

なお、svg要素には、aria-label属性やaria-labelledby属性を指定することが可能です。それらの属性があれば、そちらが優先されます。SVGにおけるアクセシブルな名前の算出方法については、SVG-AAM仕様の8.special Processing Requiring Additional Computationを参照してください。

＜memo＞
8.special Processing Requiring Additional Computation
https://w3c.github.io/svg-aam/#mapping_additional

説明文についても同様です。aria-describedby属性が利用できる他、SVG内にdesc要素があればアクセシブルな説明として利用されます〓30〓。

〓30〓SVG内にdesc要素を記述した例
＜コード＞
<svg role="img">
  <title>図: XX会社の組織図</title>
  <desc>XX会社の組織図です。頂点にはXX組織があり...</desc>
</svg>

インラインでSVGを使用するときは、画像の代替テキストと説明文をSVGの中で与えるようにしましょう。それができない場合は、aria-label属性やaria-describedby属性を利用します。

＜小見出し＞
装飾的なSVG画像を無視させる
＜本文＞
SVGが意味を持たない、純粋に装飾的な画像である場合は、支援技術に無視させる必要があります。img要素の場合はalt=""を指定しますが、svg要素の場合はaria-hidden属性を用います。この場合、role属性を指定する必要はありません〓31〓。

〓31〓svg要素にaria-hidden属性を指定
＜コード＞
<svg aria-hidden="true">
  <!-- 純粋に装飾的な画像 -->
  ...
</svg>

＜中見出し＞
テストを行う
＜本文＞
ここまで、WAI-ARIAを利用する事例を紹介してきました。HTMLだけでアクセシビリティを担保できない場合に、WAI-ARIAを利用することで、アクセシビリティを向上できることがあります。
しかし、常にWAI-ARIAを利用するのがよいわけではありません。WAI-ARIAの実践例を多数紹介しているWAI-ARIA Authoring Practicesで、2.1節の見出しに「No ARIA is better than Bad ARIA」とあります。これはARIAを不適切に利用するくらいなら、使わない方がよいという意味です。

＜memo＞
2.1 No ARIA is better than Bad ARIA
https://www.w3.org/TR/wai-aria-practices/#no_aria_better_bad_aria

ここでも見てきたように、WAI-ARIA以外の手段のほうがよいケースや、WAI-ARIAを無理に使わなくても十分に伝わり、WAI-ARIAによる補足がむしろ冗長になるケースなどもあります。
では、WAI-ARIAの利用が適切かどうかは、どうやって判断すればよいのでしょうか。
筆者は、実際にテストしてみることがほぼ唯一の解であると考えています。
テストといっても、大掛かりなものである必要はありません。実際にスクリーンリーダーなどの支援技術を用いてアクセスしてみればよいのです。近年ではOSに標準でスクリーンリーダーの機能が搭載されていますから、それを利用するだけでもよいでしょう。
そして、もし可能であれば、普段からその支援技術を利用している当事者にアクセスしてもらって、その意見を聞くとよりよいでしょう。説明が冗長であるというような感想は、コンテンツを実装した本人からはなかなか出てこないものです。
アクセシビリティに唯一の正解はありませんが、WAI-ARIAを利用するのは、支援技術でもコンテンツにアクセスしやすくしたいという動機によるものです。当事者に支援技術で実際にコンテンツにアクセスしてもらい、フィードバックを得ることで、品質を向上できるでしょう。
