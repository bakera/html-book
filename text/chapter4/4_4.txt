＜タイトル＞
WAI-ARIAの実践
＜リード＞
ここでは、実際にウェブでよく使われるウィジェットの事例を通じて、WAI-ARIAをどのように利用するのか、その検討の過程や考え方について紹介します。

＜中見出し＞
事例1： ハンバーガーメニューを改良する
＜本文＞
モバイル用のページでは、通常はメニューを隠しておき、ボタンを押すことでメニューが開く仕組みがよく見られます。〓01〓のように、メニューを開くボタンが3本の横棒で表現されたものは「ハンバーガーメニュー」と呼ばれます。一般的なハンバーガーメニューは、以下のような機能を持ちます。

・ユーザーがボタンを押すと、メニューが出現する
・メニューにはサイト内の主要なコンテンツへのリンクが含まれる
・メニューはコンテンツに覆いかぶさるような形で現れ、メニューが開いている間はメニューの外のコンテンツは利用できない
・メニューが出現すると、メニューを開くボタンはメニューを閉じるボタンに変化する
・閉じるボタンを押すとメニューは消え、元の状態に戻る

＜memo＞
詳細なコード例についてはWAI-ARIA Authoring Practicesなどを参照してください。
https://www.w3.org/TR/wai-aria-practices/

〓01〓一般的なハンバーガーメニューの例

＜memo＞
参考サイト
弁護士ドットコム - 無料法律相談や弁護士、法律事務所の検索
https://www.bengo4.com/

＜本文＞
コンテンツ制作者にとってはおなじみのパーツですが、アクセシビリティ上の留意点がいくつかあります。深く考えずに作られたハンバーガーメニューは、たとえば〓02〓のようなマークアップになっていることがあります。

〓02〓ハンバーガーメニューのマークアップ例
＜コード＞
<div class="hamburgerMenu">
  <div class="button">
    <!-- 閉じている場合にのみ表示され、開くとdisplay:noneになる -->
    <span class="menu-icon"></span>
    <!-- 開いている場合にのみ表示され、閉じるとdisplay:noneになる -->
    <span class="close-icon"></span>
  </div>
  <ul>
    <li><a href="/">ホーム</a></li>
    <!-- メニュー -->
  </ul>
</div>


<div class="button">がボタンに相当します。中に入っている2つのspan要素は、それぞれハンバーガーアイコンと閉じるアイコンに相当し、CSSのbackground-imageを使用してアイコン画像を表示します。そして、〓02〓のようなJavaScriptでdivにclickイベントのイベントハンドラーを付け、動くようにします。

〓02〓ハンバーガーメニューのJavaScript
＜コード＞
const hamburgerMenu = document.querySelector('.hamburgerMenu');
const hamburgerMenuButton = hamburgerMenu.querySelector('.button');
hamburgerMenuButton.addEventListener('click', event => {
  hamburgerMenu.classList.toggle('js-opened');
});

さまざまなJavaScriptの実装方法が考えられますが、ここでは単純に、外側のdiv要素にjs-openedクラスを付けたり外したりしています。そして、〓03〓のようなCSSでメニュー項目のul要素を非表示にし、js-openedクラスが付いたときだけ表示されるようにします。

〓03〓ハンバーガーメニューのCSS
＜コード＞
.hamburgerMenu ul{
  display: none;
}
.hamburgerMenu.js-opened ul{
  display: block;
}
/* 実際には別のスタイル定義も必要だが省略 */

これでメニューボタンは動作しますが、このメニューにはアクセシビリティ上の問題点が複数あります。ここでは、このマークアップで作成されたメニューが既に存在すると仮定して、アクセシビリティを向上していく過程の考え方を紹介します。

＜memo＞
アクセシビリティを向上する手段の代表例がWAI-ARIAですが、Chapter4-3で紹介したように、WAI-ARIAを利用することが必ずしも望ましいとは限りません。ここでは、WAI-ARIAを利用する方法、しない方法の両方を含めて検討していきます。

＜小見出し＞
キーボード操作を可能にする
＜本文＞
このメニューの最大の問題は、キーボードで操作できないことです。メニューボタンはdiv要素で実装されています。clickイベントを付けているため、マウスでのクリックやタップには反応します。しかし、キーボードでは、そもそもボタンにフォーカスを当てることができません。
キーボード操作を可能にする方法はいくつかあります。

＜memo＞
キーボード操作は、WCAG 2.1の達成基準2.1.1「キーボード」で要求されているアクセシビリティ上の重要事項です。
https://www.w3.org/TR/WCAG21/#keyboard
Chapter4-3の「マウスやタッチで操作可能なものはキーボードでも操作可能にする」も参照してください。

＜太字黒見出し＞
方法1：button要素を使用する
＜本文＞
Chapter4-3でも触れてきたように、WAI-ARIAを使う前に、まずHTMLのネイティブ機能が使えないか検討すべきです。ここでは〓03〓のように、HTMLのbutton要素を使うことができます。

〓03〓
＜コード＞
<button>
  <span class="menu-icon"></span>
  <span class="close-icon"></span>
</button>

これだけでキーボード操作が可能になります。role属性もtabindex属性もkeypressイベントも必要ありません。button要素はそれらの機能を既に備えているからです。

＜太字黒見出し＞
方法2：a要素を使用する（非推奨）
＜本文＞
おすすめはしませんが、a要素でもフォーカスを受け取ることはできます。a要素にrole=buttonを指定すると、ボタンであると宣言することができます。
role属性の指定は単に役割を宣言するだけです。role=buttonを指定しても、ボタンと同じ挙動にはならないことに注意してください。
a要素はbutton要素とは動作が異なります。たとえば、button要素ではフォーカスしたあとにスペースキーでボタンを押すことができますが、a要素ではできません。可能な限りbutton要素を利用するべきです。

＜太字黒見出し＞
方法3：divのままキーボード操作可能にする（非推奨）
＜本文＞
まったくおすすめしませんが、何らかの理由でbutton要素が利用できない場合、div要素のままキーボード操作を可能にする方法もあります。〓04〓のように、tabindex=0とrole=buttonを指定すると、フォーカスが当たるようになり、スクリーンリーダーでも「ボタン」と読み上げられます。

〓04〓tabindex=0を指定した例
＜コード＞
<div class="button" role="button" tabindex="0">
  <span class="menu-icon"></span>
  <span class="close-icon"></span>
</div>


さらに、キーボード操作に対応するために、〓05〓のようなJavaScriptでkeypressイベントを付けます。

〓05〓keypressイベントをJavaScriptで追記
＜コード＞
hamburgerMenuButton.addEventListener('keypress', event => {
  // Enterキーやスペースキーでボタンが押せ、かつTabキーではボタンが押されないような実装...
});

このイベント内では、押されたキーを判定して、Enterキーやスペースキーならばボタンが押されるように、かつTabキーなどの操作を横取りしないように実装します。
繰り返しになりますが、この方法はおすすめしません。複雑で労力がかかる上に、考慮すべきことが多数あるために、考慮漏れも生じやすくなります。基本的にbutton要素を使うべきです。

＜小見出し＞
何のボタンかわかるようにする
＜本文＞
button要素を利用すると、スクリーンリーダーを使ってボタンにフォーカスを当てたとき、「ボタン」と読み上げられます。しかし、単に「ボタン」と読み上げられても、これが何をするボタンかはわかりません。
何のボタンかわかるようにするために、ボタンにラベルを与える必要があります。たとえば、「メニュー」というラベルを与えると、「メニュー ボタン」などと読み上げられ、何のボタンか伝わります。
ボタンにラベルを与える方法はいくつかあります。

＜太字黒見出し＞
方法1：画像をimg要素にしてaltでテキストを指定する
＜本文＞
Chapter3-9で紹介したとおり、button要素は、内容に含まれるテキストをラベルとして扱います。アイコンをCSSの背景画像で実装することをやめて、〓06〓のようにimg要素のalt属性で代替テキストを提供すれば、ラベルとして扱われることになります。

〓06〓alt属性でテキストを指定
＜コード＞
<button>
  <!-- 閉じている場合にのみ表示され、開くとdisplay:noneになる -->
  <span class="menu-icon"><img src="menu.png" alt="メニュー"></span>
  <!-- 開いている場合にのみ表示され、閉じるとdisplay:noneになる -->
  <span class="close-icon"><img src="close.png" alt="閉じる"></span>
</button>

＜memo＞
「メニュー」や「閉じる」アイコンは意味を持つ画像コンテンツと考えられます。WCAG 2.1達成基準1.1.1「非テキストコンテンツ」では、テキストによる代替を提供することが求められています。
https://www.w3.org/TR/WCAG21/#non-text-content

＜memo＞
img要素のalt属性については、Chapter3-7も参照してください。

＜本文＞
このようにすると、スクリーンリーダーで読み上げられることに加え、画像が表示できないケースや、通信速度の問題で画像を表示しないようにしている場合などに代替テキストが利用されることが期待されます。ただし、ブラウザーによっては代替テキストを表示しないこともあります。
なお、img要素を用いるこの方法は、サイトの高速化を意図した「CSSスプライト」と呼ばれる技法と相性が悪いという問題があります。最近はCSSスプライトが使われることも少なくなってきましたが、CSSスプライトの利用が必須である場合は、他の方法を考えましょう。

＜太字黒見出し＞
方法2：スクリーンリーダー用テキストを入れる
＜本文＞
button要素の中にテキストかあれば、ラベルとして扱われます。それは必ずしも、視覚的に見えている必要はありません。〓07〓のように、スクリーンリーダーで読み上げさせる専用のテキストを入れる方法もあります。

〓07〓スクリーンリーダー用テキストを記述
＜コード＞
<button>
  <span class="visually-hidden">メニュー</span>
  <span class="menu-icon"></span>
  <span class="close-icon"></span>
</button>

visually-hiddenは、視覚環境で表示されず、かつスクリーンリーダーでは読み上げられるようなスタイルを定義したクラスです。詳細はChapter4-3の「スクリーンリーダー向けテキストを提供する」を参照してください。
なお、単純にCSSのdisplay:noneの指定を用いると、スクリーンリーダーからも参照できなくなり、読み上げられなくなるため注意が必要です。

＜太字黒見出し＞
方法3：aria-label属性を利用する
＜本文＞
別の選択肢として、〓09〓のようにaria-label属性を利用する方法もあります。

〓09〓aria-label属性の記述例
＜コード＞
<button aria-label="メニュー">
  <span class="menu-icon"></span>
  <span class="close-icon"></span>
</button>

このようにすると、aria-labelに対応しているスクリーンのリーダーでは「メニュー ボタン」と読み上げることが期待できます。
ただし、aria-labelで指定したラベルは、支援技術のユーザーにしか伝わらないという問題があります。視覚環境において、何らかの理由でCSSが無効になった場合、方法1や方法2ではボタンのアイコンやラベルが見えますが、この方法ではボタンの内容がまったく表示されなくなります。
aria-labelの利用はスマートな方法に見えますが、おすすめできるものではありません。

＜太字黒見出し＞
方法4：aria-haspopup属性を利用する
＜本文＞
ボタンの意味を伝える方法には、ボタンにラベルを与える以外のアプローチもあります。〓10〓は、メニューボタンにaria-haspopup属性を指定した例です。

〓10〓aria-haspopup属性を指定する記述例
＜コード＞
<button aria-haspopup="menu">
  <span class="menu-icon"></span>
  <span class="close-icon"></span>
</button>

こうすると、aria-haspopupに対応したスクリーンリーダーでは、「ボタン メニュー ポップアップ」などと読み上げられます。ボタンにラベルはありませんが、押せばポップアップメニューが出現することは伝わります。

＜memo＞
aria-haspopupは、あくまでポップアップが現れることを知らせるものです。メニューがポップアップするのではなく、他の方法で出現する場合は、aria-haspopupを使用するべきではありません。

＜本文＞
ボタンにラベルがある場合、それもあわせて読み上げられます。ラベルが「メニュー」の場合は、「メニュー ボタン メニュー ポップアップ」と読み上げられます（「メニュー」が2回出現しますが、前者はボタンのラベル、後者はaria-haspopup属性の値です）。これは冗長になるため、ボタンのラベルだけで動作が十分に伝わる場合は、aria-haspopupを指定すべきでないという考え方もあります。
なお、このボタンが閉じるボタンに変化する場合、「メニュー ポップアップ」と読み上げられると混乱を招くため、動作にあわせてaria-haspopup属性を削除する必要があります。

＜小見出し＞
メニューの開閉状態がわかるようにする
＜本文＞
ここまでで、キーボード操作ができ、ボタンも「メニュー ボタン」と読み上げられるようになりました。これで、メニューボタンを利用できる最低限の条件は満たしています。
メニューを開いた際、視覚的には、メニューが開いたことは一目瞭然です。しかし、スクリーンリーダーのユーザーには、メニューが開いたかどうかはわかりません。
今回はボタンに「メニュー」というラベルを付けましたから、メニューが開いただろうと想像はできるでしょう。しかし、実際にどこがどう変化したかはわかりませんし、メニューの開閉状態、つまりメニューが開いているのか、閉じているのかもわかりません。
この問題について、対応を検討していきましょう。

＜太字黒見出し＞
方法1：開いたメニューにフォーカスを移す
＜本文＞
メニューが開いたことを伝える方法の1つは、開いたメニューにキーボードフォーカスを移してしまうことです。先のスクリプトにあったボタンクリック時のイベントに、〓11〓のようなフォーカス移動の処理を追加します。

〓11〓先頭のa要素にフォーカスを移動
＜コード＞
hamburgerMenuButton.addEventListener('click', event => {
  hamburgerMenu.classList.toggle('js-opened');
  hamburgerMenu.querySelector('ul a').focus(); // この行を追加 
});

こうすると、メニューを開くと同時に、メニューの先頭の項目にフォーカスが移動します。スクリーンリーダーはメニューの先頭の項目を読み上げ始めますから、メニューが開いたことは確実に伝わるでしょう。
この方法はわかりやすい反面、フォーカスを強制的に移動させる点に注意が必要です。HTMLソースコード上で、ボタンの直後にメニューが存在する場合は、直後の要素にフォーカスが移るだけ、元の位置に戻ることもできます大きな問題はありません。

＜memo＞
WCAG 2.1の達成基準 3.2.5「要求による変化」では、フォーカス移動のようなコンテキストの変化は、ユーザーの要求によってだけ生じるようにすることが望ましいとされています。この例では、ユーザーが「メニュー」というボタンを押すことによってフォーカスが移動しますから、この達成基準は抵触しません。
https://waic.jp/docs/WCAG21/#change-on-request

＜本文＞
メニューがボタンから離れている場合は、慎重な設計が必要です。メニューを開いたあと、ユーザーはShift+Tabキーでフォーカスを戻そうとするかもしれません。フォーカス移動先がHTMLのDOMツリー上で離れた位置にあると、Shift+Tabキーの操作では元に戻れない場合があります。出現するメニューは、メニューボタンの直後に置くことが望ましいでしょう。

＜memo＞
HTMLソースコード上、メニューがボタンとかけ離れた場所にある場合、WCAG 2.1達成基準1.3.2「意味のある順序」の観点でも問題となる場合があります。
https://www.w3.org/TR/WCAG21/#meaningful-sequence

＜太字黒見出し＞
方法2：ボタンのラベルで状態を伝える
＜本文＞
フォーカスを移さない場合、ボタンのラベルで現在の状態を伝える方法もあります。たとえば〓12〓のように、メニューが開くと同時にボタンのラベルを「メニューを閉じる」に変えるようにします。

〓12〓ボタンのラベルを変更
＜コード＞
<button>
  <!-- 閉じている場合にのみ表示され、開くとdisplay:noneになる -->
  <span class="menu-icon"><img src="menu.png" alt="メニュー"></span>
  <!-- 開いている場合にのみ表示され、閉じるとdisplay:noneになる -->
  <span class="close-icon"><img src="close.png" alt="メニューを閉じる"></span>
</button>


こうすると、ボタンを再度読み上げさせれば「メニューを閉じる ボタン」と読み上げられ、現在メニューが開いている（だから閉じることができる）と推測できるでしょう。
ただし、メニューが開いたことがわかっても、実際にメニューに移動できるかどうかは別の話です。HTMLソースコード上、ボタンの直後にメニューを挿入するか、前述の方法1のように、フォーカスを制御するとよいでしょう。

＜memo＞
見た目上はボタンの隣にメニューが表示され、しかしHTMLソースコード上ではボタンと離れた場所にメニューが存在する場合、フォーカス移動先が予想外の要素になることがあります。その場合、WCAG 2.1達成基準2.4.3「フォーカス順序」の問題も生じます。
https://www.w3.org/TR/WCAG21/#focus-order

＜太字黒見出し＞
方法3：aria-expanded属性を利用する
＜本文＞
WAI-ARIAには開閉状態を通知するaria-expanded属性があります。メニューが開いた際、〓13〓のようにaria-expanded=trueを追加します。

〓13〓aria-expanded属性を利用する例
＜コード＞
<button aria-expanded="true">


こうすると「メニュー ボタン 開いています」などと読み上げられます。同様に、メニューが閉じた際にaria-expanded=falseを指定すると「メニュー ボタン 閉じています」などと読み上げられます（「隠されました」などと読み上げることもあります）。
aria-haspopup属性と同様、ボタンのラベルとあわせて読み上げることに注意してください。メニューが既に開いていて、ボタンのラベルが「メニューを閉じる」となっている場合、aria-expanded=trueを指定すると、「メニューを閉じる ボタン 開いています」と読み上げられます。これは冗長ですし、むしろ混乱を招くことがあります。
初期状態ではaria-expanded属性を付けないようにしておき、開いたときだけaria-expanded=trueを付ける方法もあります。この場合、メニューが閉じているときは「メニュー ボタン」と読み上げられ、開いているときは「メニュー ボタン 開いています」と読み上げられるようになります。

＜memo＞
実際にユーザーに伝わるかどうかは、文脈にもよります。ボタンのラベルや他のARIA属性も合わせた状態で実際に読み上げさせて、ボタンの挙動が伝わるか、逆に過度に冗長になっていないかを検討するとよいでしょう。

＜本文＞
aria-controls属性を指定すること自体は望ましいことですが、その機能に頼るべきではありません。基本的に、出現するメニューはメニューボタンの直後に置くことが望ましいでしょう。

＜memo＞
Chapter4-2のaria-controls属性も参照してください。

＜小見出し＞
メニューの裏側にフォーカスが当たらないようにする
＜本文＞
一般的に、メニューを開いたとき、視覚環境ではメニューがコンテンツに覆いかぶさります。コンテンツはメニューの裏側に隠れて見えなくなり、メニューに隠されない部分があっても、グレーアウトして操作できない状態になります。
しかしキーボード操作の場合、メニューが開いた状態でも背後のコンテンツにフォーカスを移せてしまう場合があります。メニューの裏側の要素にフォーカスが移ると、視覚環境のキーボードユーザーはフォーカスを見失い、混乱することがあります。スクリーンリーダーのユーザーの場合、メニューが開いたままであることに気づかず、普通に利用できてしまうことが多いでしょう。

＜memo＞
見えない要素にフォーカスが当たってしまう状況は、ユーザーにとって予想外のフォーカス移動になるため、WCAG 2.1の達成基準達成基準 2.4.3「フォーカス順序」の問題となります。
https://www.w3.org/TR/WCAG21/#focus-order

＜本文＞
このようなフォーカス順序の問題を避ける方法を検討していきます。

＜太字黒見出し＞
方法1：メニューの外の要素をすべてフォーカス不可能にする
＜本文＞
メニューが開いたときに、メニューの外の要素をすべてフォーカス不可能にするという方法です。実装方法は複数存在しますが、ここでは方針だけ紹介します。

・メニューの外側のフォーカス可能な要素すべてにtabindex=-1を指定する
・メニューの外側の要素すべてをdisplay: none;やvisibility: hiddenなどで削除する
・メニューをdialog要素として実装し、showModal()メソッドで呼び出す

＜memo＞
dialog要素については、Chapter3-9のdialog要素の項を参照してください。また、詳細な実装方法についてはWAI-ARIA Authoring Practicesを参照してください。

＜本文＞
aria-hiddenはこの目的では利用できないことに注意してください。aria-hiddenを指定してもフォーカス移動には影響せず、フォーカスを受け取ってしまいます。スクリーンリーダーのユーザーは読み上げられない要素にフォーカスを奪われ、混乱することになります。

＜太字黒見出し＞
方法2：フォーカス移動するときにメニューの先頭に戻す
＜本文＞
メニューからフォーカスが外に出るのは、メニューの最後の要素からさらにフォーカス移動しようとしたタイミングです。そのタイミングでTabキーの挙動をフックして、メニューの先頭に戻してしまえば、フォーカスはメニューの外に出られなくなます。
メニューの最後の要素にkeypressイベントを付けてフックする方法もありますが、フォーカストラップを利用する方法もあります。たとえば〓15〓のように、メニューの前後にtabindex属性を指定したdivを挿入します。


〓15〓tabindex属性を指定したdivを挿入
<コード＞
<div tabindex="0"></div>
  <ul id="menu01">
    <li><a href="/">ホーム</a></li>
    <!-- メニュー -->
  </ul>
<div tabindex="0"></div>

キーボード操作でメニューの外にフォーカスを出そうとした際、このdiv要素にフォーカスが当たります。このdiv要素にfocusイベントを付けておき、フォーカスが当たったタイミングでフォーカスをメニューの先頭、もしくは末尾に移動します。
この際、フォーカスが脱出不能にならないように注意してください。メニューを閉じるボタンが押せなくなると、キーボードユーザーは操作不可能になってしまいます。

＜memo＞
フォーカスが脱出不能になると、WCAG 2.1達成基準2.1.2「キーボードトラップなし」の要件を満たせなくなります。これはレベルAの要求で、「非干渉」の条件でもある重要な基準です。WCAGへの対応が求められる場合には、この基準を必ず満たさなければなりません。
https://www.w3.org/TR/WCAG21/#no-keyboard-trap

＜本文＞
また、ユーザーはブラウザーのアドレスバーにフォーカスしたい場合にShift+Tabキーで戻ることもあります。先頭の要素から前に戻ろうとすることは許容してもよいでしょう。

＜memo＞
スクリーンリーダーのユーザーはTabキーを使用せずにフォーカスを移動できる場合もあります。また、フォーカスを移動せずに外の要素を読み上げられることもあります。もっとも、スクリーンリーダーのユーザーは視覚的にフォーカスを見失っても困らないため、そこまで気にしなくてもよいでしょう。

＜太字黒見出し＞
方法3：フォーカス移動しようとした場合にメニューを自動的に閉じる
＜本文＞
方法2と似ていますが、フォーカスをメニューの先頭に戻す代わりに、メニューを閉じるという方法もあります。実装方法は基本的に方法2と同様で、フォーカスをトラップした際の処理を、メニューを閉じる処理に変更するだけです。
ただし、メニュー項目にフォーカスしたままメニューを閉じると、フォーカスを見失うため、メニューを閉じた際には、フォーカスを適切な場所に移動する必要があります。通常は、メニューを開く直前にフォーカスがあった場所、つまりメニューボタンにフォーカスを戻すとよいでしょう。
ただし、この方法には欠点もあります。ユーザーはメニューが閉じることを予測できませんし、メニューが閉じたことに気づかないことがあります。これは混乱の原因になります。たとえば、メニューが閉じたあとでShift+Tabキーを押しても、直前のメニュー項目に戻ることはできず、予想外の場所にフォーカスが移ってしまいます。
また、メニューが長い場合、閉じてしまったメニューを開き直した上で、もう一度メニュー項目を先頭から読み上げていくことになります。ユーザーが大きなストレスを感じることもあるでしょう。

＜中見出し＞
事例2：カルーセルのライブラリーを選定する
＜本文＞
「カルーセル（Carousel）」とは、回転木馬、メリーゴーランドの意味です。ウェブでは、画像やカードなどが横に並び、左右にスライドして順繰りに表示される、〓16〓のようなコンポーネントを指します。スライドショーと呼ばれたり、イメージローテーターと呼ばれることもあります。

〓16〓左右のスライドが見切れているカルーセルの例

カルーセルにはさまざまなパターンがありますが、一般的には以下のような機能を持ちます。

・複数のスライド（slide）を持ち、順番に表示できる。スライドには画像やカードなど、視覚的に提示される項目が含まれる
・一度に表示するスライドは1つだけ（ただし、左右に見切れた状態で前後のスライドが表示されることはある）
・ユーザーの操作により、次のスライド、前のスライドを表示させることができる。多くの場合、カルーセル領域の左右に矢印状のボタンが表示される
・表示されているスライドをクリックすると、そのスライドに対応するリンク先に遷移する。

また、これらに加えて以下の機能を持つケースも見られます。

・スライドピッカーコントロール（slide picker control）を持つ。これはスライドが全部で何枚あり、現在表示中のものが何番目かを示すインジケータであり、インジケータ部分をクリックすると、対応するスライドを直接表示させることもできる。多くの場合、カルーセル領域の下部に、円が横に並んだ形で表示される
・ページが読み込まれると同時に自動的にカルーセルの再生（回転）が始まる
・スライドにマウスポインターが乗った場合や、キーボードフォーカスが移った場合に、カルーセルの自動回転を停止する
・ローテーションコントロール（rotation control）を持つ。これは、カルーセルの自動再生を停止・再開できる機能で、多くの場合、オーディオ機器の一時停止・再生ボタンを模したボタンで表現される

このように、カルーセルは多数の機能を持つ複雑なものです。これらすべてを自前で実装するのは大変です。実際には、カルーセルを扱う専用のライブラリーを利用するケースが多いでしょう。カルーセルのライブラリーにはさまざまなものがあり、アクセシビリティに配慮したものも、そうでないものもあります。
ここでは、ライブラリーを選定するときに注意したいポイントを見ていくことにしましょう。

＜memo＞
すべてを自前で実装する必要がある場合は、WAI-ARIA Authoring PracticesやWeb Accessibility Tutorialsを参考にするとよいでしょう。
3.6 Carousel (Slide Show or Image Rotator)
https://www.w3.org/TR/wai-aria-practices/#carousel
Web Accessibility Tutorials Carousel
https://www.w3.org/WAI/tutorials/carousels/

＜小見出し＞
キーボード操作が可能か
＜本文＞
カルーセルもキーボードで操作できなければなりません。ライブラリー選定時には、動作サンプルをキーボードで実際に操作してみるとよいでしょう。特に問題になりやすいのは以下の点です。

・現在表示されているスライドにフォーカスし、リンクをたどることができるか
・隠れているスライドにフォーカスが当たってしまい、フォーカスを見失うことはないか
・次のスライド/前のスライドボタンにフォーカスし、操作できるか
・スライドピッカーコントロールにフォーカスし、操作できるか
・ローテーションコントロールにフォーカスし、操作できるか

キーボードフォーカスが見えず、事実上操作できないケースもよく見かけます。フォーカスが明確に見えるかどうかも確認しましょう。

＜太字黒見出し＞
フォーカス時の自動停止
＜本文＞
カルーセルが自動再生する場合、スライドにフォーカスを移したタイミングでスライドが動くと、フォーカスを見失うことがあります。多くのカルーセル実装では、スライドにフォーカスしたときに自動再生を止めることで、これを防いでいます。
同様に、マウスポインターがスライドに乗ったときにも自動再生を止めることが一般的です。スライドをクリックする瞬間にスライドが切り替わると、意図しない遷移先に移動してしまうためです。このような配慮がなされているかどうかも確認しておきましょう。

＜小見出し＞
スクリーンリーダーで操作できるか
＜本文＞
視覚環境だけでなく、スクリーンリーダーで問題なく操作できるかどうかを確認しましょう。

・現在表示されているスライドが適切に読み上げられるか
・各種のボタンにラベルが付けられているか
・隠れているスライドが読み上げられて混乱することはないか

実装方法によっては、隠れているスライドまで読み上げてしまうことがあります。スライドの内容によっては大きな問題ないケースもありますが、多くの場合は混乱を招きます。

＜memo＞
自前で実装する場合は、隠れているスライドにaria-hiddenを適用するのも1つの方法です。ただし、aria-hiddenだけではキーボードフォーカスは当たってしまうことに注意してください。

＜太字黒見出し＞
他の箇所の読み上げを妨害しないか
＜本文＞
カルーセルが自動再生する場合、1つ重要な注意点があります。自動再生時に、現在の読み上げを妨害しないかという点です。
カルーセルのライブラリーの中には、カルーセル領域をライブリージョンとして実装するものがあります。たとえば、Slickというライブラリーの古いバージョンでは、〓17〓のように、カルーセル領域にaria-live="polite"を指定していました。

＜memo＞
Slick
https://kenwheeler.github.io/slick/

〓17〓カルーセル領域にaria-live="polite"を指定
＜コード＞
<div aria-live="polite" class="slick-list draggable">
  <!-- カルーセル領域 -->
</div>

aria-live=politeの指定によって、この領域はライブリージョンとして扱われます。カルーセルのスライドが切り替わると、ライブリージョンの内容が変化するため、その都度、内容が読み上げられます。カルーセルを手動で操作した場合は問題ありませんが、カルーセルが自動再生したタイミングでも読み上げられることになります。
aria-live=politeの場合、現在の読み上げが一段落したところで割り込んで内容を読み上げます。たとえば、見出しを読み上げているときにカルーセルが切り替わると、見出しのテキストを読み上げ終えたあと、すぐに続けてカルーセルの内容を読み上げます。これはユーザーを混乱させます。

＜memo＞
カルーセルにライブリージョンを採用しているライブラリーは使うべきではありませんが、どうしても使わざるを得ない場合、スライドのテキストを工夫する方法もあります。たとえば、テキストの頭に「【広告】」と入れれば、現在の読み上げとは無関係の広告が読み上げたとわかり、混乱をやわらげる可能性があります。

＜本文＞
カルーセルを自前で実装する場合、ライブリージョンを使う必要があるかどうかは慎重に検討してください。どうしても利用する必要がある場合は、ユーザーがカルーセル領域から離れたときにaria-live=offに切り替えるか、カルーセルの自動再生をしないようにするとよいでしょう。

＜小見出し＞
ローテーションコントロールがあるか
＜本文＞
ローテーションコントロールは、自動再生するカルーセルを停止する機能です。WCAG 2.1の達成基準2.2.2「一時停止、停止、非表示」は、動き続けるコンテンツが停止できることを求めています。
カルーセルが自動再生する場合、ローテーションコントロールが提供されていること、それがアクセシブルであることを確認しましょう。

＜memo＞
WCAG 2.1の達成基準2.2.2「一時停止、停止、非表示」はレベルAの要求で、「非干渉」の条件でもある重要な基準です。WCAGへの対応が求められる場合には、この基準を必ず満たさなければなりません。
https://www.w3.org/TR/WCAG21/#pause-stop-hide

＜中見出し＞
事例3：タブのマークアップを検討する
＜本文＞
「タブ（tabs）」は、複数のコンテンツを切り替えて表示する機能です。典型的には〓18〓のように、コンテンツが入る「タブパネル（tab panel）」を複数持っており、その表示を切り替えるためのタブ（tab）を持ちます。タブは、「タブリスト（tab list）」としてグループ化されます。

〓18〓タブの例（WAI-ARIA Authoring Practicesより）

タブは以下のような機能を持ちます。

・複数のタブとタブパネルから構成される。タブとタブパネルは1対1対応している
・タブリスト内のすべてのタブは見えている状態になっており、初期状態ではいずれか1つのタブが選択されている
・タブパネルは、選択されているタブに対応したものだけが表示され、他のタブパネルは見えない
・他のタブをクリックすると、そのタブが選択状態になり、選択したタブに対応するタブパネルが表示される。他のタブパネルは表示されなくなる

タブがキーボード操作を受け付ける場合、以下のような操作が一般的です。

・タブリストにフォーカスを移すと、選択されているタブがアクティブになる
・キーボードの左右キーを押すと、左右にある他のタブが選択される

＜memo＞
キーボードの左右キーによる操作は、他のウェブコンポーネントではあまり見られませんが、OSが提供するタブコントロールの操作に合わせたものです。

＜本文＞
ウェブコンテンツでは、タブの表現はよく使われます。ここでは、タブのマークアップについて、いくつかのパターンを検討しながら、考え方の過程を見ていきます。

＜小見出し＞
タブのマークアップと実装
＜本文＞
WAI-ARIAには、タブの部品に対応するロールが用意されています。

・タブ：tab
・タブリスト：tablist
・タブパネル：tabpanel

WAI-ARIAの基本はネイティブの機能を利用することですが、HTMLにはこれらのロールを持つネイティブ要素がないため、既存のHTMLの要素を利用し、role属性でこれらのロールを指定することになります。
では、HTMLのどの要素を使うべきでしょうか。ここでは、実際にどのようなマークアップにするべきかを検討していきましょう。

＜太字黒見出し＞
タブ
＜本文＞
タブはユーザーの操作の対象となる要素です。タブをクリックしたとき、タブパネルが切り替わるようにする必要があります。また、キーボードフォーカスを受け取る必要もあります。フォーカスを受け取れる要素、a要素かbutton要素のいずれかを使うべきでしょう。

＜memo＞
WAI-ARIA Authoring Practicesのタブの例ではbutton要素を使用しています。
WAI-ARIA Authoring Practices tabpanel
https://www.w3.org/TR/wai-aria-practices/#tabpanel

＜本文＞
タブが3つある場合、たとえば〓19〓のようなマークアップになります。aria-selectedとtabindexはJavaScriptで動的に付けられている想定です。

〓19〓3つのタブがある場合のマークアップ
＜コード＞
<button type="button" role="tab" id="tab01" aria-controls="tabpanel01"
 aria-selected="true">タブその1</button>
<button type="button" role="tab" id="tab02" aria-controls="tabpanel02"
 aria-selected="false" tabindex="-1">タブその2</button>
<button type="button" role="tab" id="tab03" aria-controls="tabpanel03"
 aria-selected="false" tabindex="-1">タブその3</button>

＜本文＞
〓19〓のコードについて、もう少し詳しく見ていきましょう。
タブにはaria-controls属性を指定して、このタブに対応するタブパネルを示します。一部のスクリーンリーダーでは、対応するタブパネルにジャンプできるようになります。
id属性を指定しておくと、タブのラベルをaria-labelledbyで参照できるようになります。これは後述のタブパネルで利用します。
また、JavaScriptで以下の属性を付けます。これらの値は、タブが切り替わったときに動的に変化する想定です。

・aria-selected属性 : このタブが現在選択されているかどうかを示します。選択されているタブには"true"、そうでないタブには"false"を指定します。
・tabindex属性 : 選択されていないタブにtabindex=-1を指定します。前述のように、キーボード操作ではタブにフォーカスしてから左右キーでタブを切り替える想定となるため、選択されていないタブには直接フォーカスが当たらないようにします。

タブには、必ずアクセシブルな名前を付けてください。上記の例のように、button要素の中にラベルテキストが入っていれば問題ありません。テキストを持たせられない場合、タブパネルに含まれている見出しにIDを付けてaria-labelledby属性で参照してもよいでしょう。

＜memo＞
aria-labelledby属性についてはChapter4-2を参照してください。

＜太字黒見出し＞
タブリスト
＜本文＞
タブリストは、タブが列挙される部分です。tablistロールを適用しますが、どの要素を採用するかは議論の余地があります。
ARIA in HTMLでは、menu、ol、ul、nav要素にtablistロールが適用できることになっています。ほかにも、すべてのロール（Any role）が適用可能とされている要素、たとえばp要素やdiv要素なども利用できます。なお、dl要素にはtablistロールを指定可能ではないため、採用できません。
タブリストにはタブが複数列挙されますし、名前に「リスト」と付いていますから、ul要素は有力候補です。しかし、WAI-ARIAのtablistロールはlistロールと派生関係になく、listitemの親にはなれません。ul要素のロールをtablistに変更すると、li要素のlistitemロールが宙に浮くことになります。li要素にtabロールを指定することも可能ですが、先に述べたようにtabロールはbutton要素かa要素に指定したほうがよいでしょう。この場合、li要素にはrole=presentationを指定することになります。ul要素を使っても、結局はリストの意味を失わせることになります。
最初からdiv要素を使うという考え方も有力です。実際、WAI-ARIA Authoring Practicesのタブの例ではdiv要素を使用しています。どちらが正解というわけでもなく、前後の文脈や互換性など、周辺の事情を考えて採用するとよいでしょう。

＜memo＞
画面幅によって表現を切り替える場合、ul要素が便利な面もあります。後述の「タブと他の表現を切り替える」の項も参照してください。

＜太字黒見出し＞
タブパネル
＜本文＞
タブパネルは実際に表示される内容を含む部分で、tabpanelロールを適用します。
tabpanelロールは、ARIA in HTMLではsection要素に適用可能とされています。そのほか、任意のロールを適用可能な要素で利用できます。ただし、タブパネルの中にさまざまな要素が入る可能性を考えるとp要素は使い勝手に難があり、事実上、section要素とdiv要素のどちらかになるでしょう。タブパネルの中に見出しが入ってセクションとして成立しているならばsection要素、そうでなければdiv要素を利用するとよいでしょう。

＜memo＞
以前はsection要素にtabpanelロールを指定できなかったため、section要素にtabpanelロールを指定すべきでないという解説を見かけることもあります。現在はそのような指定は可能です。
WAI-ARIA Authoring Practicesのタブの例では、タブパネルにdiv要素を使用しています。

＜本文＞
〓20〓は、タブパネルをdiv要素としてマークアップした例です。

〓20〓タブパネルのマークアップ
＜コード＞
<div tabindex="0" role="tabpanel" id="tabpanel01" aria-labelledby="tab01">
<!-- タブパネルの内容 -->
</div>
<div tabindex="0" role="tabpanel" id="tabpanel02" aria-labelledby="tab02" hidden>
<!-- タブパネルの内容 -->
</div>
<div tabindex="0" role="tabpanel" id="tabpanel03" aria-labelledby="tab03" hidden>
<!-- タブパネルの内容 -->
</div>

＜本文＞
〓20〓のコードについて、もう少し詳しく見ていきましょう。
それぞれのタブパネルには、id属性を指定しています。これは、タブのaria-controls属性で対応するタブパネルを参照するためです。
タブパネルをフォーカス可能にする場合、タブパネルにはラベルを付ける必要があります。この例では、タブのラベルがそのまま使えるため、aria-labelledby属性でタブのIDを参照しています。タブパネルの中に見出しが含まれる場合は、その見出しにIDを付けて参照してもよいでしょう。ラベルにふさわしいテキストがどこにもない場合は、aria-labelでラベルを付けることも可能です。
hidden属性が指定されているタブパネルは、現在非表示となっているものです。JavaScriptでhidden属性を与えたり、取り除いたりして表示・非表示を切り替えます。CSSの優先度によっては、hidden属性で要素を隠せないこともあるかもしれません。その場合は、class属性でクラス名を与えてCSSで非表示にしてもよいでしょう。
通常、aria-hiddenを利用する必要はありません。非表示のタブパネルは視覚環境からも隠されるべきもので、典型的にはCSSのdisplay:noneを適用して、視覚環境とスクリーンリーダーの双方から隠されるようにします。演出上の都合など何らかの理由でdisplay:noneを適用できず、非表示のタブパネルがスクリーンリーダーで読み上げられてしまうような場合には、aria-hiddenの利用を検討してもよいでしょう。

＜太字黒見出し＞
スクリプト実装
＜本文＞
これでマークアップは完成です。あとは、JavaScriptを実装して動作するようにします。
具体的なコード例についてはWAI-ARIA Authoring Practicesに譲りますが、タブがクリックされた場合だけでなく、タブにフォーカスしたときのキーボード操作も忘れずに実装してください。keypressイベントではカーソルキーの操作を取得できないため、keydownイベントとkeyupイベントを利用します。

＜小見出し＞
タブと他の表現を切り替える
＜本文＞
タブを利用する目的の1つは、画面スペースの節約です。タブ操作によって表示を切り替えることで、狭いスペースで多くの情報を見せることができます。むしろ、画面スペースが十分にある場合、タブで表現する必要はないかもしれません。
レスポンシブデザインを採用し、画面が狭いときはタブで表現し、広いときはすべてを展開して見せたいケースもあるでしょう。このような場合、ul要素を利用すると便利です。
〓21〓のマークアップは、ページ内リンクの目次をul要素で表現したものです。リンク先はsection要素内の見出しになっています。

〓21〓タブインターフェイスの記述例
＜コード＞
<ul>
  <li><a href="#section01">セクション1</a></li>
  <li><a href="#section02">セクション2</a></li>
  <li><a href="#section03">セクション3</a></li>
</ul>
<section>
  <h2 id="section01">セクション1</h1>
  <p>セクション1の内容...</p>
</section>
<section>
  <h2 id="section02">セクション2</h1>
  <p>セクション2の内容...</p>
</section>
<section>
  <h2 id="section03">セクション3</h1>
  <p>セクション2の内容...</p>
</section>

＜本文＞
このような目次とページ内リンクの構造は、タブに対応させることができます。目次のリストがタブリストに、目次内の個々のリンクがタブに、リンク先のセクションがタブパネルに対応します。〓21〓のマークアップに対し、JavaScriptでrole属性などを付与すると、〓22〓のようになります。

〓22〓〓21〓にrole属性を付与した例
＜コード＞
<ul role="tablist">
  <li role="none"><a role="tab" href="#section01">セクション1</a></li>
  <li role="none"><a role="tab" href="#section02">セクション2</a></li>
  <li role="none"><a role="tab" href="#section03">セクション3</a></li>
</ul>
<section role="tabpanel" aria-labelledby="section01">
  <h2 id="section01">セクション1</h1>
  <p>セクション1の内容...</p>
</section>
<section role="tabpanel" aria-labelledby="section02">
  <h2 id="section02">セクション2</h1>
  <p>セクション2の内容...</p>
</section>
<section role="tabpanel" aria-labelledby="section03">
  <h2 id="section03">セクション3</h1>
  <p>セクション2の内容...</p>
</section>

〓22〓にはほかにも属性やイベントを付ける必要はありますが、タブとして成立することはわかるでしょう。このようにすると、状況によってページ内リンクの表示方法とタブの表現とを切り替えることが可能になります。また、JavaScriptが動作しない環境でも、ページ内リンクとして成立し、動作します。

＜太字黒見出し＞
タブの操作方法をあえて実装しない選択
＜本文＞
〓22〓の例は、ページ内リンクの目次だったものをタブとして動作させています。このとき、キーボードでの操作方法は変化します。ページ内リンクだった場合は、Tabキーでリンクに次々とフォーカスしていき、希望のリンクを選択するという操作でした。タブになると、現在選択されているタブにフォーカスし、左右キーでタブを選ぶという操作になります。
この操作方法の変更は本当に必要なのでしょうか。表現だけ変えて操作は変えず、ロールも変えず、そのままページ内リンクとして操作させるという考え方もあります。
タブを提供するコンテンツがウェブアプリケーションであり、デスクトップアプリケーションと同じ操作感が求められる場合は、タブとして操作できたほうがよいでしょう。そうではなく、単に単に省スペースを目的としているだけであれば、ページ内リンクの操作方法でも問題ないことが多いでしょう。
ただし、タブの表現にはアクセシビリティ上の課題もあることに注意してください。ページ内リンクの場合、リンクをクリックすると該当箇所までスクロールし、明確に画面が変化するのが基本の動作です。それに対し、タブ切り替えでは通常、画面はスクロールしません。画面を拡大しているユーザーの場合、タブの部分を画面いっぱいに拡大していると、その外で起きた変化に気づかないことがあります。

＜memo＞
これは、先に挙げたメニューボタンの例において、開いたメニューがどこにあるのかわからないケースと類似した問題です。メニューの例と同様、aria-controls属性だけでは不十分なので、タブとタブパネルを隣接させる、フォーカスを移動させるといった対応をするとよいでしょう。

＜中見出し＞
事例4：モーダルダイアログ
＜本文＞
「ダイアログ（dialog）」は、ウェブコンテンツの上に覆いかぶさるように出現するウィンドウ領域です。基本的には、ユーザーに対して注意を促し、何かを入力させるために用います。

＜memo＞
dialogという英単語は「対話」という意味で、ユーザーに通知をし、かつユーザーからの操作を受け付けることからこの名があります。ユーザー操作を受け付けない通知領域は、ダイアログとは呼びません。

＜本文＞
ダイアログには、大きく分けて2つのモードがあります。

・モーダルダイアログ（modal dialog）：ダイアログが出現している間、ダイアログ以外の要素を操作できなくなるもの
・モードレスダイアログ（modeless dialog）：ダイアログが出ても他のコンテンツを引き続き操作できるもの

モーダルダイアログの場合、〓23〓のようにダイアログの外をグレーアウトさせて、他のコンテンツが操作できないことが視覚的にわかるようにする提示が一般的です。

〓23〓モーダルダイアログのイメージ図

ウェブではモードレスダイアログはあまり利用されません。他のコンテンツを引き続き操作できる場合、ダイアログではない表示をすることが多いでしょう。
ここでは、モーダルダイアログの実装について、いくつかの方法をとりあげ、内容を見ていくことにします。

＜小見出し＞
window.confirmによる簡易なダイアログ
＜本文＞
簡易なダイアログであれば、JavaScriptの機能だけで簡単に実装できます。window.confirm()を利用すると、ユーザーにOKかキャンセルかの2択を問うモーダルダイアログを出すことができます。〓24〓は、フォームをリセットする場合に警告のダイアログを出す例です。表示例は〓25〓のようになります。

〓24〓警告のダイアログの例
＜コード＞
<form onreset="return confirm('フォームの内容をすべて初期化します。よろしいですか?')">
  <input value="初期値">
  <button>送信</button>
  <button type="reset">リセット</button>
</form>


〓25〓ブラウザーによる〓24〓の表示例

ユーザーがキャンセルボタンを押した場合はconfirm()の戻り値がfalseとなり、return falseが実行されてリセットの動作がキャンセルされます。

＜memo＞
onreset属性はイベントハンドラーコンテンツ属性の1つで、フォームがリセットされる際に実行されます。Chapter4-1のイベントハンドラーコンテンツ属性も参照してください。

＜本文＞
このダイアログはブラウザーの機能で表示されるため、コンテンツ制作者は見た目を制御できません。ブラウザーによっても異なりますが、ほとんどの場合、シンプルで事務的な見た目になります。簡潔にYes/Noを問うだけでよい場合は、これで十分でしょう。

＜小見出し＞
dialog要素によるダイアログ
＜本文＞
HTMLには、ダイアログを表示するためのdialog要素が用意されています。showModal()メソッドを呼ぶとモーダルダイアログとして機能します。詳細はChapter3-11のdialog要素を参照してください。
dialog要素を利用すると、それだけで、モーダルダイアログの外にある要素を暗く表示し、操作できないようにするところまで実現できます。
なお、初期状態でダイアログを隠す処理も実現されていますが、これは単にユーザーエージェントのスタイルシートでdialog:not([open]){display:none;}というスタイルが与えられているだけです。より強いセレクターでdisplayプロパティを上書きすると、ダイアログが表示されてしまうこともあるので注意してください。

＜小見出し＞
WAI-ARIAを駆使した実装
＜本文＞
dialog要素をサポートしないブラウザーを想定した場合、他の要素とWAI-ARIAを組み合わせて自前でダイアログを実装する選択肢が現実的になります。ダイアログのマークアップは、たとえば〓28〓のようになります。

〓28〓WAI-ARIAを使ったダイアログのマークアップ例
＜コード＞
<div id="dialog_layer" class="dialogs">
  <div tabindex="0"></div>
  <div id="dialog4" class="dialog"
    role="dialog"
    aria-labelledby="dialog_label"
    aria-describedby="dialog_desc"
    aria-modal="true">
    <h2 id="dialog_label">ダイアログの見出し</h2>
    <p id="dialog_desc">
      ダイアログのメッセージ...
    </p>
    <!-- その他さまざまな中身が入る -->
    <button type="button"
      id="dialog_close_button">
      <img src="close.png" alt="閉じる">
    </button>
  </div>
  <div tabindex="0"></div>
</div>

〓28〓のコード例を少し詳しく見ていきましょう。
一番外側のdiv要素は、ダイアログ全体のラッパーです。その中にダイアログ本体のdiv要素が入っていますが、キーボードフォーカスの制御のために、ダイアログの前後に<div tabindex="0"></div>を挿入しています。これは、ハンバーガーメニューの事例で紹介したフォーカストラップです。JavaScriptによるDOM操作でdivを挿入してfocusイベントを付けておき、フォーカスをトラップする制御を行います。

＜memo＞
フォーカストラップについては、ハンバーガーメニューの項で紹介した「方法2：フォーカス移動するときにメニューの先頭に戻す」を参照してください。

＜本文＞
ダイアログ本体となるdiv要素には、role属性でdialogロールを指定して、ダイアログであることを示しています。

＜memo＞
ダイアログが重要な警告やエラーを通知する場合は、alertdialogロールを指定してもよいでしょう。なお、ユーザーの入力を受け付けない（ボタンでダイアログを閉じる必要もない）ような場合は、そもそもダイアログではないため、alertロールがより適切です。

＜本文＞
dialogロールには、必ずアクセシブルな名前を与えなければなりません。この例では、ダイアログの内部に見える形で見出しが存在しているため、aria-labelledby属性でを利用して結び付けています。見える形のテキストラベルがない場合は、aria-label属性などを利用してもよいでしょう。
同様に、aria-describedby属性でアクセシブルな説明を提供しています。これは必須ではありませんが、スクリーンリーダーでは、ダイアログにフォーカスした際に、見出しに続けてメッセージが読み上げられるようになります。
aria-modal="true"の指定は、このダイアログがモーダルであることを示すものです。aria-modalに対応した支援技術の場合、これだけでモーダルの外の要素を操作できないようにする場合があります。とはいえ、この処理は仕様上必須とはされておらず、対応していない支援技術もあるため、モーダルダイアログの外の要素を読み上げないようにしたり、キーボードフォーカスを制御する処理の実装も必要です。
モーダルダイアログの内部には、閉じるボタンを置きます。aria-modalを指定するとダイアログの外側にアクセスできなくなることがあるため、ダイアログを開いたボタンをトグルさせたい場合などは、ボタンが必ずダイアログの内部に来るように配慮してください。また、Escキーが押されたときにダイアログが閉じるようにしておくとよいでしょう。
あとはJavaScriptで動作を制御するだけですが、コードは長くなるため、ここでは紹介しません。具体的なJavaScriptのコードやその他の細部については、WAI-ARIA Authoring Practicesのdialogの例を参考にしてください。

＜memo＞
WAI-ARIA Authoring Practices dialog
https://www.w3.org/TR/wai-aria-practices/examples/dialog-modal/dialog.html


＜中見出し＞
事例5：インラインSVGのアクセシビリティを担保する
＜本文＞
SVGは、XML形式のデータでベクター形式の画像を表現する技術です。img要素のsrc属性でSVGファイルを参照すれば画像として扱うことができますが、HTMLでsvg要素を利用すると、HTMLコンテンツにインラインでSVGを埋め込むことが可能になります。JavaScriptと組み合わせることで、DOM操作でSVGの内容を制御でき、さまざまな表現が可能になります。
ここでは、svg要素を利用してSVGをインラインで記述する場合のアクセシビリティの考慮点について見ていきます。

＜小見出し＞
svg要素のロール
＜本文＞
SVGの用途はさまざまですが、ウェブコンテンツでは、純粋に画像として利用するケースが多いでしょう。img要素でSVG画像を埋め込む代わりに、インラインのsvg要素を利用します。
この場合、svg要素のデフォルトのロールがimg要素とは異なる点に注意が必要です。SVG2の仕様、およびARIA in HTML仕様では、svg要素はデフォルトでgraphics-documentロールを持つとされています。

＜memo＞
SVG2 5.13.4. Implicit and Allowed ARIA Semantics
https://www.w3.org/TR/SVG2/struct.html#implicit-aria-semantics

＜本文＞
graphics-documentロールは文書を表すdocumentロールから派生したもので、画像よりも文書に近い性質を持つものです。このロールはWAI-ARIA仕様ではなく、WAI-ARIA Graphics Module仕様で定義されています。

＜memo＞
graphics-document (role)
https://www.w3.org/TR/graphics-aria/#graphics-document

＜本文＞
SVGは一般的に画像を表現するために利用されますが、テキストを含めて、テキストのレイアウトに用いることもできます。ウェブコンテンツでSVGを利用する場合、SVGの用途を確認しましょう。単に画像として扱っている場合は、role=imgを指定して、明示的にimgロールを付与するとよいでしょう。

＜小見出し＞
画像の代替テキストと説明を提供する
＜本文＞
意味のある画像には代替テキストを与える必要があります。img要素のsrc属性でSVGファイルを参照した場合には、alt属性で代替テキストを与えます。
svg要素を使ってインラインでSVGを記述した場合、alt属性は利用できません。svg要素にはtitle属性も指定できません。〓29〓のようなインラインSVGの場合、svg要素直下のtitle要素がアクセシブルな名前として利用されます。

〓29〓インラインSVGの記述例
＜コード＞
<svg role="img">
  <title>図: XX会社の組織図</title>
  ...
</svg>

なお、svg要素には、aria-label属性やaria-labelledby属性を指定することも可能です。それらの属性があれば、そちらが優先されます。

＜memo＞
SVGにおけるアクセシブルな名前の算出方法については、SVG-AAM仕様の8.special Processing Requiring Additional Computationを参照してください。
8.special Processing Requiring Additional Computation
https://w3c.github.io/svg-aam/#mapping_additional

＜本文＞
説明文についても同様です。aria-describedby属性が利用できるほか、〓30〓のようにSVG内にdesc要素があれば、アクセシブルな説明として利用されます。

〓30〓SVG内にdesc要素を記述した例
＜コード＞
<svg role="img">
  <title>図: XX会社の組織図</title>
  <desc>XX会社の組織図です。頂点にはXX組織があり...</desc>
</svg>

インラインでSVGを使用するときは、画像の代替テキストと説明文をSVGの中で与えるようにしましょう。それができない場合は、aria-label属性やaria-describedby属性を利用します。

＜小見出し＞
装飾的なSVG画像を無視させる
＜本文＞
SVGが意味を持たない、純粋に装飾的な画像である場合は、支援技術に無視させる必要があります。img要素の場合はalt=""を指定しますが、svg要素の場合は〓31〓のようにaria-hidden属性を利用します。この場合、role属性を指定する必要はありません。

〓31〓svg要素にaria-hidden属性を指定
＜コード＞
<svg aria-hidden="true">
  <!-- 純粋に装飾的な画像 -->
  ...
</svg>

＜中見出し＞
テストを行う
＜本文＞
ここまで、WAI-ARIAを利用する事例を紹介してきました。HTMLだけでアクセシビリティを担保できない場合に、WAI-ARIAを利用することで、アクセシビリティを向上できることがあります。
しかし、常にWAI-ARIAを利用することがよいわけではありません。Chapter4-3でも紹介したように、ARIAを不適切に利用するくらいならば、使わないほうがよいといえます。しかし残念ながら、不適切なARIA利用は多いのが現状です。
では、WAI-ARIAの使用が適切かどうかは、どうやって判断すればよいのでしょうか。筆者は、実際に動作検証をすることが重要だと考えています。Chapter4-3でも触れたように、実際にスクリーンリーダーなどの支援技術を用いてアクセスすることは難しくありません。
ここで紹介してきたような複雑な事例では、ユーザビリティの観点も重要になります。実際にユーザーに触れてもらい、テストを行うことが、より重要になってくるでしょう。
