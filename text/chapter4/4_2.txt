＜タイトル＞
WAI-ARIA
＜本文＞
HTMLで利用できる属性の中には、HTML仕様とは別の文書で定義されているものもあります。その1つに、近年利用されるようになったWAI-ARIAがあります。ここでは、WAI-ARIAで定義されているARIA属性について説明します。

＜中見出し＞
WAI-ARIAの概説
＜本文＞
Chapter1-4で触れたように、WAI-ARIAは、W3CのWAIによって発行されている仕様で、アクセシビリティを向上させるための属性を定義するものです。単にARIAとも呼ばれます。

＜memo＞
WAI-ARIAは、「ワイ アリア」や「ウェイ アリア」などと発音します。WAIの発音は英語圏でも一定ではないようです。
Accessible Rich Internet Applications (WAI-ARIA) 1.1
https://www.w3.org/TR/wai-aria/

＜本文＞
WAI-ARIAは単独で使うものではなく、別のマークアップ言語と組み合わせて、補助する形で利用します。組み合わせる相手のマークアップ言語のことを「ホスト言語（host language）」と呼びます。

＜memo＞
WAI-ARIAの用例のほとんどはHTMLをホスト言語としますが、SVGをホスト言語とするケースも見られます。

＜小見出し＞
ARIA属性の分類
＜本文＞
WAI-ARIAが定義する属性を「WAI-ARIA属性（WAI-ARIA attribute）」、もしくは単に「ARIA属性（ARIA attribute）」と呼びます。
ARIA属性を利用することで、ホスト言語の要素に対して追加の情報を提供できます。ARIA属性は性質によって「ロール（role）」、「ステート（state）」、「プロパティ（property）」の3種類に分類されます。

＜丸見出し＞
ロール
＜本文＞
ロールとは要素の役割を表すもので、この要素が何であるのか、もしくは何をするものかという情報を与えます。要素にロールを付与する場合は、role属性を使用します。
たとえば、div要素にrole="navigation"を指定すると、HTMLのnav要素と同じようなナビゲーションのセマンティクスを持つことを提示できます。ロールの中には、tabロールやsearchロールのように、対応するHTMLの要素が存在しないものもあります。

＜memo＞
2021年現在、searchロールに対応するsearch要素が提案されています。

＜丸見出し＞
ステート
＜本文＞
ステートは、要素の現在の状態を表すものです。
ステートと後述のプロパティとの役割はほとんど同じですが、ステートは頻繁に変化することが想定されるものを表します。主にJavaScriptからの操作によって設定され、現時点でのその要素の状態を表します。

＜memo＞
ステートとプロパティを定義するARIA属性には、aria-で始まる名前が付けられています。これらを総称して「aria-*属性（aria-* attribute）」と呼ぶことがあります。

＜本文＞
たとえば、aria-disabled="true"は、指定された要素が現在無効になっていることを伝えます。また、aria-expanded属性は、指定された要素と関連する要素が開閉どちらの状態になっているのかを伝えます。

＜memo＞
ステートとプロパティとの違いはそこまで厳密なものではありません。プロパティが頻繁に変更されたり、ステートが変更されずに使われることもあります。実際、WAI-ARIA仕様ではステートとプロパティは一括りのセクションで記述されています。
6. Supported States and Properties
https://www.w3.org/TR/wai-aria/#states_and_properties

＜丸見出し＞
プロパティ
＜本文＞
プロパティは、要素の性質や特性を表現するものです。
たとえば、aria-required="true"は、指定された要素が必須入力項目であることを伝えます。aria-label属性のように、要素に対して追加の説明を与えるものや、aria-controls属性のように、他の要素との関連性を示すものもあります。

＜小見出し＞
WAI-ARIAとその周辺仕様
＜本文＞
WAI-ARIAには、本体の仕様のほかに複数の関連文書があります。WAI-ARIAを体系立てて理解したい場合や、HTML仕様との対応関係を調べたい場合などは、関連文書を参照する必要があります。

＜丸見出し＞
WAI-ARIA仕様
＜本文＞
WAI-ARIA仕様の本体には、WAI-ARIAそのものの説明と、ロール、ステート、プロパティの定義が含まれています。それぞれの意味や効果、どのロールにどのステートやプロパティが指定可能かといった情報も含まれています。

＜memo＞
WAI-ARIA 1.2からは、JavaScriptからARIA属性へアクセスする場合に利用するIDLインターフェイスも定義されるようになりました。IDLについては、Chapter3-0も参照してください。
10. IDL Interface
https://www.w3.org/TR/wai-aria-1.2/#idl-interface

＜本文＞
ロールの情報の中には、"Related Concepts"として、そのロールがどのHTML要素に類似するかという情報もあります。ただし、これはあくまで理解を助けるための参考情報という位置付けです。HTML要素とロールとの対応関係については、後述のARIA in HTMLを参照する必要があります。

＜丸見出し＞
ARIA in HTML
＜本文＞
ARIA in HTMLは、HTMLをホスト言語とした場合のARIAの位置付けを規定した、コンテンツ制作者向けの文書です。ARIAロールとHTMLの要素との対応関係や、どのHTML要素にどのロールを指定できるかといった情報があります。
この文書では、ARIA属性の具体的な使い方までは説明していません。使い方のガイドや具体例については、後述のUsing ARIAとWAI-ARIA Authoring Practicesを参照するように促しています。

＜memo＞
ARIA in HTML
https://www.w3.org/TR/html-aria/

＜丸見出し＞
Using ARIA
＜本文＞
Using ARIAはW3Cのワーキンググループノートで、ARIAの使い方の基本的な方針について書かれた、入門ガイドのような位置付けの文書です。
Using ARIAには使用例も出ていますが、コード例は基本的な説明にとどまります。本格的なウィジェットをデザインするには不十分かもしれません。

＜memo＞
Using ARIAは、2018年に公開されてから2021年現在まで更新されていません。一部の情報は古いものになっており、他のW3C文書と重複している箇所もあります。
Using ARIA
https://www.w3.org/TR/using-aria/

＜丸見出し＞
WAI-ARIA Authoring Practices
＜本文＞
WAI-ARIA Authoring PracticesはW3Cのグループノートで、カルーセルやモーダルダイアログなどの本格的なウィジェットの実装例が紹介されています。コード例はもちろん、実際に動作を見ることのできるサンプルも用意されており、実際に制作する際の参考になるでしょう。

＜memo＞
WAI-ARIA Authoring Practices 1.1
https://www.w3.org/TR/wai-aria-practices/

＜丸見出し＞
その他の関連文書
＜本文＞
その他、WAI-ARIAの関連文書には以下のようなものがあり、WAI-ARIAスイートとして位置付けられています。

・Core Accessibility API Mappings (core-aam): WAI-ARIAのプラットフォームAPIとの対応を示した、ブラウザーや支援技術の開発者向けの仕様
・HTML Accessibility API Mappings : core-aamのHTML拡張仕様。ARIA in HTMLの対の仕様と位置付けられる
・Accessible Name and Description Computation : アクセシブルな名前と説明の優先順位を決めるアルゴリズムを示した仕様

さらに、WAI-ARIA仕様の拡張として、EPUBのためのDPUB-ARIA、SVGのためのSVG Accessibility API Mappingsといった仕様もあります。

＜memo＞
Core Accessibility API Mappings 1.1
https://www.w3.org/TR/core-aam/
HTML Accessibility API Mappings 1.0
https://www.w3.org/TR/html-aam/
Accessible Name and Description Computation 1.1
https://www.w3.org/TR/accname/

＜memo＞
Digital Publishing WAI-ARIA Module 1.0
https://www.w3.org/TR/dpub-aria/
SVG Accessibility API Mappings
https://www.w3.org/TR/svg-aam/

＜中見出し＞
role属性
＜本文＞
role属性を使用すると、要素のロールを指定できます。属性値にはロールの名前を指定します。role属性にはさまざまな注意点があります。

＜小見出し＞
ロールの複数指定
＜本文＞
ロールは複数指定可能で、ASCII空白文字で区切って列挙します。複数指定はフォールバックのためのもので、ブラウザーが解釈でき、かつ、その要素に適用可能なロールのうち、先頭にあるものが適用されます。〓01〓は複数指定の例です。

〓01〓role属性の記述例
＜コード＞
<div role="dummyrole blockquote note">...</div>

＜本文＞
この場合、dummyroleというロールは現在のARIA仕様に存在しないため、無視されます。blockquoteロールはARIA 1.2仕様で定義され、対応するブラウザーはこのロールを採用します。そうでないブラウザーはこれも無視してnoteロールを採用することになります。

＜小見出し＞
抽象ロールは指定できない
＜本文＞
ARIA仕様では、ロールの継承・派生関係を表現するための「抽象ロール（abstract role）」が定義されています。
抽象ロールはコンテンツ制作者が使用できないロールです。そのため、role属性で抽象ロールを指定してはなりません。抽象ロールを指定しても、ブラウザーはそれを無視します。たとえば、windowロールは抽象ロールであるため、〓02〓のような指定はできません。

＜memo＞
逆に、実際に使える具体的なロールは「具象ロール(concrete role)」と呼びますが、この言葉が使われることはまれです。

〓02〓windowロールを指定した不適切な例
＜コード＞
<div role="window">ダイアログのつもり?</div>

＜本文＞
一方で、windowロールの派生ロールであるdialogロールは抽象ロールではないので、〓03〓のような指定は問題ありません。

〓03〓dialogロールを指定した適切な例
＜コード＞
<div role="dialog">ダイアログのつもり</div>

＜memo＞
あるロールが抽象ロールかどうかは、ARIA仕様で確認できます。全部で12のロールが抽象ロールとなっています。
5.3.1 Abstract Roles
https://www.w3.org/TR/wai-aria-1.2/#abstract_roles

＜小見出し＞
ロールの上書き
＜本文＞
HTMLの要素の多くは、もともとセマンティクスを持っています。たとえば、h1要素はランク1の見出しを、main要素は主要なコンテンツを表します。このような、ホスト言語がもともと持つロールを「暗黙のネイティブロール（implicit native role）」、もしくは単に「ネイティブロール（native role）」と呼びます。

＜memo＞
HTMLの要素がどのようなネイティブロールを持つかは、先に紹介したARIA in HTMLで確認できます。

＜本文＞
要素がネイティブロールを持つ場合、role属性で異なるロールを指定すると、ネイティブロールを上書きします。〓04〓は、a要素にrole属性を指定した例です。

〓04〓a要素にrole属性を指定した例
＜コード＞
<a href="/register" role="button">今すぐ登録</a>

＜本文＞
href属性を持つa要素のネイティブロールはlinkですが、role属性によってbuttonロールに上書きされます。そのため、支援技術は、この要素をリンクではなくボタンとして認識します。
ただし、role属性が上書きするのはセマンティクスだけで、機能は変更しません。〓04〓はスクリーンリーダーで「ボタン」と読み上げられますが、button要素のような機能は持ちません。たとえば、スペースキーでボタンを押せるようにはなりません。

＜コラム＞
ネイティブ、暗黙、ホスト言語
＜本文＞
WAI-ARIA仕様では、ネイティブ（native）、暗黙の（implicit）、ホスト言語（host language）といった用語が出てきますが、これらはすべて同じ概念を表しているものです。つまり、HTMLを考える場合、すべてHTMLデフォルトの（default）と読み替えることができます。
ARIA関連仕様では、「ネイティブセマンティクス（native semantics）」という表現も出てきますが、この文脈でのセマンティクスは、ロールだけでなく、ステート、プロパティも含んだ総称に当たります。

＜小見出し＞
指定できるロールの制限
＜本文＞
role属性では要素のネイティブロールを上書きできますが、ネイティブの機能と矛盾するような指定はできません。〓05〓は不適切な例です。

〓05〓button要素を見出しとした構文エラーとなる例
＜コード＞
<button role="heading">見出し?</button>

＜本文＞
button要素をボタンではなく見出しにしようとしていますが、ボタンと見出しとでは役割や機能がかけ離れており、互換性がありません。このような無理のあるロール変更はできず、エラーとなります。
要素に適用できるロールは、ARIA in HTMLで定義されています。button要素に適用できるロールは以下のとおりです。
＜引用囲み＞
checkbox, link, menuitem, menuitemcheckbox, menuitemradio, option, radio, switch or tab.
＜/引用囲み＞
headingロールは含まれていないため、button要素にheadingロールは適用できません。なお、見出しをボタンとして押せるようにしたい場合には、〓06〓のように、見出しの中にボタンを入れる方法があります。

〓06〓見出しの中にボタンを入れた記述例
＜コード＞
<h1><button>見出しボタン</button></h1>

＜memo＞
ARIA in HTMLで許可されている組み合わせであっても、不用意なセマンティクスの変更は望ましくありません。Chapter4-3の「ネイティブセマンティクスをむやみに変更しない」も参照してください。

＜小見出し＞
特殊な働きをするロール
＜本文＞
基本的に、ロールはユーザーにセマンティクスを伝えるものであり、要素の機能を変更することはありません。ただし、中には特殊な働きをするロールもあります。ここでは、注意が必要なロールをいくつか紹介します。

＜丸見出し＞
ランドマークロール
＜本文＞
Chapter3でも触れましたが、ロールの中には「ランドマークロール」と呼ばれるものがあります。これはその名のとおり、ナビゲーションのランドマークとして機能するものです。

＜memo＞
WAI-ARIA仕様では、ランドマークロールが8種類定義されています。
5.3.4 Landmark Roles
https://www.w3.org/TR/wai-aria/#landmark_roles

＜本文＞
支援技術の多くはランドマークを利用したナビゲーションの機能を持ちます。たとえば、mainロールのランドマークまで読み飛ばして本文から読み上げ始める、searchロールのランドマークに移動して検索する、といったことが可能になります。

＜memo＞
ランドマークは便利ですが、使い過ぎには注意してください。コンテンツ内に大量のランドマークが存在すると、目的のランドマークを見つけ出すのに多大な労力がかかってしまいます。

＜丸見出し＞
ライブリージョンロール
＜本文＞
「ライブリージョン（live region）」は、内容が更新された際にユーザーに通知される領域です。
支援技術のユーザーがある箇所を読んでいるとき、他の特定の箇所がリアルタイムで更新されても、その更新に気づかないことがあります。更新される領域に対してライブリージョンを設定しておくと、更新された際にユーザーへ通知され、他の箇所を読んでいても更新に気づくことができます。たとえば、株価の表示、ゲームのスコア表示、緊急性の高いエラーメッセージなど、リアルタイムで更新される箇所に使用します。

＜memo＞
WAI-ARIA仕様では、ライブリージョンの機能を持つロールが5種類定義されています。aria-live属性（P000）を使用すると、他のロールにライブリージョンの機能を持たせることも可能です。
5.3.5 Live Region Roles
https://www.w3.org/TR/wai-aria/#landmark_roles

＜本文＞
ライブリージョンロールは慎重に利用してください。不用意に利用すると、ユーザーが読もうとしている箇所とは無関係なメッセージが不意に読み上げられたり、重要性の低いメッセージが繰り返し読み上げられることになります。場合によっては、コンテンツの読み上げに著しい支障をきたすことがあります。

＜丸見出し＞
ロールの削除：presentationとnoneロール
＜本文＞
presentationロールとnoneロールは、ネイティブロールを打ち消す働きをするロールです。このロールを指定すると、要素はセマンティクスを持たなくなります。

＜memo＞
presentationロールとnoneロールは同じ機能を持つ同義語です。同義の別名のロールが存在するに至った経緯は、仕様の注記で言及されています。
Note regarding the ARIA 1.1 none role.
https://www.w3.org/TR/wai-aria-1.2/#note-regarding-the-aria-1-1-none-role-0

＜本文＞
ネイティブロールを打ち消したいケースには、たとえば以下のようなものがあります。

・table要素を純粋にレイアウト調整のためだけに用いている場合
・親子のロール関係を修復したい場合

親子のロール関係の修復は、たとえば〓07〓のように、ul/li要素を用いてタブコンポーネントを作成するような場合に行います。

〓07〓ul/li要素を用いてタブコンポーネントを作成する記述例
＜コード＞
<ul role="tablist">
  <li>
    <button role="tab" aria-controls="panel1">タブ1</button>
  </li>
  ...
</ul>
<div role="tabpanel" id="panel1">
タブ1は…。
</div>

＜本文＞
一見すると問題ないように見えますが、ul要素のネイティブロール（list）をtablistロールによって上書きした一方で、li要素はネイティブロール（listitem）のままです。これは、ul要素のないli要素が出現しているのと同じ状態で、親子のロール関係に矛盾が生じています。
そこで、presentationロールを用いて〓08〓のようにマークアップすることで、親子のロール関係の修復をします。

〓08〓〓07〓のul/li要素部分の関係性を修復した例
＜コード＞
<ul role="tablist">
  <li role="none presentation">
    <button role="tab" aria-controls="panel1">タブ1</button>
  </li>
  ...
</ul>

＜本文＞
このようにすることで、セマンティクスの観点から矛盾のないタブコンポーネントを作成できます。

＜memo＞
タブコンポーネントの詳細についてはAuthoring Practicesを参照してください。
3.24 Tabs
https://www.w3.org/TR/wai-aria-practices/#tabpanel

＜丸見出し＞
ロールを削除できない場合
＜本文＞
ロールを削除できない場合もあります。まず、フォーカス可能要素やインタラクティブ要素のロールを打ち消すことはできません。これは、要素が操作可能であることを担保するためのルールです。〓09〓はrole属性が機能しない例です。

〓09〓ロールを削除できない例
＜コード＞
<button role="presentation">ボタンじゃない?</button>

＜本文＞
〓09〓の場合、ブラウザーはrole属性を無視しなければならないと定められています。ロールの指定は無視され、ネイティブロールであるbuttonロールが有効になります。
また、グローバルARIA属性が明示的に指定されている場合、その要素のロールは削除できません。〓10〓はaria-describedby属性が指定されている例です。

＜memo＞
グローバルARIA属性の一覧は、WAI-ARIA仕様の6.4 Global States and Propertiesで確認できます。
https://www.w3.org/TR/wai-aria/#global_states

〓10〓aria-describedby属性が指定されている記述例
＜コード＞
<section role="presentation" aria-describedby="heading01">
  <h1 id="heading01">このセクションの説明</h1>
</section>

＜本文＞
〓10〓の場合も、〓09〓と同様に要素のロールは削除できません。グローバルARIA属性が指定されていることが要件のため、たとえばaria-hidden=falseのような一見無意味な指定でも、ロールは打ち消せなくなります。

＜memo＞
グローバルでないARIA属性が付いている場合は、ロールの削除が可能です。たとえば、h1要素にaria-level属性が指定されていても、role="presentation"を指定することでロールを削除できます。

＜小見出し＞
必須の所有要素が存在する場合のロール変更
＜本文＞
HTMLの要素には、table要素やul要素のように、必ず特定の子孫とセットで用いるものがあります。このような場合に必須となる特定の子孫を、ARIA仕様では「必須の所有要素（Required Owned Elements）」と呼んでいます。table要素ならばtr要素が、ul要素ならばli要素が必須の所有要素となります。
要素が必須の所有要素を持つ場合、その要素のロールだけを変更すると、矛盾が生じます。〓11〓は、見た目のためにテーブルレイアウトでカラムを左右に並べたものです。

〓11〓テーブルレイアウトでカラムを左右に並べる記述例
＜コード＞
<table role="presentation">
  <tr>
    <td>左カラム</td>
    <td>右カラム</td>
  <tr>
</table>

＜本文＞
table要素はとtd要素はそれぞれ、ネイティブロールとしてtableロールとcellロールを持ちますが、このままでは支援技術にテーブルとして扱われてしまい、混乱を招きます。そこで、〓11〓ではtable要素にpresentationロールを指定し、テーブルのセマンティクスを打ち消しています。

＜memo＞
table要素にth要素やcaption要素などが一切使われていない場合、ブラウザーはレイアウト目的のテーブルと判断して、独自のロールを割り当てることもあります。

＜本文＞
cellロールは祖先がtableロールであることを前提としていますが、tableロールが失われたことにより、td要素のロールは宙に浮いてしまいます。このようなとき、ブラウザーはtd要素のネイティブセマンティクスを自動的に削除します。
つまり、必須の所有要素を持つ要素にpresentationロールを指定すると、対応する子孫要素にpresentationロールが継承されるような動作になります。

＜memo＞
必須の所有要素ではない要素には影響しません。たとえば、〓11〓でtd要素の中に他の要素があった場合、その要素のロールは変更されません。

＜中見出し＞
代表的なaria-*属性
＜本文＞
ここでは、ステートおよびプロパティを表すaria-*属性のうち、よく利用される代表的なものを紹介します。

＜小見出し＞
aria-hidden属性（ステート）
＜本文＞
aria-hidden属性は、その要素がアクセシビリティAPIに対して公開されるかどうかを指定する属性です。属性値として"true"もしくは"false"を指定します。

＜memo＞
HTMLのブール型属性とは指定の仕方が異なり、aria-hiddenと書いただけでは効果を発揮しないので注意してください。

＜本文＞
aria-hidden=trueを指定した要素はアクセシビリティAPIに公開されず、支援技術からアクセスできなくなります。要素は視覚的に表示されますが、スクリーンリーダーでは読み上げられません。

＜memo＞
視覚的に非表示にするhidden属性、CSSのdisplay: noneやvisibility: hiddenには、aria-hidden=trueと同様にアクセシビリティAPIから隠す効果もあります。そのため、これらとaria-hiddenを併用する必要はありません。

＜本文＞
この属性は、冗長な情報を支援技術から隠すために使用します。たとえば、意味を持たないアイコンを表現するためにアイコンフォントを利用すると、スクリーンリーダーでは意図しない読み上げがなされてしまうことがあります。〓12〓のようにaria-hidden=trueを指定することで、意図しない読み上げを回避できます。

〓12〓aria-hidden=trueを指定する例
＜コード＞
<span class="icon" aria-hidden="true">□</span>

＜本文＞
aria-hidden属性を本当に利用する必要があるのか、十分に考慮してください。意味を持つ要素にaria-hidden=trueを指定すると、支援技術のユーザーにはその意味が伝わらなくなります。この属性を利用してよいのは、その要素を隠していても支援技術のユーザーに十分な情報が伝わり、同等の機能が利用できる場合だけです。

＜memo＞
フォーカス可能な要素にaria-hidden="true"を指定した場合、フォーカスを見失う危険性もあります。フォーカスに関してはChapter4-3も参照してください。

＜小見出し＞
aria-label属性（プロパティ）
＜本文＞
aria-label属性は、要素に対して「アクセシブルな名前（accessible name）」を提供します。言い換えると、要素にラベル付けする文字列を定義します。
主にアイコンボタンなど、視覚的には意味を持ち、かつテキストを持たない要素にラベルを与えるために使用します。〓13〓の例は、閉じるボタンにアルファベット大文字で「X」とだけ記載されている例です。

〓13〓閉じるボタンの記述例
＜コード＞
<button type="button" aria-label="閉じる" onclick="myDialog.close()">X</button>

＜本文＞
視覚的には「X」がバツ印のように見え、閉じるボタンであることが伝わりますが、スクリーンリーダーは単に「エックス ボタン」などと読み上げてしまいます。〓13〓の例ではaria-label属性で「閉じる」というラベルを与えていることで、「閉じる ボタン」と読み上げることが期待されます。
このとき、ボタンの内容であるテキスト「X」を読み上げない点に注意してください。もともとラベルを持っている要素にaria-label属性でラベルを与えた場合、元のラベルは上書きされる形になります。

＜丸見出し＞
aria-labelの使い過ぎに注意
＜本文＞
aria-label属性は支援技術のユーザーに情報を伝えるための手段としては便利なものです。しかし、aria-label属性のラベルを利用できるのは支援技術のユーザーだけであり、視覚的には何も伝わりません。
そのラベルが多くのユーザーにとって有益なものならば、すべてのユーザーに見える形で提示することを検討しましょう。

＜memo＞
見えているテキストをコントロールと結びつけたい場合は、後述のaria-labelledby属性が利用できます。

＜丸見出し＞
名前付けできないロール
＜本文＞
aria-label属性はグローバルARIA属性ですが、WAI-ARIA 1.2では「名前付けできないロール（Roles which cannot be named）」が定義されています。これらのロールではaria-label属性を利用できません。

＜memo＞
5.2.8.6 Roles which cannot be named (Name prohibited)
https://www.w3.org/TR/wai-aria-1.2/#namefromprohibited

＜本文＞
〓14〓は、WAI-ARIA 1.2において語彙的ルールに反する例です。span要素のデフォルトのロールはgenericとなりますが、これは名前付けできないロールであるため、支援技術はこのaria-label属性を無視することがあります。

〓14〓語彙的ルールに反した記述
＜コード＞
<span class="close-icon" aria-label="閉じる">
  <!-- 要素の内容は空だが、CSSでアイコンを表示 -->
</span>

＜memo＞
〓14〓の例はaria-label属性によって代替テキストを提供する意図だと考えられますが、そもそもラベルは代替テキストではないことに注意しましょう。

＜小見出し＞
aria-labelledby属性（プロパティ）
＜本文＞
aria-labelledby属性はaria-label属性と同様の働きをしますが、属性値にラベルの文字列ではなく、ラベルを含む要素のIDを指定します。HTMLのlabel要素のfor属性と似ていますが、label要素とは参照の方向が逆となることに注意してください。
〓15〓のように、スペースで区切ってIDを複数指定すると、そのすべてが有効となり、順に読まれます。

〓15〓aria-labelledby属性の記述例
＜コード＞
<div id="billing">請求書</div>
<div>
  <div id="name">名前</div>
  <input type="text" aria-labelledby="billing name">
</div>
<div>
  <div id="address">住所</div>
  <input type="text" aria-labelledby="billing address">
</div>

＜本文＞
〓15〓では、1つ目のinput要素は「請求書 名前」、2つ目のinput要素は「請求書 住所」とラベル付けされます。
aria-label属性と同様に、元あったラベルが上書きされることに注意してください。〓16〓は、ラベルを持つボタンにaria-labelledby属性を指定した例です。

〓16〓ラベルを持つボタンにaria-labelledby属性を指定した例
＜コード＞
<div id="billing">請求書</div>
<button aria-labelledby="billing">
下書き保存する
</button>

＜本文＞
〓16〓の場合、「請求書 ボタン」とだけ読み上げられ、「下書き保存する」は読み上げられません。ボタンのラベルも読み上げさせたい場合は、〓17〓のようにその要素自身にIDを付け、自身を参照します。こうすると、「請求書 下書き保存する 送信ボタン」と読み上げることが期待できます。

〓17〓ボタンのラベルを読み上げさせる例
＜コード＞
<div id="billing">請求書</div>
<button id="submitbutton" aria-labelledby="billing submitbutton">
下書き保存する
</button>

＜本文＞
aria-labelledby属性では不可視の要素も参照できます。〓18〓のようにすると、不可視のspan要素の内容も参照されて「請求書 を 下書き保存する」というラベルになります。もっとも、実際にはここまでこだわらなくてもユーザーには十分伝わるでしょう。

〓18〓不可視の要素を利用した例
＜コード＞
<div id="billing">請求書</div>
<span id="billingsubname" hidden>を</span>
<button id="submitbutton" aria-labelledby="billing billingsubname submitbutton">
下書き保存する
</button>

＜本文＞
なお、画面上で可視のラベルを持つことができない場合は、aria-labelledby属性ではなくaria-label属性を使うべきです。
aria-labelledby属性とaria-label属性を同時に指定した場合は、aria-labelledby属性だけが有効となり、aria-label属性は無視されます。

＜memo＞
複数の方法でラベルを指定した場合の優先順位については、Chapter4-3を参照してください。

＜小見出し＞
aria-describedby属性（プロパティ）
＜本文＞
aria-describedby属性を利用すると、その要素に対して「アクセシブルな説明（accessible description）」を提供できます。使い方はaria-labelledby属性とほとんど同じで、提供されるものが名前であるのか、説明であるのかという点が異なります。要素のIDを指定すること、複数指定が可能であることも共通です。
多くのスクリーンリーダーは、入力欄の種類とラベルを読み上げた後に説明文を読み上げます。〓19〓は「新しいパスワード パスワード入力欄 半角英数記号、8文字以上512文字以下で入力してください」などと読み上げられます。

〓19〓aria-describedby属性の記述例
＜コード＞
<label>新しいパスワード
<input type="password" aria-describedby="new-pass-desc">
</label>
<p id="new-pass-desc">※半角英数記号、8文字以上512文字以下で入力してください</p>

＜小見出し＞
aria-current属性（ステート）
＜本文＞
aria-current属性は、その要素が「現在の項目（current item）」であることを示します。ページナビゲーション、ステップナビゲーション、パンくずリストなどで現在位置を示したり、カレンダーの中で今日の日付を示すことができます。
属性値として"true"と"false"を指定できますが、そのほかに、現在地の種類を示す5種類のトークンを指定できます。〓20〓は、ページナビゲーションでaria-current属性を利用し、"page"トークンを指定した例です。

〓20〓ページナビゲーションにaria-current属性を指定した例
＜コード＞
<ul>
  <li><a href="../1">1</li>
  <li><a href="../2">2</a></li>
  <li aria-current="page">3</li>
</ul>

＜memo＞
aria-current属性の5種類のトークンとその意味は次のとおりです。
・page：現在のページ
・step：現在のステップ
・location：現在の位置
・date：現在の日付
・time：現在の時間

＜本文＞
このようにすると、3番目の項目では「3 現在のページ」と読み上げることが期待されます。

＜memo＞
フォームコントロールやタブのようなコントロールで現在選択されている項目を表す場合は、aria-current属性ではなくaria-selected属性を使います。Chapter4-3も参照してください。

＜小見出し＞
aria-haspopup属性（プロパティ）
＜本文＞
aria-haspopup属性を指定すると、指定した要素がポップアップする何かを持っていることを示すことができます。典型的には、ポップアップメニューやダイアログボックスを表示するボタンに使用します。
多くの場合、ユーザーはボタンに含まれるアイコンの形状（典型的には、下向きの三角形）によって、ポップアップが出ることを予測します。この属性を利用すると、視覚的に形状を認識できないスクリーンリーダーのユーザーにも、ポップアップメニューが出るボタンであることが伝わります。
属性値には"true"と"false"のほか、5種類のトークンを指定でき、何がボップアップするのかを示すことができます。

＜memo＞
aria-haspopup属性で指定できる5種類のトークンは以下になります。
・menu
・listbox
・tree
・grid
・dialog

＜小見出し＞
aria-expanded属性（ステート）
＜本文＞
aria-expanded属性を利用すると、その要素が所有しているか、もしくはコントロールしている要素の開閉状態を示すことができます。属性値として"true"か"false"のいずれかを指定し、"true"は開いている、"false"は閉じている状態を示します。
〓21〓は、「パネルを開く」ボタンを押すと下の要素が開閉する想定です。

〓21〓aria-expanded属性でパネルの開閉状態を提示する例
＜コード＞
<button type="button" aria-expanded="true" aria-controls="panel01">パネルを開く</button>
<div id="panel01">
開くコンテンツ
</div>

＜本文＞
〓21〓では、ボタンを押すとパネルが開きます。視覚的には、パネルが開いたことは一目瞭然です。しかしスクリーンリーダーのユーザーには、視覚的に伝わっている開閉状態を伝えられていません。
aria-expanded属性を利用することで、スクリーンリーダーのユーザーにも開閉状態を伝えられます。〓21〓の場合、ボタンにフォーカスすると「パネルを開く ボタン 開いています」などと読み上げます。これで、このボタンの操作対象が現在すでに開いていることがわかります。

＜memo＞
〓21〓では、開閉操作の対象の要素が何であるのかをaria-controls属性で示しています。aria-controls属性については後述します。

＜本文＞
aria-expanded属性はグローバル属性ではなく、特定のロールを持つ要素にしか指定できません。基本的に、開閉を制御するボタンとなる要素に指定します。開閉される要素の側に指定するものではないことに注意してください。
ボタンのラベルや他のARIA属性から十分に状態が推測できる場合、aria-expanded属性は不要なこともあります。たとえば、〓21〓ではボタンのラベルが「パネルを開く」となっているため、現在はパネルが閉じている状態であると推測できます。

＜memo＞
同様の理由で、後述のaria-haspopup属性を持っている要素にはaria-expanded属性を指定しなくてよい場合があります。

＜小見出し＞
aria-controls属性（プロパティ）
＜本文＞
aria-controls属性を利用すると、その要素が制御する対象の要素を示すことができます。たとえば、メニューを開くボタンと開いたメニューを結び付けたり、タブとタブパネルを結び付けます。典型的にはaria-expanded属性と組み合わせて使用します。属性値は制御対象の要素のIDで、スペースで区切って複数の指定もできます。〓22〓は、メニューを開くボタンと、メニューの内容を結びつける例です。

〓22〓aria-controls属性の記述例
＜コード＞
<div class="hamburgerMenu">
  <button aria-expanded="true" aria-controls="menu01">
    <span class="menu-icon"><img src="menu.png" alt="メニュー"></span>
  </button>
  <ul id="menu01">
      <li><a href="/">ホーム</a></li>
      <!-- メニュー -->
  </ul>
</div>

＜本文＞
aria-controls属性は明確な挙動が仕様で定義されていないため、基本的にスクリーンリーダーが特別な扱いをすることはありません。aria-controls属性だけでは伝わらないことがあるため、他の手段と併用するとよいでしょう。

＜memo＞
スクリーンリーダーのJAWSはaria-controls属性を独自に解釈し、特定の組み合わせのキーを押すことで、制御対象の要素に移動するオプション機能があります。ただし、移動したあとで元いた場所に戻る手段は提供されていません。

＜小見出し＞
aria-level属性（プロパティ）
＜本文＞
aria-level属性は、要素の階層レベルを示します。属性値として整数を指定します。
典型的な利用法は、headingロールを持つ要素の見出しレベルを示すものです。HTMLの見出し要素はh1〜h6しか存在しませんが、〓23〓のようにするとレベル7の見出しを表現できます。

〓23〓aria-level属性の記述例
＜コード＞
<div class="heading" aria-level="7">見出し7</div>

＜memo＞
見出しの他、リストの階層を表すために用いることもできます。

＜小見出し＞
aria-live属性（プロパティ）
＜本文＞
aria-live属性を使用すると、要素をライブリージョンとして定義したり、その動作を変更したりできます。

＜memo＞
aria-live属性の指定は慎重に行なってください。不用意に利用すると、ライブリージョンロールと同様の問題を起こします。詳細はライブリージョンロール（P000）を参照してください。

＜本文＞
aria-live属性に設定できる値は"off"、"polite"、"assertive"の3種類です。
offを指定した場合、ユーザーが該当のライブリージョンにフォーカスしているときのみ変化が伝わります。他の要素にフォーカスしている場合には何も伝わりません。広告や時計など、あまり重要でない情報に対して利用します。
politeを指定した場合、ライブリージョンの変化は、スクリーンリーダーのタスクが一段落した時点で通知されます。たとえば、スクリーンリーダーが他の箇所を読み上げている場合は、その読み上げが終わってから通知が行われます。
assertiveを指定した場合、ライブリージョンの変化は即座に伝えられます。スクリーンリーダーが他の箇所を読み上げている場合、その読み上げを強制的に中断します。
先に紹介したように、ライブリージョンの機能を持つロールも存在します。これらにはaria-live属性のデフォルトの挙動が定義されてます。

＜memo＞
ロールとaria-live属性値の対応は以下のようになります。
・alert : assertive
・log : polite
・marquee : off
・status : polite
・timer : off

＜本文＞
ライブリージョンロールにaria-live属性を指定すると、デフォルトの挙動を上書きできます。しかし、挙動を変更することは推奨されません。とくにassertiveの指定は慎重に行ってください。
ライブリージョンが機能するためには、ドキュメントが読み込まれた時点であらかじめライブリージョンとして設定されている必要があります。JavaScriptによってあとから動的にaria-live属性を追加しても、その要素はライブリージョンにはなりません。

＜memo＞
aria-live属性に関連する属性として、aria-atomic属性もあります。ライブリージョンの変化が発生したとき、変化した箇所だけを通知するか、ライブリージョン全体を通知するかを設定します。
