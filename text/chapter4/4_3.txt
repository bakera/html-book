＜タイトル＞
ARIA利用時の注意点
＜本文＞
Chapter4-2ではWAI-ARIAと関連仕様について取り上げました。WAI-ARIAではさまざまな属性が定義されていますが、誤用や使いすぎには注意が必要です。このChapterでは、ARIA属性を利用する際の注意点を紹介します。


＜中見出し＞
ARIA利用時の基本的な注意点
＜本文＞
WAI-ARIAは便利ですが、むやみに使っても効果がなかったり、かえって混乱を招いたりすることがあります。WAI-ARIAの関連文書には、誤用や使いすぎに関する言及があります。
ここでは、WAI-ARIAを利用する際の基本的な注意点を3つ紹介します。

＜小見出し＞
1. HTML自身に備わっている機能を利用する
＜本文＞
WAI-ARIAに関する警句として、以下のようなものがあります。
＜引用囲み＞
ARIAを使う際に最も注意すべきことは、ARIAを使わないようにすることです
＜/引用囲み＞

＜memo＞
2.1 No ARIA is better than Bad ARIA
https://www.w3.org/TR/wai-aria-practices/#no_aria_better_bad_aria

＜本文＞
これは、HTMLにもともと備わっているネイティブな機能でWAI-ARIAと同等の表現ができる場合、HTMLの機能を使用すべきという意味です。たとえば、メインコンテンツと見出しはWAI-ARIAで〓01〓のように表現できます。これは結局のところ、〓02〓と同じ意味です。
〓01〓と〓02〓はどちらも機能は同じですが、このような場合はHTMLのネイティブセマンティクスを利用した〓02〓を選択します。

〓01〓WAI-ARIAを用いたコード例
<div role="main">
  <div role="heading" aria-level="1">メインコンテンツ</div>
  ...
</div>

〓02〓ネイティブセマンティクスを用いたコード例
<main>
  <h1>メインコンテンツ</h1>
  ...
</main>

＜小見出し＞
2. 冗長なロールやARIA属性を使用しない
＜本文＞
HTMLのネイティブセマンティクスとWAI-ARIAのセマンティクスを同時に使用する状況もありえます〓03〓。

〓03〓ネイティブセマンティクスとWAI-ARIAのセマンティクスを同時に使用する例
＜コード＞
<main role="main">
  <h1 role="heading" aria-level="1">メインコンテンツ</h1>
  ...
</main>

＜本文＞
〓03〓は特に害はありませんが、冗長であり、やはり望ましくありません。
ARIAの機能とまったく同一の機能がネイティブで利用できる場合は、ネイティブの機能だけを使用し、ARIAを使わないようにすることがARIA in HTML仕様で推奨されています。

＜memo＞
2.2 Don't add redundant roles
https://www.w3.org/TR/html-aria/#don-t-add-redundant-roles

＜本文＞
かつてのHTML 5.0仕様では、main要素にrole="main"もあわせて指定するようアドバイスされていたことがあります。しかし、これは当時のブラウザーの互換性のためのもので、現在ではこのような指定は必要ありません。

＜memo＞
4.4.14 The main element
https://www.w3.org/TR/2018/SPSD-html5-20180327/grouping-content.html#the-main-element

＜本文＞
プロパティやステートも同様です。インタラクティブな要素に冗長なステートを設定すると、有害なこともあります。たとえば、チェックボックスが「チェックされている」という状態は、HTMLのchecked属性とWAI-ARIAのaria-checked属性で表現できます。〓04〓は、その両方を指定した例です。

〓04〓checkedとaria-checked属性を併用した望ましくない例
＜コード＞
<input type="checkbox" checked aria-checked="true">

＜本文＞
これは単に冗長なだけではありません。ユーザーがチェックボックスのチェックを外した場合、aria-checked属性の値が自動で"false"に変わることはないため、支援技術には「チェックされている」ままの状態として通知されてしまいます。〓05〓のように、単にHTMLのchecked属性を使い、冗長なaria-checked属性は使わないようにします。

〓05〓checked属性のみを使用した適切な例
＜コード＞
<input type="checkbox" checked>

＜小見出し＞
ネイティブセマンティクスをむやみに変更しない
＜本文＞
Chapter4-2の「ロールの上書き」で説明したとおり、role属性を指定すると、要素のセマンティクスを上書きして変更できる場合があります。
この場合、元からあったネイティブセマンティクスは失われることに注意してください。不用意な変更は望ましくありません。〓06〓は望ましくない例です。

〓06〓h2要素をtabロールで上書きした望ましくない記述例
＜コード＞
<div role="tablist">
  <h2 role="tab">見出しタブ</h2>
</div>

＜本文＞
この例ではh2要素のロールをtabに変更しています。この場合、h2要素のheadingロールは失われ、見出しであることは伝わらなくなります。見出しのセマンティクスは生かしたまま、tabロールの要素を新規に追加するほうがよいでしょう〓07〓。

〓07〓見出しのセマンティクスを生かした記述例
＜コード＞
<div role="tablist">
  <div role="tab">
    <h2>見出しタブ</h2>
  </div>
</div>

＜中見出し＞
インタラクティブな要素を扱う際の注意点
＜本文＞
独自のウィジェットを実装する場合など、WAI-ARIAをインタラクティブな要素と組み合わせて利用する機会も多いでしょう。ここでは、インタラクティブな要素を扱う際の注意点を紹介します。

＜小見出し＞
1. マウスやタップ操作可能なものはキーボードでも操作可能にする
＜本文＞
div要素やspan要素などの要素にJavaScriptで機能を追加し、独自のウィジェットを作ることがあります。Chapter4-2で説明したように、role属性を利用すると、その要素が操作可能なコントロールであることを伝えられます。
注意しなければならないのは、WAI-ARIAは機能を追加しないことです。ロールを指定しても、自動的に操作可能になるわけではありません。たとえば、〓08〓ではdiv要素にrole=buttonを指定しています。

〓08〓div要素にrole=buttonを指定
＜コード＞
<div role="button" onclick="pushedButton()">素敵なボタン</div>
<script>
const pushed = () =>{
  alert('押されました'); // ボタンを押されたときの処理
}
</script>

＜本文＞
この要素はボタンとしてのセマンティクスを持ち、支援技術にはボタンであると伝えられます。また、ボタンを押した際の動作はonclick属性に記述したJavaScriptで実現しています。マウスでクリックするとボタンのように動作し、問題ないように見えますが、以下のような機能はありません。

・キーボードのTabキーでフォーカスを当てる
・キーボードのEnterキー、Returnキー、spaceキーでボタンを押す

つまり、このボタンはキーボード操作ができません。
ユーザーがクリック、タップ、ドラッグ、ドロップ、スライド、スクロールといった各種の操作を行えるとき、キーボードのみの環境でも同等の操作を実現できるようにする必要があります。これは、WCAG 2.1達成基準2.1.1「キーボード」の要請であり、アクセシビリティ上の重要事項でもあります。

＜memo＞
Success Criterion 2.1.1 Keyboard
https://www.w3.org/TR/WCAG21/#keyboard

＜本文＞
スマートフォンなど、典型的にはタップ操作を行う環境でも、キーボード操作への対応は必要です。スクリーンリーダーを利用する場合はキーボード操作に準じた操作が必要となります。

＜memo＞
実際にBluetoothキーボードを利用することも考えられます。

＜本文＞
ARIAを併用したキーボード操作の考え方については、WAI-ARIA Authoring PracticesのDeveloping a Keyboard Interfaceが参考になります。

＜memo＞
6. Developing a Keyboard Interface
https://www.w3.org/TR/wai-aria-practices-1.2/#keyboard

＜小見出し＞
2. 操作可能な要素を隠さない
＜本文＞
要素にaria-hidden="true"を指定しても、フォーカス移動には影響しません。フォーカス可能な要素にaria-hidden="true"を指定すると、フォーカスは当たります。しかし、支援技術からはその要素が見えなくなるため、支援技術のユーザーはフォーカスを見失ってしまいます〓09〓。

〓09〓aria-hidden="true"を指定した問題のある記述例
＜コード＞
<button aria-hidden="true">支援技術に「見えない」がフォーカスは当たるボタン</button>

＜本文＞
フォーカスが当たらなければ問題は起きないため、視覚環境も含めたすべての環境から要素を隠したり、フォーカスを無効にすれば問題を回避できます。〓10〓はこの問題が起きない例です。

〓10〓フォーカスを無効にして問題を回避した記述例
＜コード＞
<button hidden>すべての環境から隠されたボタン</button>
<button aria-hidden="true" disabled>無効のボタン</button>
<button aria-hidden="true" tabindex="-1">フォーカスの当たらないボタン</button>

＜本文＞
逆に、フォーカス可能な要素を視覚的に隠し、支援技術からはアクセス可能にした場合にも問題が起きます。この場合、視覚環境でキーボード操作したユーザーは、見えない要素にフォーカスが当たってフォーカスを見失ったり、操作できることを想定していない要素が操作できてしまうことがあります。
意図的に隠す場合だけでなく、ある要素が別の要素に重なって視覚的に見えない場合や、ある領域が操作不能であることを示すために視覚的にグレーアウトした場合にも同様の問題が起こることがあります。

＜memo＞
WCAG 2.1達成基準2.4.3「フォーカス順序」の問題を引き起こすことがあります。
Success Criterion 2.4.3 Focus Order
https://www.w3.org/TR/WCAG21/#focus-order

＜小見出し＞
3. 操作可能な要素にアクセシブルな名前を持たせる
＜本文＞
操作可能な要素、すなわちインタラクティブな要素には、アクセシブルな名前を付けなければなりません。〓11〓は不適切な例です。

〓11〓内容が空のボタンの不適切な例
＜コード＞
<button><span class="menu-icon"></span></button>

＜本文＞
このような空の要素を用意し、CSSでアイコンを表示して、アイコンボタンとして利用するケースがあります。この要素はアクセシブルな名前を持ちません。スクリーンリーダーの利用者がこのボタンにフォーカスした場合、単に「ボタン」と読み上げられるだけで、何をするボタンなのかわかりません。
操作可能な要素には、アクセシブルな名前を与える必要があります。ARIA 1.2のRoles Supporting Name from Authorでは名前を与えられるロールを定めていますが、この一覧で「(name required)」とされているロールに対応する要素は、必ず名前を与えなければなりません。
名前を与える方法は、後述の「アクセシブルな名前を与える方法」を参照してください。

＜memo＞
5.2.8.4 Roles Supporting Name from Author
https://www.w3.org/TR/wai-aria-1.2/#namefromauthor

＜中見出し＞
アクセシブルな名前を与える方法
＜本文＞
要素によって、アクセシブルな名前を提供する方法は異なります。

＜memo＞
アクセシブルな名前は、HTML Accessibility API Mappings仕様に基づいて算出されます。
4. Accessible Name and Description Computation
https://www.w3.org/TR/html-aam-1.0/#accessible-name-and-description-computation

＜本文＞
〓11〓のようなbutton要素であれば、要素の内容となるテキストがアクセシブルな名前となります。〓12〓の例は「メニュー ボタン」と読み上げることが期待できます。画像の代替テキストもアクセシブルな名前となります〓13〓。

＜memo＞
CSSの::before擬似要素や::after擬似要素で追加したテキストもアクセシブルな名前に含まれます。つまり、スクリーンリーダーで読み上げられます。

＜本文＞
〓12〓要素のテキストがアクセシブルな名前となる記述例
＜コード＞
<button><span class="menu-icon">メニュー</span></button>

〓13〓画像の代替テキストがアクセシブルな名前となる記述例
＜コード＞
<button><img src="menu-icon.png" alt="メニュー"></button>

ラベル付け可能要素を利用している場合は、label要素（P000）で名前を与えることができます。

また、以下の属性によっても名前を与えることができます。

・aria-labelledby属性（P000）
・aria-label属性（P000）
・title属性（P000）

実際に何がアクセシブルな名前として認識されているかは、ブラウザーの開発者ツールで確認できます。たとえばChromeでは、要素を「検証」して開発者ツールを開き、"Accessibility"パネルを開くと確認できます〓14〓。

＜memo＞
Accessibilityパネルは環境によって「ユーザー補助」と訳されている場合もあります。

〓14〓Accessibilityパネル

＜小見出し＞
操作可能でないは要素にアクセシブルな名前を与える
＜本文＞
インタラクティブではない要素にも、アクセシブルな名前を付けられる場合があります。ARIA 1.2のRoles Supporting Name from Authorでは、どのロールが名前付け可能かを定義しています。

＜memo＞
5.2.8.4 Roles Supporting Name from Author
https://www.w3.org/TR/wai-aria-1.2/#namefromauthor

＜本文＞
よくあるケースは、ランドマークに名前を与えるものです。たとえば、1つのページに複数のnav要素がある場合、スクリーンリーダーはどれも「ナビゲーション ランドマーク」としか読み上げないため、区別ができません。そこで、たとえばaria-label属性で名前を与えることがあります〓15〓。

〓15〓aria-label属性で名前を与える記述例
＜コード＞
<nav aria-label="パンくずナビゲーション">
  <!-- ヘッダーナビゲーション -->
</nav>
...
<nav aria-label="グローバルナビゲーション">
  <!-- グローバルナビゲーション -->
</nav>
...
<nav aria-label="フッターナビゲーション">
  <!-- フッターナビゲーション -->
</nav>

＜本文＞
ただし、この名前が有用かどうかはまた別の話です。「パンくずナビゲーション」「グローバルナビゲーション」と言われたとき、ユーザーはその内容を想像できない可能性もあります。名前で説明することを考える前に、多数のnav要素を区別させなければならない状況自体を改善するべきでしょう。
名前がなくても、コンテキストで理解できるケースもあります。〓16〓の例では、2つのnav要素に名前を付けています。

〓16〓2つのnav要素に名前を付けた記述例
＜コード＞
<header>
  <nav aria-label="ヘッダーナビゲーション">
    <!-- ヘッダーナビゲーション -->
  </nav>
</header>
...
<footer>
  <nav aria-label="フッターナビゲーション">
    <!-- フッターナビゲーション -->
  </nav>
</footer>

＜本文＞
しかしこの例では、それぞれのnav要素がヘッダー内・フッター内にあることは要素のセマンティクスからも明らかです。「ヘッダーナビゲーション」「フッターナビゲーション」という名前からは、追加の情報はほとんど得られません。
インタラクティブでない領域にaria-label属性やaria-labelledby属性を用いてアクセシブルな名前を与える場合、名前が本当に必要なのか、有用な名前を付けられるかという点を考えるようにしましょう。

＜中見出し＞
ARIA実装の基本テクニック
＜本文＞
WAI-ARIAを利用した実装には、さまざまなテクニックがあります。WAI-ARIA Authoring Practicesでは、コード例とともに多数のテクニックを学ぶことができます。

＜memo＞
WAI-ARIA Authoring Practices 1.1
https://www.w3.org/TR/wai-aria-practices/

＜本文＞
WAI-ARIAのテクニックの中には、さまざまな局面で利用でき、応用が利くものもあります。ここでは、そのような基本テクニックをいくつか紹介します。

＜小見出し＞
アクセシブルな名前を提供する方法
＜本文＞
前述したように、要素にアクセシブルな名前を提供する方法は複数あります。
実装時には、どの方法を採用すればよいか迷うかもしれません。WAI-ARIA Authoring Practices 1.2のCardinal Rules of Namingでは、名前を与える際に考えるべきこととして、5つのルールが紹介されています。

・（仕様に反した実装をしないように）テストを行い、警告に注意する
・可視のテキストを使う
・HTMLのネイティブ機能を使う
・（title属性やplaceholder属性などによる）ブラウザーのフォールバックに頼ることは避ける
・簡潔で有用な名前を付ける

＜memo＞
5.3.1 Cardinal Rules of Naming
https://www.w3.org/TR/wai-aria-practices-1.2/#naming_cardinal_rules

＜本文＞
筆者が特に重要だと考えるのは、「可視のテキストを使う」ことと、「HTMLのネイティブ機能を使う」ことです。コントロールにlabel要素で名前を付けることは、その両方を満たす方法であり、ベストな方法といえます。
ビジュアルデザインの制約などでラベルを設けるスペースがない場合でも、たとえばフローティングラベル（floating label）と呼ばれる手法を用いると、可視のラベルテキストを確保できます。

＜memo＞
Bootstrapの例が参考になります。
https://getbootstrap.com/docs/5.1/forms/floating-labels/

＜本文＞
インタラクティブでない要素に名前を与える場合も、考え方の基本は同じです。この場合、label要素は利用できませんが、aria-labelledby属性を用いて可視のテキストと関連付けることができます。こうすることで、支援技術を利用するユーザー、利用しないユーザーの双方に情報が伝わります〓17〓。

〓17〓aria-labelledby属性で可視テキストと関連付ける例
＜コード＞
<nav aria-labelledby="product">
  <div id="product">製品</div>
  <!-- 製品ページへのリンクのナビゲーションリスト -->
</nav>

＜本文＞
もっとも、nav要素はセクショニングコンテンツでもあるため、内容の先頭に見出しがあれば、セクションの見出しとして扱われます。〓17〓では、div要素を見出しに変更し、aria-labelledby属性を削除してもよいでしょう。

＜小見出し＞
スクリーンリーダー向けテキストを提供する
＜本文＞
要素の内容がアクセシブルな名前として扱われる場合、スクリーンリーダーに読み上げさせる専用のテキストを入れる方法もあります〓18〓。

〓18〓読み上げ専用のテキストを記述した例
＜コード＞
<button>
  <span class="visually-hidden">メニュー</span>
  <span class="menu-icon"></span>
</button>

＜本文＞
visually-hiddenは、視覚環境で表示されず、かつスクリーンリーダーでは読み上げられるようなスタイルを定義したクラスです。CSSフレームワークは、このようなクラスをあらかじめ用意していることがあります。たとえば、Bootstrap 5.0のvisually-hiddenには、〓19〓のようなスタイルが定義されています。

＜memo＞
_visually-hidden.scss
https://github.com/twbs/bootstrap/blob/main/scss/mixins/_visually-hidden.scss

＜本文＞
〓19〓Bootstrap 5.0のvisually-hiddenのコード
＜コード＞
.visually-hidden {
  position: absolute !important;
  width: 1px !important;
  height: 1px !important;
  padding: 0 !important;
  margin: -1px !important;
  overflow: hidden !important;
  clip: rect(0, 0, 0, 0) !important;
  white-space: nowrap !important;
  border: 0 !important;
}

こうしておくと、テキストはスクリーンリーダーで読み上げられ、かつ視覚環境には影響を与えません。
このテクニックは、ボタンの外でも使えます。任意のspan要素やdiv要素などにこのクラスを指定することで、テキストをスクリーンリーダーだけに読み上げさせることができます。
このテクニックを利用する際は、先に紹介した「操作可能な要素を隠さない」（P000）という考え方と競合することに注意してください。原則として、操作可能な要素に適用すべきではありません。〓20〓は、Chapter3-5で紹介した「スキップリンク」にvisually-hiddenを適用し、視覚的に隠した例です。
この場合、スキップリンクは視覚的に隠されていますが、キーボードフォーカスは受け取ります。視覚環境を利用するキーボードユーザーは、フォーカスを見失ってしまうことになります。

〓20〓スキップリンクにvisually-hiddenを適用した記述例
＜コード＞
<body>
  <div class="visually-hidden">
    <a href="#content">メインコンテンツへ</a>
  </div>
...
  <main id="content">

＜小見出し＞
キーボードフォーカスを制御する
＜本文＞
通常、フォーカス可能でない要素はキーボードフォーカスを受け取れませんが、Chapter4-1で紹介したtabindex属性を利用すると、フォーカスを受け取れるようになります。
tabindex="0"を指定すると、ユーザーがフォーカスを移動してフォーカスを当てられるようになります。〓21〓はdiv要素をフォーカス可能にする例です。

〓21〓div要素をフォーカスする記述例
＜コード＞
<div class="button" tabindex="0">ボタン?</div>

＜本文＞
ただし、これだけでは単にフォーカスが当たるだけで、他の機能は持ちません。フォーカスを当てた後に何か操作をさせたい場合、それは自力で実装する必要があります。前述の「マウスやタップ操作可能なものは、キーボードでも操作可能にする」（P000）も参照してください。
tabindex="-1"を指定した場合、ユーザーがフォーカスを当てることはできませんが、JavaScriptのfocus()メソッドでフォーカスを移せるようになります。たとえば、ユーザーがボタンを押した際に別の場所にフォーカスを移動したい場合などに利用します。
ただし、予想外のフォーカス移動が行われるとユーザーは混乱します。基本的には、ユーザーの何らかの操作をトリガーとするようにしてください。

＜中見出し＞
動作検証とアクセシビリティサポーテッド
＜本文＞
最後に、筆者が重要だと考えている動作検証についてお伝えします。
アクセシビリティに関する技術や機能が、ブラウザーや支援技術によって十分に対応されて、意図どおりに動作するとき、その状態のことを「アクセシビリティサポーテッド（Accessibility supported）」であるといいます。

＜memo＞
逆に、ブラウザーや支援技術によるサポートが十分でない場合、アクセシビリティサポーテッドでないということになります。

＜本文＞
特に、WAI-ARIAは比較的新しい技術でもあり、古い支援技術はARIA属性を十分にサポートしていないことがあります。仕様で規定されたARIA属性を適切に利用していても、アクセシビリティサポーテッドでないことがあり、意図どおりに機能しないことがあるということです。
また、ARIAのルールにはかなり複雑な部分があります。これまで説明してきたように、特定の要素に適用できないロールがある、ロールとARIA属性との組み合わせを許可しない場合がある、他のARIA属性が効果を上書きする場合があるなど、さまざまな注意点があります。正直なところ、これらすべてを正確に把握するのはかなり難しく、正しい効果が予想しにくい場合もあるでしょう。
そこで重要になるのが、動作検証です。検証といっても、大掛かりなものである必要はありません。最近では多くのOSにスクリーンリーダーの機能が組み込まれており、追加のスクリーンリーダーを導入することなく検証できます。ARIA属性を利用するときには、実際にスクリーンリーダーを利用してアクセスし、動作検証を行うようにしましょう。

＜memo＞
可能であれば、普段から支援技術を利用しているユーザーにアクセスしてもらって、その意見を聞くとよいでしょう。ARIAの使いすぎや、説明が冗長であるという意見は、コンテンツの実装者からはなかなか出てこないものです。

＜本文＞
アクセシビリティに唯一の正解はありませんが、WAI-ARIAを利用するのは、支援技術でもコンテンツにアクセスしやすくしたいという動機によるものです。支援技術のユーザーに実際にコンテンツにアクセスしてもらい、フィードバックを得ることで、品質を向上できるでしょう。