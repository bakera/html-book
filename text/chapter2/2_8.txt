＜タイトル＞
HTMLの細かい構文ルール
＜リード＞
タグの書き方については、主にセキュリティの観点から通常は行わないマークアップの解釈について、検討が必要となることがあります。ここでは、タグの書き方についてもう一歩踏み込んで説明します。

＜中見出し＞
細かい構文ルールを知りたいときは
＜本文＞
HTMLパーサー（HTMLを解釈するプログラム）のルールは仕様で明確に定められています。仕様のParsing HTML documentsのセクションでは、ある状況で特定の文字が出現した場合にどのように解釈するのか、というレベルまで挙動が規定されています。「このような書き方は可能か？」「このように書いた場合にどのように解釈されるのか？」という疑問は、ほとんどの場合、仕様をつぶさに読むことで解決できます。

＜memo＞
Parsing HTML documents
https://html.spec.whatwg.org/multipage/parsing.html

＜中見出し＞
タグ名に使用できる文字
＜本文＞
Chapter2-7でも触れましたが、HTMLのタグ名はASCII英字で始まる必要があり、数字で始まることは許されません。つまり、〓01〓のようなマークアップは構文エラーとなり、結果としてタグではなくテキストとして解釈されます〓02〓。

＜memo＞
この場合、「invalid-first-character-of-tag-name parse error」となります。

〓01〓タグ名が数字の開始タグを誤って記述した例
＜コード＞
<42>

〓02〓エラー処理による〓01〓の解釈
＜コード＞
&lt;42>

＜本文＞
ASCII英字でなければならないのは1文字目だけです。構文上、2文字目以降には数字や記号類が使用できます。2文字目以降に利用できない文字は、以下に挙げるものに限られます。

・>：タグの終了と解釈されます
・ASCII空白文字：属性値との区切りと解釈されます
・/：自己終了タグもしくは属性値との区切りと解釈されます

＜memo＞
タグ名の2文字目以降にASCII英字でない文字が使われている例としては、h1要素などがあります。

＜本文＞
興味深いことに、タグの開始のマークである<も利用できる文字となっており、タグ名の一部として解釈されます。たとえば〓03〓は、<h1>タグの>が抜けた形ですが、これはh1<spanという名前の要素があるものとみなされ、〓04〓のように解釈されます。

〓03〓<h1>タグの>が抜けた記述例
＜コード＞
<body>
  <h1<span>test</span></h1>
</body>

〓04〓〓03〓の解釈
＜コード＞
<body>
  <h1<span>test</h1<span>
</body>

＜memo＞
〓03〓は構文エラーですが、エラー処理により、対応する開始タグがない</h1>と</span>は無視され、</body>の前に</h1<span>の終了タグが補われています。

＜本文＞
タグ名に<を含めることができるのは、SGMLやXMLとは互換性のない挙動です。SGMLでは、〓03〓のようなケースを「閉じない開始タグ（unclosed start tag）」とみなし、<h1><span>と補います。XML構文の場合には、Well-formedではないため、パースエラーとなります。

＜word＞
Well-formed（整形式）
XMLの文書について、タグの対応関係などの字句的ルールが満たされていること。語彙的ルールを満たすかどうかは問わない。

＜本文＞
セキュリティの観点からは、タグ名に後続する/の扱いに注意が必要です。〓05〓のマークアップは構文エラーですが、/はタグ名の一部とはみなされません。エラー処理により、/の後が属性名とみなされ、〓06〓のように解釈されます。タグ内部に空白を挿入できなくても、属性を挿入できる点に注意が必要です。

＜memo＞
この場合、unexpected-solidus-in-tag parse errorとなります。

〓05〓タグ内部に誤った/を含む記述例
＜コード＞
<span/onmouseover="alert(1);">test</span>

〓06〓エラー処理による〓05〓の解釈
＜コード＞
<span onmouseover="alert(1);">test</span>

＜中見出し＞
終了タグに属性は書けない
＜本文＞
終了タグに属性を書くことはできません。終了タグに属性を書いた場合〓07〓、エラーとなり、属性は無視されます。なお、終了タグ自体は有効に機能します。

〓07〓終了タグに誤って属性を記述した例
＜コード＞
<p>foo</p class="foo">

＜memo＞
この場合、end-tag-with-attributes parse errorとなります。

＜中見出し＞
終了タグ末尾の/
＜本文＞
終了タグの末尾に/を書くことはできません。〓08〓の場合はエラーとなり、単に/が無視されます。なお、終了タグ自体は有効に機能します。

〓08〓終了タグ末尾に/を記述した例
＜コード＞
<p>foo</p/>

＜memo＞
この場合、end-tag-with-trailing-solidus parse errorとなります。

＜中見出し＞
空タグ
＜本文＞
SGMLでは「空タグ（empty tag）」と呼ばれる記述が許されており、理論上はHTML4でも使用可能でした。文字通り空のタグ、タグ名部分を省略したタグで、空の開始タグ、空の終了タグがあり、直近に開いた要素の名前を参照します。〓09〓は空タグの記述例です。

＜memo＞
もっとも、実際にはほとんどのブラウザーは空タグを仕様のとおりには処理していませんでした。

〓09〓空タグの記述例
＜コード＞
<p>テキスト</>
<>テキスト</>

＜本文＞
〓09〓では、<>と</>は、それぞれ<p>と</p>の省略とみなされます。
しかし、このような空タグは現在のHTML構文では使用できません。空の開始タグはエラーとなり、<>という文字列のテキストノードになります。空の終了タグもエラーですが、こちらは終了タグが丸ごと無視されます。〓09〓の場合、p要素が2つできることはなく、テキスト <>テキストというテキストノードを持った1つのp要素になります。

＜中見出し＞
開始タグを省略すると属性は書けない
＜本文＞
開始タグは省略できる場合があります。ただし、開始タグを省略した際に属性のみを書く方法は存在しません。つまり、属性を指定したければ必ず開始タグを書かなければなりません。
たとえば、html要素の開始タグは省略可能ですが、lang属性を指定したい場合は開始タグを書く必要があります〓10〓。

〓10〓属性値を指定した開始タグの記述例
＜コード＞
<html lang="ja">

＜中見出し＞
重複する属性
＜本文＞
Chapter2-2でも触れましたが、同一の属性は複数指定できません。
〓11〓は構文エラーとなり、後の方の属性が無視されて〓12〓のように解釈されます。

〓11〓同一属性を複数記述したエラーとなる例
＜コード＞
<body class="type1" class="type2">

〓12〓エラー処理による〓11〓の解釈
＜コード＞
<body class="type1">

＜memo＞
この場合、duplicate-attribute parse errorとなります。

＜本文＞
属性の種類によっては、1つの属性に複数の値を指定できる場合があります。class属性の場合、〓13〓のようにASCII空白文字で区切って指定します。

〓13〓class属性で複数の値を指定した例
＜コード＞
<body class="type1 type2 type3">

＜中見出し＞
属性値の省略
＜本文＞
Chapter2-3のブール型属性で触れましたが、空の属性値の記述は省略できます。〓14〓の3つのimg要素の書き方は同じ意味になります。

〓14〓属性値の省略例
＜コード＞
<img alt>
<img alt="">
<img alt=''>

<img alt="">と書いた場合、ブラウザーの開発者ツールで調査してDOMツリーを見ると<img alt>と表示される場合があります。これは、もっとも短い書き方で正規化されているためです。
なお、属性自体を丸ごと省略した場合とは意味が異なることに注意してください。ブール型属性の場合は意味が正反対になりますし、img要素のalt属性など、属性を省略した場合とは意味が大きく異なる場合があります。

＜memo＞
img要素についてはChapter3-7で詳しく説明します。

＜中見出し＞
引用符のない属性
＜本文＞
属性を書く場合には属性値を引用符で括るのが基本ですが、引用符を省略できる場合もあります。引用符を省略した場合、以下のようになります。

・タブ、改行、スペース、>が出現すると属性値の終了とみなされる
・"、'、<、=、`が出現すると構文エラーとなるが、該当の文字は属性値の一部とみなされて処理される

属性値を引用符で括った場合、対応する引用符（"もしくは'）で終了するのに対し、括らない場合はさまざまな文字で属性値が終了します。これはクロスサイトスクリプティング（XSS）脆弱性の原因となりやすいため、セキュリティ上の観点からは、属性値を引用符で括ることが強く推奨されています。

＜memo＞
この場合、unexpected-character-in-unquoted-attribute-value parse errorとなります。

＜word＞
クロスサイトスクリプティング（XSS）
ユーザーが入力した内容を表示するようなウェブサイトで、不正な内容を表示させてHTMLの構文を破壊し、悪意のあるHTMLやスクリプトを挿入する攻撃。本物サイト上で偽情報が表示されたり、スクリプトが実行されて不正な操作、情報の詐取などが行われれることがある。

＜中見出し＞
plaintext要素の処理
＜本文＞
昔のHTMLではplaintext要素が定義されていました。これはもともと、HTTP/0.9でContent-Typeフィールドが存在しなかった時代に、データの先頭に<plaintext>と書くことで、プレーンテキストであることを明示するものでした。
現在のHTMLではこの要素は廃止されていますが、ブラウザーはplaintextというタグ名の開始タグに遭遇すると、以降をすべてプレーンテキストとして処理し、タグも文字参照も解釈しなくなります。</plaintext>という文字列があってもそのまま表示します。

＜memo＞
HTML Standardではobsolete feature（廃止された機能）として記載されています。

＜本文＞
現在では、Content-Type: text/plainを指定してプレーンテキストであることを示せるため、plaintext要素を使う必要はありません。
何らかの理由でContent-Typeを適切に設定できない場合に、これを書くことで、Content-Typeヘッダーの誤判定によるXSSを回避できるケースがあるかもしれません。

＜中見出し＞
終了タグを書き漏らした際のエラー
＜本文＞
終了タグを書き漏らした場合、特殊な方法で補われるケースがあります。〓15〓は問題のないマークアップです。

〓15〓問題のないマークアップ
＜コード＞
<p><b>b要素</b></p>
<p>bのないp</p>

＜本文＞
一方で、〓16〓のように終了タグ</b>を書き忘れたとしましょう。
b要素の終了タグは省略できないため、これは構文エラーとなります。エラー処理の結果、これは〓17〓のように解釈されます。
終了タグが補われただけでなく、次のp要素の外側がb要素とみなされます。エラー修正のされ方は要素によっても異なり、かなり複雑です。後述のように、直感に反する挙動となることもあるため、エラーが起こらないようにマークアップすることをお勧めします。

〓16〓</b>を書き忘れた記述例
＜コード＞
<p><b>b開始タグ</p>
<p>bのないp</p>

〓17〓エラー処理による〓16〓の解釈
＜コード＞
<p><b>b開始タグ</b></p>
<b><p>bのないp</p></b>

＜中見出し＞
直感に反するエラー処理
＜本文＞
HTML Standardのエラー処理には、直感に反する独特なルールがいくつかあります。

＜小見出し＞
ノアの箱舟ルール
＜本文＞
〓16〓に<b>の終了タグを書き忘れた例を紹介しました。
〓18〓は、<b>を4つに増やした例です。これは〓19〓のように補われます。

〓18〓<b>を4つに増やした記述例
＜コード＞
<p><b><b><b><b>4つのb開始タグ</p>
<p>bのないp</p>

〓19〓エラー処理による〓18〓の解釈
＜コード＞
<p><b><b><b><b>4つのb開始タグ</b></b></b></b></p>
<b><b><b><p>bのないp</p></b></b></b>

＜本文＞
一見、<b>が1つのときと同じルールで補正されているように見えますが、よく見ると、2行目のp要素の外側に補われている<b>タグと</b>タグの数は3つしかありません。4つあったはずのb要素が1つ減っているのです。
これは、要素をまたがって補われる際、同一要素名・同一クラス名の要素は3つまでしか復元されないというルールがあるからです。
仕様の注釈では、これは「ノアの箱舟（Noah's Ark）」であるとされています。

＜memo＞
ノアの箱舟は、旧約聖書で動物のつがいを1つずつ選ぶ話ですが、ここでは3つずつになります。99%のウェブサイトではフォント装飾要素の入れ子の数が3つ以下である、という調査からこの数が決められました。
https://www.w3.org/Bugs/Public/show_bug.cgi?id=10802

＜小見出し＞
foster parenting
＜本文＞
table要素には"foster parenting"と呼ばれる特殊なエラー処理があります。〓20〓はtable要素のマークアップの例です。

〓20〓table要素のマークアップ例
＜コード＞
<table>
  <tr>
    <th>見出しセル</th>
    <td>データセル</td>
  </tr>
</table>

＜本文＞
table要素直下には、caption、col、colgroup、thead、tbody、tfoot要素といったテーブル関連要素が入れられます。

＜memo＞
table要素直下にはtr要素が出現してもかまいません。この場合はtbody要素が自動的に補われます。th要素やtd要素がtable要素直下に出現した場合は構文エラーとなりますが、エラー処理によってtr要素が補われます。

＜本文＞
table要素の内部にテーブルとは関係のない要素が現れた場合はどうなるでしょうか。〓22〓は、table要素の末尾にp要素を挿入しようとした例です。これは構文エラーとなり、〓23〓のように解釈されます。

〓22〓table要素の末尾にp要素を挿入した例
＜コード＞
<table>
  <tr>
    <th>見出しセル</th>
    <td>データセル</td>
  </tr>
  <p>何かテキスト</p>
</table>

〓23〓エラー処理による〓22〓の解釈
＜コード＞
<p>何かテキスト</p>
<table>
  <tr>
    <th>見出しセル</th>
    <td>データセル</td>
  </tr>
</table>

＜本文＞
〓23〓では、〓22〓で下方にあったp要素が、table要素の前に移動されています。
通常、このような語彙的ルールの違反があってもそのままの形でDOMツリーが構築されるのですが、table要素では不正な子孫要素が前に追い出される形になります。一見奇妙ですが、この処理は仕様に定められている正式な挙動で、foster parentingと呼ばれています。

＜memo＞
foster parentは「里親」というような意味です。

＜本文＞
テキストノードでも同様の処理が行われるため、注意が必要です。〓24〓は、一見すると問題のないマークアップですが、誤って全角スペース（U+3000）でインデントを行っている例です。

〓24〓インデントに全角スペースを使用した例
＜コード＞
<p>以下の表をご覧ください。</p>
<table>
  <tr>
  [　]<td>日本</td>
  </tr>
</table>

＜本文＞
[　]の部分は全角スペースです。全角スペースはASCII空白文字ではないため、table要素の直下に出現できないテキストノードとして扱われます。よって、foster parentingによってtable要素の前に移動されます〓25〓。

〓25〓エラー処理による〓24〓の解釈
＜コード＞
<p>以下の表をご覧ください。</p>
[　]
<table>
  <tr>
    <td>日本</td>
  </tr>
</table>

＜本文＞
結果としてp要素とtable要素の間に全角スペースのテキストノードが挿入され、余白ができることになります。このように、table要素の中に内容モデルに従わないものが存在すると、予想外の挙動になることがあります。
