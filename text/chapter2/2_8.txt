＜タイトル＞
HTMLの細かい構文ルール
＜リード＞
タグの書き方については、主にセキュリティの観点から通常は行わないマークアップの解釈について、検討が必要となることがあります。ここでは、タグの書き方についてもう一歩踏み込んで説明します。

＜中見出し＞
細かい構文ルールを知りたいときは
＜本文＞
HTMLパーサー（HTMLを解釈するプログラム）のルールは仕様で明確に定められています。仕様のParsing HTML documentsのセクションでは、ある状況で特定の文字が出現した場合にどのように解釈するのか、というレベルまで挙動が規定されています。「このような書き方は可能か？」「このように書いた場合にどのように解釈されるのか？」という疑問は、ほとんどの場合、仕様をつぶさに読むことで解決できます。

＜memo＞
Parsing HTML documents
https://html.spec.whatwg.org/multipage/parsing.html

＜中見出し＞
タグ名に使用できる文字
＜本文＞
Chapter2-7でも触れましたが、HTMLのタグ名はASCII英字で始まる必要があり、数字で始まることは許されません。つまり、〓01〓のようなこのようなマークアップはエラーとなり、タグではなくテキストとして解釈されます〓02〓。

＜memo＞
この場合、「invalid-first-character-of-tag-name parse error」となります。

〓01〓タグ名が数字の開始タグを誤って記述した例
＜コード＞
<42>

〓02〓エラー処理による〓01〓の解釈
＜コード＞
&lt;42>

＜本文＞
このタグ名の制限は1文字目だけで、2文字目以降には数字も使えます。具体的な例としてはh1などがあります。構文上、2文字目以降は数字だけでなく、記号類も使用できます。2文字目以降に利用できない文字はほぼ以下に挙げるものに限られます。

・>：タグの終了と解釈されます
・ASCII空白文字：属性値との区切りと解釈されます
・/：自己終了タグもしくは属性値との区切りと解釈されます

興味深いことに、タグの開始のマークである<も利用できる文字となっており、タグ名の一部として解釈されます。
〓03〓のマークアップがあるとします。これは、<h1>タグの>が抜けた形ですが、エラー処理によって〓04〓のように補われます。

〓03〓<h1>タグの>が抜けた記述例
＜コード＞
<body>
  <h1<span>test</span></h1>
</body>

〓04〓〓03〓の解釈
＜コード＞
<body>
  <h1<span>test</h1<span>
</body>

＜本文＞
HTML構文では、h1<spanという名前の要素があるものとみなされます。</h1>と</span>には対応する開始タグがないため無視され、</body>の前に</h1<span>という終了タグが補われます。
タグ名に<を含めることができるのは、SGMLやXMLとは互換性のない挙動です。なお、XML構文の場合にはWell-formedではないため、パースエラーとなります。

＜memo＞
SGMLでは、これは「閉じない開始タグ（unclosed start tag）」とみなされ、HTML構文と異なり<h1><span>と補われていました。

＜word＞
Well-formed（整形式）
XMLの基本的な構文形式が満たされている文書のこと。

＜本文＞
セキュリティの観点からは、/の扱いについて注意が必要です。〓05〓のようなマークアップは、HTMLの仕様としては不正です。
これはエラーとなりますが、<の場合と異なり、/はタグ名の一部とはみなされません。エラー処理の際は、/の後が属性名とみなされます。結果として、〓05〓は〓06〓のようなマークアップと等価になり、onmouseover属性が有効に機能することになります。タグ内部に空白を挿入できなくても、属性を挿入できる点に注意が必要です。

＜memo＞
この場合、unexpected-solidus-in-tag parse errorとなります。

〓05〓タグ内部に誤った/を含む記述例
＜コード＞
<span/onmouseover="alert(1);">test</span>

〓06〓エラー処理による〓05〓の解釈
＜コード＞
<span onmouseover="alert(1);">test</span>

＜中見出し＞
終了タグに属性は書けない
＜本文＞
終了タグに属性を書くことはできません。終了タグに属性を書いた場合〓07〓、エラーとなり、属性は無視されます。なお、終了タグ自体は有効に機能します。

〓07〓終了タグに誤って属性を記述した例
＜コード＞
<p>foo</p class="foo">

＜memo＞
この場合、end-tag-with-attributes parse errorとなります。

＜中見出し＞
終了タグ末尾の/
＜本文＞
終了タグの末尾に/を書くことはできません。〓08〓の場合はエラーとなり、単に/が無視されます。なお、終了タグ自体は有効に機能します。

〓08〓終了タグ末尾に/を記述した例
＜コード＞
<p>foo</p/>

＜memo＞
この場合、end-tag-with-trailing-solidus parse errorとなります。

＜中見出し＞
空タグ
＜本文＞
SGMLでは「空タグ（empty tag）」と呼ばれる記述が許されており、（対応しているブラウザーが存在するかどうかはともかく）理論上はHTML4でも使用可能でした。文字通り空のタグ、タグ名部分を省略したタグで、空の開始タグ、空の終了タグがあります。たとえば〓09〓のようなものです。

〓09〓空タグの記述例
＜コード＞
<p>テキスト</>
<>テキスト</>

＜本文＞
空タグは、直近に開いた要素の名前を参照します。上記の例では、<>と</>は、それぞれ<p>と</p>の省略とみなされます。
しかし、このような空タグは現在のHTML構文では使用できません。空の開始タグはエラーとなり、<>という文字列のテキストノードになります。空の終了タグもエラーですが、こちらは終了タグが丸ごと無視されます。上記の例の場合、p要素が2つできることはなく、テキスト <>テキストというテキストノードを持った1つのp要素になります。

＜中見出し＞
開始タグを省略すると属性は書けない
＜本文＞
開始タグは省略できる場合があります。ただし、開始タグを省略した際に属性のみを書く方法は存在しません。つまり、属性を指定したければ必ず開始タグを書かなければなりません。
たとえば、html要素の開始タグは省略可能ですが、lang属性を指定したい場合は開始タグを書く必要があります〓10〓。

〓10〓属性値を指定した開始タグの記述例
＜コード＞
<html lang="ja">

＜中見出し＞
重複する属性
＜本文＞
Chapter2-2でも触れましたが、同一の属性は複数指定できません。
〓11〓はエラーとなり、後の方の属性が無視されて〓12〓のように解釈されます。

〓11〓同一属性を複数記述したエラーとなる例
＜コード＞
<body class="type1" class="type2">

〓12〓エラー処理による〓11〓の解釈
＜コード＞
<body class="type1">

＜memo＞
この場合、duplicate-attribute parse errorとなります。

＜本文＞
属性の種類によっては、1つの属性に複数の値を指定できる場合があります。class属性の場合、〓13〓のようにASCII空白文字で区切って複数の値を指定できます。

〓13〓class属性で複数の値を指定した例
＜コード＞
<body class="type1 type2 type3">

＜中見出し＞
属性値の省略
＜本文＞
Chapter2-3のブール型属性で触れましたが、空の属性値の記述は省略できます。属性のパース時、属性値の初期値は空文字列（""）になっています。属性名だけを指定し、属性値の記述を省略した場合、属性値が空文字列のまま属性のパースが終わるため、空文字列の属性値が指定されたものとして扱われます。そのため、〓14〓の3つのimg要素の書き方は同じ意味になります。

〓14〓属性値の省略例
＜コード＞
<img alt>
<img alt="">
<img alt=''>

<img alt="">と書いた場合、ブラウザーの開発者ツールで調査してDOMツリーを見ると<img alt>と表示される場合があります。これは、もっとも短い書き方で正規化されているためです。
なお、img要素のalt属性の場合は特に、alt属性を丸ごと省略した場合とは意味が異なることに注意してください。

＜memo＞
img要素についてはChapter3-7で詳しく説明します。

＜中見出し＞
引用符のない属性
＜本文＞
属性を書く場合には属性値を引用符で括るのが基本ですが、引用符を省略できる場合もあります。引用符を省略した場合、以下のようになります。

・タブ、改行、スペース、>が出現すると属性値の終了とみなされる
・"、'、<、=、`が出現するとエラーとなるが、該当の文字は属性値の一部とみなされて処理される

属性値を引用符で括った場合、対応する引用符（"もしくは'）で終了するのに対し、括らない場合はさまざまな文字で属性値が終了します。これはクロスサイトスクリプティング（XSS）脆弱性の原因となりやすいため、セキュリティ上の観点からは、属性値を引用符で括ることが強く推奨されています。

＜memo＞
この場合、unexpected-character-in-unquoted-attribute-value parse errorとなります。

＜word＞
クロスサイトスクリプティング（XSS）
脆弱性のあるウェブサイトに悪意のあるスクリプトを仕掛け、個人情報などを搾取する攻撃のこと。

＜小見出し＞
plaintext
＜本文＞
HTML4まではplaintext要素が定義されていましたが、HTML Standardでは廃止されています。
要素としては廃止されているのですが、パーサーのルールには<plaintext>というマークアップの処理が定義されています。plaintextというタグ名の開始タグに遭遇すると、以降をすべてプレーンテキストとして処理し、タグも文字参照も解釈しなくなります。</plaintext>という文字列があってもそのまま表示します。

＜memo＞
HTML Standardではobsolete feature（廃止された機能）として記載されています。

＜本文＞
これはもともと、HTTP/0.9でContent-Typeフィールドが存在しなかった時代に、データの先頭に<plaintext>と書くことで、プレーンテキストであることを明示するものでした。現在では、Content-Type: text/plainを指定してプレーンテキストであることを示せるため、plaintext要素を使う必要はありません。
とはいえ互換性のために動作はするので、もし何らかの理由でContent-Typeを適切に設定できない場合などに、この存在を思い出すと便利かもしれません。
今日では<plaintext>を使用することはほとんどありませんが、これを書くとContent-Typeヘッダーの誤判定によるXSSを回避できるケースもあるので、セキュリティの視点では意味があるといえるでしょう。

＜中見出し＞
終了タグを書き漏らした際のエラー
＜本文＞
終了タグを書き漏らした場合、特殊な方法で補われるケースがあります。まず、問題のない〓15〓のようなマークアップがあったとしましょう。

〓15〓問題のないマークアップ
＜コード＞
<p><b>b要素</b></p>
<p>bのないp</p>

＜本文＞
一方で、〓16〓のように終了タグ</b>を書き忘れたとしましょう。
b要素の終了タグは省略できないため、これはエラーになります。エラー処理の結果、これは〓17〓のように解釈されます。
終了タグが補われただけでなく、次のp要素の外側がb要素とみなされます。エラー修正のされ方は要素によっても異なり、かなり複雑です。後述のように、直感に反する挙動となることもあるため、エラーが起こらないようにマークアップすることをお勧めします。

〓16〓</b>を書き忘れた記述例
＜コード＞
<p><b>b開始タグ</p>
<p>bのないp</p>

〓17〓エラー処理による〓16〓の解釈
＜コード＞
<p><b>b開始タグ</b></p>
<b><p>bのないp</p></b>

＜中見出し＞
直感に反するエラー処理
＜本文＞
HTML Standardのエラー処理には、直感に反する独特なルールがいくつかあります。

＜小見出し＞
ノアの箱舟ルール
＜本文＞
〓16〓に<b>の終了タグを書き忘れた例を紹介しました。
〓18〓は、<b>を4つに増やした例です。これは〓19〓のように補われます。

〓18〓<b>を4つに増やした記述例
＜コード＞
<p><b><b><b><b>4つのb開始タグ</p>
<p>bのないp</p>

〓19〓エラー処理による〓18〓の解釈
＜コード＞
<p><b><b><b><b>4つのb開始タグ</b></b></b></b></p>
<b><b><b><p>bのないp</p></b></b></b>

＜本文＞
一見、<b>が1つのときと同じルールで補正されているように見えますが、よく見ると、2行目のp要素の外側に補われている<b>タグと</b>タグの数は3つしかありません。4つあったはずのb要素が1つ減っているのです。
これは、要素をまたがって補われる際、同一要素名・同一クラス名の要素は3つまでしか復元されないというルールがあるからです。
仕様の注釈では、これは「ノアの箱舟（Noah's Ark）」であるとされています。

＜memo＞
ノアの箱舟は、旧約聖書で動物のつがいを1つずつ選ぶ話ですが、ここでは3つずつになります。要素の数が爆発的に増殖するのを抑えるために導入されたとされます。

＜小見出し＞
foster parenting
＜本文＞
table要素には"foster parenting"と呼ばれる特殊なエラー処理があります。〓20〓はtable要素のマークアップの例です。

〓20〓table要素のマークアップ例
＜コード＞
<table>
  <tr>
    <th>見出しセル</th>
    <td>データセル</td>
  </tr>
</table>

＜本文＞
table要素直下には、caption、col、colgroup、thead、tbody、tfoot要素といったテーブル関連要素が入れられます。また、tbody要素は開始タグも終了タグも共に省略可能なため、tr要素が直下に出現してもかまいません（この場合はtbody要素が自動的に補われます）。
tr要素もなく、thやtd要素が直下に出現した場合〓21〓はパースエラーとなります。

〓21〓table要素直下にthやtd要素が出現した例
＜コード＞
<table>
  <th>見出しセル</th>
  <td>データセル</td>
</table>

＜本文＞
ただし、エラー処理の結果としてtr要素が補われます。結果として、〓20〓のマークアップと同じように解釈されます。tbody要素が補われるケースと異なり、エラーであることに注意してください。
さて、table要素の内部にtable要素とは関係のない要素が現れた場合はどうなるでしょうか。〓22〓は、table要素の末尾にp要素を挿入しようとした例です。これはエラーとなり、〓23〓のように解釈されます。

〓22〓table要素の末尾にp要素を挿入した例
＜コード＞
<table>
  <tr>
    <th>見出しセル</th>
    <td>データセル</td>
  </tr>
  <p>何かテキスト</p>
</table>

〓23〓エラー処理による〓22〓の解釈
＜コード＞
<p>何かテキスト</p>
<table>
  <tr>
    <th>見出しセル</th>
    <td>データセル</td>
  </tr>
</table>

＜本文＞
〓23〓では、〓22〓で下方にあったp要素が、table要素の前に移動されています。
一見奇妙ですが、この処理をfoster parentingいいます。table要素と関係のない要素はtable要素内のどこにあっても、table要素の前に追い出されるような形となります。

＜memo＞
foster parentは「里親」というような意味です。table要素の子だった要素を、外側の要素が引き取って子にするように見えるのでこう呼ぶのでしょう。

＜本文＞
テキストノードでも同様の処理が行われるため、注意が必要です。〓24〓は、一見すると問題のないマークアップですが、誤って全角スペース（U+3000）でインデントを行っている例です。

〓24〓インデントに全角スペースを使用した例
＜コード＞
<p>以下の表をご覧ください。</p>
<table>
  <tr>
  [　]<td>日本</td>
  </tr>
</table>

＜本文＞
[　]の部分は全角スペースです。全角スペースはASCII空白文字ではないため、table要素の直下に出現できないテキストノードとして扱われます。よって、HTMLがパースされるときにfoster parentingによってtable要素の前に移動されます〓25〓。

〓25〓エラー処理による〓24〓の解釈
＜コード＞
<p>以下の表をご覧ください。</p>
[　]
<table>
  <tr>
    <td>日本</td>
  </tr>
</table>

＜本文＞
結果としてp要素とtable要素の間に全角スペースのテキストノードが挿入され、余白ができることになります。このように、table要素の中に内容モデルに従わないものが存在すると、予想外の挙動になることがあります。
その一方で、このエラー処理により結果として見た目がコンテンツ制作者の意図したとおりになっていることがあるかもしれません。たとえ見た目が意図どおりであっても、内容モデルに対する違反であるため、特に注意が必要です。