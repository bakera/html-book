# WAI-ARIAの実践と活用
<!-- class="hidden" のかわりに aria-hiden="true" を使ったらどうかという話。4ページも書くことがあるのかは謎。-->

4-2節ではWAI-ARIAと関連仕様についてとりあげました。この節では、実際によく使われる部品を取り上げ、アクセシビリティを向上する方法や、その際の検討事項について解説します。より詳しい具体的な実践例については、WAI-ARIA Authoring Practices[^1]を参照すると良いでしょう。

[^1]: <https://www.w3.org/TR/wai-aria-practices/>

## ハンバーガーメニュー

ボタンを押すとメニューが開く、というのはよくあるウィジェットです。特にモバイル用のページでは、メニューボタンに三本の横棒のアイコンがよく利用され、その形状から「ハンバーガーメニュー」と呼ばれます。一般的なハンバーガーメニューは、以下のような機能を持ちます。

- ユーザーがボタンを押すと、メニューが出現する
- メニューにはサイト内の主要なコンテンツへのリンクが含まれる
- メニューはコンテンツに覆いかぶさるような形で現れ、メニューが開いている間はメニューの外のコンテンツは利用できない
- メニューが出現した際、ハンバーガーボタン自体はメニューを閉じるボタンに変化する
- 閉じるボタンを押すとメニューは消え、元の状態に戻る

<!-- サイトから借りてきたが、実際にはポンチ絵の想定 -->
![ハンバーガーメニューの例。左側は初期状態、右側はボタンを押してメニューが開いている状態。](../img/4-4-01.png)

ウェブ制作者にとってはおなじみのパーツですが、アクセシビリティ上の留意点がいくつかあります。深く考えずに作られたハンバーガーメニューは、たとえば以下のようなマークアップになっていることがあります。

```html
<div class="hamburgerMenu">
  <div class="button">
    <span class="menu-icon"></span>
    <span class="close-icon"></span>
  </div>
  <ul>
      <li><a href="/">ホーム</a></li>
      <!-- メニュー -->
  </ul>
</div>
```

`<div class="button">`がボタンに相当します。中に入っている2つの`span`要素は、それぞれハンバーガーアイコンと閉じるアイコンに相当し、CSSの`background-image`を使ってアイコン画像を表示します。そして、`div`に`click`イベントをつけて動くようにします。

```JavaScript
const hamburgerMenu = document.querySelector('.hamburgerMenu');
const hamburgerMenuButton = hamburgerMenu.querySelector('.button');
hamburgerMenuButton.addEventListener('click', event => {
    hamburgerMenu.classList.toggle('js-opened');
});
```

JavaScriptの実装方法はいろいろ考えられますが、ここでは単純に、外側の`div`要素に`js-opend`クラスをつけたり外したりするようにしました。あとは、CSSで`ul`を非表示にし、`js-opened`クラスがついたときだけ`ul`が表示されるようにすれば、ひとまずは完成です。

これでメニューボタンはいちおう動作しますが、このメニューには致命的な問題点があります。

### キーボード操作を可能にする

このメニューの最大の問題は、キーボード操作ができないということです。メニューボタンは`div`要素で実装されています。`click`イベントをつけたのでマウスクリックには反応しますが、キーボードではそもそもフォーカスを当てることができず、このボタンを押すことができないのです。

キーボード操作は、WCAG 2.1の達成基準2.1.1 Keyboard [^2] でも要求されている重要事項です。まずはこれを行えるようにする必要があります。

[^2]: <https://www.w3.org/TR/WCAG21/#keyboard>

#### `div`をキーボード操作できるように……

この`div`にフォーカスが当たるようにするために、`tabindex=0`を指定します。そして`role=button`を指定すると、スクリーンリーダーでも「ボタン」と読まれるようになります。

<!-- 望ましくない例 -->
```html
<div class="button" role="button" tabindex="0">
  <span class="menu-icon"></span>
  <span class="close-icon"></span>
</div>
```

さらに、キーボード操作に対応するためには`keypress`イベントをつける必要もあります。

<!-- 望ましくない例 -->
```JavaScript
hamburgerMenuButton.addEventListener('keypress', event => {
  // Enterキーやスペースキーでボタンが押せ、かつTabキーではボタンが押されないような実装...
});
```

このイベント内では、押されたキーを判定して、Enterキーやスペースキーならばボタンが押されるように、かつTabキーなどの操作を横取りしないように実装します。

この方法は全くお勧めできません。複雑で労力がかかる上、考慮すべきことも多数あります。他の方法を考えるべきです。

#### `button`要素を使用する

WAI-ARIAを使う上で最も重要なことは、WAI-ARIAを使わないことです。HTMLにはボタンの機能を提供する`button`要素があるのですから、ここでは`button`要素を使うべきです。

```html
<button>
  <span class="menu-icon"></span>
  <span class="close-icon"></span>
</button>
```

これだけでキーボード操作が可能になります。`role`属性も`tabindek`属性も`keypress`イベントも必要ありません。`button`要素はそれらの機能を既に備えているからです。

これでキーボード操作はできるようになりましたが、まだ問題は残っています。

### 何のボタンかわかるようにする

ボタンを`button`要素にしたことで、ボタンにフォーカスが当たるようになりました。スクリーンリーダーを使ってボタンにフォーカスを当てると「ボタン」と読まれますが、いったい何のボタンなのかは分かりません。視覚環境ではボタンにハンバーガーのアイコンが付けられていることがわかりますが、スクリーンリーダーでは何のボタンなのかわからないのです。

これは、ボタンにラベルとなるテキストが含まれていないことが原因です。ラベルを与えて、「メニュー ボタン」と読まれるようにしてみましょう。ボタンにラベルを与える方法はいくつかあります。

#### 画像を`img`要素にして`alt`でテキストを指定する

ひとつは、`button`要素の中にラベルとなるテキストを追加する方法です。最もシンプルな方法は、CSSの背景画像を使うのをやめてしまい、`img`要素で画像を指定して`alt`属性にテキストを入れる方法です。

```html
<button>
  <span class="menu-icon"><img src="menu.png" alt="メニュー"></span>
  <span class="close-icon"></span>
</button>
```

この方法は「CSSスプライト」と呼ばれる技法と相性が悪いという問題はあります。最近はCSSスプライトが使われることも少なくなってきましたが、とはいえCSSの背景画像を使うという実装を避けられないということもあるでしょう。その場合には他の方法を考えることもできます。

#### スクリーンリーダー用テキストを入れる

スクリーンリーダーで読ませる専用のテキストを入れる方法もあります。

```html
<button>
  <span class="visually-hidden">メニュー</span>
  <span class="menu-icon"></span>
  <span class="close-icon"></span>
</button>
```

`visually-hidden`は、視覚環境で表示されず、かつスクリーンリーダーでは読まれるようなスタイルを定義したクラスです。CSSフレームワークは、このようなクラスをあらかじめ用意していることがあります (クラス名は異なる場合があり、他に`sr-only`などが使われることもあります)。たとえば、Bootstrap 5.0のvisually-hidden[^4]には、以下のようなスタイルが定義されています。

[^4]: <https://github.com/twbs/bootstrap/blob/main/scss/mixins/_visually-hidden.scss>

```css
.visually-hidden {
  position: absolute !important;
  width: 1px !important;
  height: 1px !important;
  padding: 0 !important;
  margin: -1px !important;
  overflow: hidden !important;
  clip: rect(0, 0, 0, 0) !important;
  white-space: nowrap !important;
  border: 0 !important;
}
```

こうしておくと、テキストはスクリーンリーダーで読まれ、かつ視覚環境には影響を与えません。

#### `aria-label`を利用する

別の選択肢として、我らが`aria-label`属性も利用できます。

```html
<button aria-label="メニュー">
  <span class="menu-icon"></span>
  <span class="close-icon"></span>
</button>
```

このようにすると、`aria-label`に対応しているスクリーンのリーダーでは「メニュー ボタン」と読まれることが期待できます。

他にも、`aria-labelledby`属性や`label`要素を利用する方法も考えられますが、これらは不可視のラベルを与えるのには向きません。どこかに見えているラベルがある場合は、これらの方法を検討すると良いでしょう。なお、ボタンの外にあるテキストを`label`要素として結び付けた場合、ラベルテキストをクリックしてもボタンが反応するようになるので注意してください。

#### `aria-haspopup`を利用する

ボタンのラベルとはまた別の軸として、`aria-haspopup`属性を指定する方法もあります。

```html
<button aria-haspopup="menu">
```

このようにすると、`aria-haspopup`に対応したスクリーンリーダーでは「ボタン メニュー ポップアップ」などと読まれます。これにより、たとえラベルがなくても、メニューがポップアップするボタンであることは伝わるようになります。

ボタンにラベルがある場合は、それもあわせて読まれます。たとえば「メニュー」というラベルがある場合、「メニュー ボタン メニュー ポップアップ」と読まれることになります。これはやや冗長になりますので、ボタンのラベルだけで動作が十分に伝わる場合は、`aria-haspopup`をあえて指定しないという考え方もあります。

メニューを開いた際に、このボタンがメニューを閉じるボタンに変化するのであれば、その際には`aria-haspopup`属性を削除するようにしましょう。メニューを閉じるボタンが「メニュー ポップアップ」と読まれると混乱を招いてしまいます。

### メニューの開閉状態が分かるようにする

ここまでで、キーボード操作ができ、ボタンも「メニュー ボタン」と読まれるようになったので、メニューボタンを利用できる最低限の条件は満たすことができました。ただし、まだ軽微な問題は残っています。

ひとつは、メニューが開いたことが分からない点です。「メニュー ボタン」と読まれるボタンを押したとき、視覚環境ではメニューが開いたことが分かりますが、スクリーンリーダーではそのことが伝わりません。

今回の例では、ボタンに「メニュー」というラベルをつけましたから、おそらくメニューが開くだろうと想像することはできるかもしれません。しかし、実際にどういう変化が起きたかはわからないのです。ボタンをもう一度読ませても「メニュー ボタン」と読まれるだけですし、何度押しても状況は変わりません。

ここには問題が2つあります。

- どこが変化したかわからない (どこにメニューが開いたのか、どうやってそこにたどり着けるのかがわからない)
- 現在の状態がわからない (今メニューが開いているのか、閉じているのかがわからない)

これを改善する方法を考えていきましょう。

#### 開いたメニューにフォーカスを移す

メニューを開いたことが最大限にダイレクトに伝わる方法は、開いたメニューにフォーカスを移してしまうことです。こうすると、ボタンを押した直後にメニューのリンクの内容を読み始めますから、メニューが開いたことは間違いなく伝わるでしょう。

メニューにはフォーカスを受け取ることのできる`a`要素が含まれていますから、先頭の`a`要素にフォーカスを移動します。先のスクリプトにあったボタンクリック時のイベントに、フォーカス移動の処理を追加します。

```JavaScript
hamburgerMenuButton.addEventListener('click', event => {
    hamburgerMenu.classList.toggle('js-opened');
    hamburgerMenu.querySelector('ul a').focus(); // ← これを追加 
});
```

この方法はわかりやすい反面、フォーカスを強制的に移動させてしまう点には注意が必要です。フォーカス移動が予測できなかったり、移動元と移動先が離れていて戻り方がわかりにくいような場合、ユーザーを混乱させることがあります。この例では、「メニュー」というボタンを押すと直後のメニューに移動するという挙動ですから、大きな問題はないでしょう。

#### ボタンのラベルで状態を伝える

ボタンのラベルを変更することで現在の状態を伝えるという方法もあります。たとえば、メニューを開いた際にボタンのラベルも「メニューを閉じる」に変更すれば、現在メニューが開いていること (そして、このボタンを押すとメニューが閉じるということ) が伝わるようになるでしょう。

```html
<button>
  <span class="menu-icon"><img src="menu.png" alt="メニュー"></span>
  <span class="close-icon"><img src="close.png" alt="メニューを閉じる"></span>
</button>
```

ただし、これだけではどこでメニューが開いているのかはわかりません。直後にメニューがある場合は大きな問題はありませんが、メニューと離れている場合には、メニューまで移動する方法も考える必要があるでしょう。

#### `aria-expanded`を利用する

WAI-ARIAには開閉状態を通知するための属性があります。`button`要素に`aria-expanded`属性を指定することで、現在の状態を通知することができます。メニューが開いた状態になったときに`aria-expanded=true`を追加するようにします。

```html
<button aria-expanded="true">
```

こうすると「メニュー ボタン 開いています」などと読まれます (スクリーンリーダーによって読まれ方は異なります。「拡大」などと読むものもあります)。

同様に、`aria-expanded=false`を指定すると「メニュー ボタン 閉じています」などと読まれます (「隠されました」などと読むものもあります)。ただし、この例の場合には、「メニュー ボタン」と読まれるだけで、これからメニューが開くであろうことは十分に予想できかもしれません。

ボタンのラベルだけで挙動が十分に伝わる場合は、あえて`aria-expanded`を指定しない方が簡潔になる場合もあります。たとえば、メニューが開いた時にボタンのラベル自体を変更して「メニューを閉じる」としている場合、「メニューを閉じる ボタン 開いています」と読まれなくても、「メニューを閉じる ボタン」だけで伝わるでしょう。

初期状態では何もつけず、開いた時だけ`aria-expanded=true`をつけるという方法もあります。たとえば、ボタンのラベルが「メニュー」のとき、閉じている時は「メニュー ボタン」と読まれ、開いている時は「メニュー ボタン 開いています」と読まれれば、それでも伝わるでしょう。

ボタンのラベルや他のARIA属性も合わせた状態で実際に読んでみて、ボタンの挙動が伝わるかどうかを考えて用いるとよいでしょう。

#### `aria-controls`を利用する

WAI-ARIAには、制御対象の要素を伝え、そこに移動する手段を提供するための属性があります。`button`要素に`aria-controls`属性を指定し、制御対象となるメニューのIDを指定します。

```html
<div class="hamburgerMenu">
  <button aria-controls="menu01">
    <span class="menu-icon"><img src="menu.png" alt="メニュー"></span>
  </button>
  <ul id="menu01">
      <li><a href="/">ホーム</a></li>
      <!-- メニュー -->
  </ul>
</div>
```

`aria-controls`に対応しているスクリーンリーダーは、制御対象に移動できる機能を提供することがあります。たとえばJAWSの場合、このボタンを「メニュー ボタン」と読んだ後、“use JAWS key+ALT+M to move to controlled element”と読みます。<!--編集注: これは数年前の状況。当時は対応しているのがJAWSのみで、中根さんに当時のJAWS日本語版での読み上げ内容を確認してもらったところ、このように英語で読むということだった。最新版の挙動や他の支援技術の挙動を要確認-->指示に従ってキー操作すると、メニューの`ul`要素に移動し、メニュー内のリンクを読んでいくことができます。ただし、移動した後に元のボタンに戻ってくる方法はありません。

`aria-controls`属性を指定するのは悪いことではありませんが、全てのスクリーンリーダーが問題なく対応できていると考えるべきではありません。開いたメニューに移動する手段と、このボタンに戻ってくる手段について、別途考えておくほうが良いでしょう。対象の要素をこのボタンと隣接させることが最善の対応策ですが、それができない場合、先に紹介したように、ボタンを押した際に対象にフォーカスを移動してしまうというのも一つの方法です。

### メニューの裏側にフォーカスが当たらないようにする

メニューを開いた際、視覚環境ではメニューがコンテンツに覆いかぶさり、コンテンツ側の操作ができなくなるケースが多いでしょう。

しかしキーボード操作の場合、メニューが開いた状態でも背後のコンテンツにフォーカスを移せてしまう場合があります。メニューの裏側の要素にフォーカスが移ると、視覚環境のキーボードユーザーはフォーカスを見失い、混乱することがあります (なお、スクリーンリーダーのユーザーの場合、メニューが開きっぱなしであることに気づかず、普通に利用できてしまうことが多いでしょう)。

これを避ける方法はいくつかあります。

#### メニューの外の要素を全てフォーカス不可能にする

メニューが開いた際、メニューの外の要素を全てフォーカス不可能にするという方法です。実装方法はまたいくつかに別れます。

- メニューの外側のフォーカス可能な要素全てに`tabindex=-1`を指定する
- メニューの外側の要素全てを`display: none;`や`visibility: hidden`などで削除する
- メニューを`dialog`要素として実装し、`showModal()`メソッドで呼び出す

詳細な実装方法はここでは説明しません。`dialog`要素については`dialog`要素の項を参照してください。

なお、`aria-hidden`は利用できないことに注意してください。`aria-hidden`を指定してもフォーカス移動には影響しません。スクリーンリーダーのユーザーは読まれない要素にフォーカスを奪われて混乱することになります。

#### メニューの最後の要素からフォーカス移動するとき、メニューの先頭に戻す

メニューからフォーカスが外に出るのは、メニューの最後の要素からさらにフォーカス移動しようとした時です。そのタイミングで`Tab`キーの挙動をフックして、メニューの先頭に戻してしまえば、フォーカスはメニューの外に出られなくなます。メニューの最後の要素に`keypress`イベントをつけて、`Tab`キーが押された時にメニューの先頭の要素にフォーカスが戻るようにします。

フォーカスが永遠に脱出不能にならないように気をつけてください。メニューを閉じるボタンが押せなくなると詰んでしまいます。また、ユーザーはブラウザのアドレスバーにフォーカスしたい場合に`Shift`+`Tab`を連打して戻ろうとすることもあります。先頭の要素から前に戻ろうとすることは許容する方が良いでしょう。

また、スクリーンリーダーのユーザーは外に出られる場合があることに注意してください。スクリーンリーダーではフォーカスを移動せずに後ろの要素を読むことができますし、`Tab`キーを使用しないフォーカス移動方法もあるため、外に出られてしまいます。もっとも、スクリーンリーダーのユーザーは視覚的にフォーカスを見失っても困ることはないので、特に気にしないという考え方もあります。

#### メニュー末尾からフォーカス移動しようとした場合、メニューを自動的に閉じる

上記と似ていますが、フォーカスをメニューの先頭に戻すのではなく、メニューを閉じることで解決します。メニューの最後の要素に`keypress`イベントをつけ、`Tab`キーが押された時にメニューを閉じるようにします。

メニューを閉じた際には、フォーカスを移動させる必要もあります。メニュー項目にフォーカスしたままメニューが閉じると、フォーカスが行方不明になってしまうため、見えているどこかにフォーカスを移動させる必要があります。

ユーザーにとって予想外の場所にフォーカスが移動すると、フォーカスを見失って混乱することがあるので注意してください。WCAG 2.1の達成基準2.4.3 Focus Order[^3]でも、脈絡のないフォーカス移動は避けるように求められています。

[^3]: <https://www.w3.org/TR/WCAG21/#focus-order>

メニューを閉じた際は、メニューを開く直前にフォーカスがあった場所、すなわちメニューボタンにフォーカスを戻すと良いでしょう。ユーザーが意図せずにメニューを閉じてしまった場合でも、開くボタンにフォーカスがあれば、またすぐに開くことができます。


## カルーセル

「カルーセル」（Carousel）とは、回転木馬、メリーゴーランドの意味です。Webでは、画像やカードなどが横に並び、左右にスライドして順繰りに表示されるようなコンポーネントを指します。スライドショーと呼ばれたり、イメージローテーターと呼ばれることもあります。

```
--+ +---+ +--
1 | | 2 | | 3
--+ +---+ +--

```
図4-4-02 左右のスライドが見切れているカルーセルの例

カルーセルにはさまざまなパターンが見られますが、一般的には以下のような機能を持ちます。

- 複数の「スライド」(slide)を持ち、順番に表示することができる。スライドには画像やカードなど、視覚的に提示される項目が含まれる。
- 1度に表示するスライドは1つだけ (ただし、左右に見切れた状態で前後のスライドが表示されることはある)
- ユーザーの操作により、次のスライド、前のスライドを表示させることができる。多くの場合、カルーセル領域の左右に矢印状のボタンが表示される
- 表示されているスライドをクリックすると、そのスライドに対応するリンク先に遷移する。スライドによってリンク先は異なる

また、これらに加えて以下の機能を持つケースも多く見られます。

- 「スライドピッカーコントロール」(Slide Picker Controls)を持つ。これはスライドが全部で何枚あり、現在表示中のものが何番目かを示すインジケータであり、インジケータ部分をクリックすると、対応するスライドを直接表示させることもできる。多くの場合、カルーセル領域の上部か下部に、円が横に並んだ形で表示される
- ユーザーが操作しなくても、ページが読み込まれると自動的にカルーセルの回転が始まる
- スライドにマウスポインタが乗った場合や、キーボードフォーカスが移った場合にも、カルーセルの自動回転を停止する
- 「ローテーションコントロール」(Rotation Control)を持つ。これは、カルーセルの自動回転を停止/再開できる機能で、多くの場合、オーディオ機器の一時停止/再生ボタンを模したボタンで表現される

こうしてみると、カルーセルの仕組みは非常に複雑で、多数の機能を持つことがわかります。これら全てを自前で実装するのはかなり大変ですから、専用のライブラリを利用するケースが多いでしょう。ここでは、ライブラリを選定する際の観点として、アクセシビリティ上の注意点をいくつか述べることにします。

もしすべてを自前で実装する必要がある場合は、WAI-ARIA Authoring Practicesの3.6 Carousel (Slide Show or Image Rotator)[^4]を参考にすると良いでしょう。

[^4]: <https://w3c.github.io/aria-practices/#carousel>

### キーボード操作が可能か

カルーセルもキーボードで操作できなければなりません。ライブラリ選定時には、動作サンプルをキーボードで実際に操作してみると良いでしょう。特に問題になりやすいのは以下の点です。

- 現在表示されているスライドにフォーカスし、リンクを辿ることができるか
- 隠れているスライドにフォーカスがあたってしまい、フォーカスが行方不明になることはないか
- 次のスライド/前のスライドボタンにフォーカスし、操作できるか
- スライドピッカーコントロールにフォーカスし、操作できるか
- ローテーションコントロールにフォーカスし、操作できるか

キーボードフォーカスが見えなくなっていて事実上操作できないケースもよく見かけますので、あわせて注意しましょう。

また、現在表示されているスライドにフォーカスが移った際、カルーセルが自動回転するとフォーカスが行方不明になることがあります。これを防ぐため、多くのカルーセル実装では、スライドにフォーカスした際に自動回転を止めるようにしています。同様に、マウスポインタがスライドに乗った際にも自動回転を止めることが一般的です。これは、スライドをクリックしようとした瞬間にスライドが切り替わると、意図しない遷移先に移動して混乱するためです。

### スクリーンリーダーで操作できるか

視覚環境だけでなく、スクリーンリーダーで問題なく操作できるかどうかを確認しましょう。

- 現在表示されているスライドが適切に読まれるか
- 各種のボタンにラベルが付けられているか
- 隠れているスライドが読まれて混乱することはないか

実装方法によっては、隠れているスライドがスクリーンリーダーで読まれることがあります。それが問題ないケースもあるかもしれませんが、混乱を招くこともあるので注意しましょう。自前で実装する場合は、隠れているスライドに`aria-hidden`を適用するのも一つの方法です。ただし、`aria-hidden`だけではキーボードフォーカスは当たってしまうことに注意が必要です。

### 他の箇所の読み上げを妨害しないか

カルーセルとスクリーンリーダーの読み上げに関しては、一つ重要な事項があります。それは、他の箇所を読んでいる際に自動回転が起きた時、読み上げを邪魔することがないかという点です。

カルーセルのライブラリの中には、カルーセル領域をライブリージョンとして実装しているものがあります。たとえば、Slick[^6]というライブラリの古いバージョンでは、以下のようにカルーセル領域に`aria-live="polite"`を指定していました。

[^6]: <https://kenwheeler.github.io/slick/>

```html
<div aria-live="polite" class="slick-list draggable">
```

カルーセル内のスライドが切り替わると、切り替わった内容が読み上げられることになります。カルーセルを手動で操作した場合に読まれるのは問題ありませんが、ユーザーが他の場所を読んでいるときにカルーセルが自動回転すると、読み上げが一段落したところでカルーセルの内容が読み上げられることになります。

ライブリージョンが読まれる際、多くのスクリーンリーダーでは、単に内容がそのまま読まれます。現在の場所と異なる場所が読まれたということはわかりませんので、たとえば、見出しを読んでいる際にカルーセルが切り替わると、見出しのテキストに続けてそのままカルーセルの内容が読まれ、一続きの内容であるように聞こえます。文脈と関係のない読み上げが挟まってくるため、これはユーザーを大いに混乱させることになります。

自前で実装する場合、カルーセルにライブリージョンを使う必要があるかどうかは慎重に検討してください。どうしても利用する必要がある場合は、ユーザーがカルーセル領域から離れた際に`aria-live=off`に切り替えるか、カルーセルの自動回転を止めるようにすると良いでしょう。

### ローテーションコントロールがあるか

ローテーションコントロールは、自動回転するカルーセルを停止する機能です。自動でスライドが切り替わり続けるカルーセルは多く見られますが、その一方で、スライドを停止す機能が提供されないことがあります。

WCAG 2.1の達成基準2.2.2 Pause, Stop, Hide[^4]は、動き続けるコンテンツが停止できることを求めています。これはレベルAの要求で、「非干渉」の条件にもなっている重要な基準ですので、WCAGへの対応が求められる場合には必ず満たさなければなりません。

[^4]: <https://www.w3.org/TR/WCAG21/#pause-stop-hide>


## タブ

「タブ」(Tabs)は、複数のコンテンツを切り替えて表示する機能です。典型的には、パーツ一式の上部に「タブリスト」(Tab List)があり、下部にコンテンツが入る「タブパネル」(Tab Panel)があります。タブリストの中には「タブ」(Tab)が並び、いずれかのタブを選択すると、タブパネルが対応するものに切り替わります。

![](../img/4-4-03.png)

図4-4-03 タブの例 (WAI-ARIA Authoring Practiceより)

タブは以下のような機能を持ちます。

- 複数のタブとタブパネルから構成される。タブとタブパネルは一対一対応している。
- タブリスト内の全てのタブは見えている状態になっており、初期状態ではいずれか一つのタブが選択されている
- タブパネルは、選択されているタブに対応したものだけが表示され、他のタブパネルは見えない
- 他のタブをクリックすると、そのタブが選択状態になり、選択したタブに対応するタブパネルが表示される。他のタブパネルは表示されなくなる。

タブがキーボード操作を受け付ける場合、以下のような操作になるのが一般的です。

- タブリストにフォーカスを移すと、選択されているタブがアクティブになる
- キーボードの左右キーを押すと、左右にある他のタブを選択することができる

キーボードの左右キーによる操作は、他のWebコンポーネントではあまり見られない、独自のものとなっています。これは、OSが提供するタブコントロールの操作に合わせたものです。


### タブのマークアップと実装

HTMLにはタブを表現する要素がありませんが、WAI-ARIAでは、タブの部品に対応するロールが用意されています。

- タブ : tab
- タブリスト : tablist
- タブパネル : tabpanel

各部品にこれらのロールを適用していくのですが、実際にどのようなマークアップにするべきか検討していきましよう。

#### タブ

タブはユーザーの操作の対象となる要素です。タブをクリックしたとき、タブパネルが切り替わるようにする必要があります。また、キーボードフォーカスを受け取る必要もあります。これらの機能を全て自前で実装することも不可能ではありませんが、お勧めしません。フォーカスを受け取れる要素、`a`要素か`button`要素のいずれかを使うべきでしょう。WAI-ARIA Authoring Practiceのタブの例[^6]では`button`要素を使用していますが、`a`要素が使われることもあります。

[^6]: <https://w3c.github.io/aria-practices/#tabpanel>

タブには `aria-controls`属性を指定して、このタブに対応するタブパネルを示すようにします。一部のスクリーンリーダーでは、対応するタブパネルにジャンプできるようになります。

`id`属性を指定しておくと、タブのラベルを`aria-labelledby`で参照できるようになります。後述のタブパネルで利用します。

また、JavaScriptで以下の属性をつけます。これらの値は、タブが切り替わった際に動的に変化する想定です。

- `aria-selected`属性 : このタブが現在選択されているかどうかを示します。選択されているタブには"true"、そうでないタブには"false"を指定します。
- `tabindex`属性 : 選択されていないタブに `tabindex=-1` を指定します。前述のように、キーボード操作ではタブにフォーカスしてから左右キーでタブを切り替える想定となるため、選択されていないタブには直接フォーカスが当たらないようにします。

タブが3つあるとするなら、たとえば以下のようなマークアップになります。`aria-selected`と`tabindex`はjavaScript で動的につけられている想定です。

```html
<button type="button" role="tab" id="tab01" aria-controls="tabpanel01"
 aria-selected="true">タブその1</button>
<button type="button" role="tab" id="tab02" aria-controls="tabpanel02"
 aria-selected="false" tabindex="-1">タブその2</button>
<button type="button" role="tab" id="tab03" aria-controls="tabpanel02"
 aria-selected="false" tabindex="-1">タブその3</button>
```

なお、タブには必ずラベルをつけるようにしてください。上記の例のように、要素の中にラベルテキストが入っていれば問題ありません。タブにテキストを持たせられないような場合は、`aria-label`でラベルを与えることを検討しましょう。タブパネルに見出しが含まれており、その見出しのテキストをそのままタブのラベルにできるならば、その見出しにIDをつけて`aria-labelledby`で参照しても良いでしょう。

#### タブリスト

タブリストは、タブが列挙される部分です。`tablist`ロールを適用しますが、どのHTML要素を採用するかは議論の余地があります。

ARIA in HTMLでは、`menu`、`ol`、`ul`、`nav`要素に`tablist`ロールが適用できることになっています。他にも、全てのロール (Any role) が適用可能とされている要素には`tablist`ロールを適用できますので、`p`や`div`などが候補になります。なお、`dl`要素には`tablist`ロールを指定することができないため、候補にはなりません。

タブリストにはタブが複数列挙されますし、名前に「リスト」とついていますから、`ul`は有力候補です。しかし、WAI-ARIAの`tablist`ロールは`list`ロールと派生関係になく、`listitem`の親にはなれません。`ul`のロールを`tablist`に変更すると、`li`要素の`listitem`ロールが宙に浮くことになります。`li`に`tab`ロールを指定することも可能ではありますが、先に述べたように、`tab`ロールは`button`か`a`に指定したほうが良いでしょう。そうすると、`li`には`role=presentation`を指定することになります (指定しなくても、ブラウザーによって同等の意味の`role=generic`に上書きされ、`listitem`ロールは失われます)。

`ul`を使っても、結局はリストの意味を失わせることになりますので、最初から`div`を使うという考え方も有力です。実際、WAI-ARIA Authoring Practiceのタブの例では`div`要素を使用しています。どちらが正解というわけでもなく、前後の文脈や互換性など、周辺の事情を考えて採用すると良いでしょう。後述の「タブと他の見せ方を切り替える」の項も参照してください。

タブリストには、必要に応じて、`aria-label`を用いてラベルを与えても良いでしょう。文脈によっては、タブリストに含まれるタブが何であるのか、何を切り替えるのかが伝わらない場合もあります。前後の文脈から十分に伝わるようであれば、`aria-label`は指定しなくてもよいでしょう。

```html
<div role="tablist" aria-label="XX機能の切り替え">
  <button type="button" role="tab" id="tab01" aria-controls="tabpanel01"
  aria-selected="true">タブその1</button>
  <button type="button" role="tab" id="tab02" aria-controls="tabpanel02"
  aria-selected="false" tabindex="-1">タブその2</button>
  <button type="button" role="tab" id="tab03" aria-controls="tabpanel02"
  aria-selected="false" tabindex="-1">タブその3</button>
</div>
```

#### タブパネル

タブパネルは実際に表示される内容を含む部分で、`tabpanel`ロールを適用します。

`tabpanel`ロールは、ARIA in HTMLでは`section`要素に適用可能とされています[^7]。そのほか、任意のロールを適用可能な要素が利用できますが、タブパネルの中にさまざまな要素が入る可能性を考えると`p`などは使いにくく、事実上`section`と`div`の二択になるでしょう。タブパネルの中に見出しが入ってセクションとして成立しているなら`section`要素、そうでなければ`div`要素を利用するのがよいでしょう。WAI-ARIA Authoring Practiceのタブの例では`div`要素を使用しています。

[^7]: 当初のARIA in HTMLでは`section`要素に`tabpanel`ロールを指定することは許されていませんでしたが、2016年11月の更新で可能となりました。

抜粋:: ヘイドン・ピカリング  “コーディングWebアクセシビリティ”。 Apple Books  

タブから`aria-controls`で参照するために、タブパネルには`id`属性を指定します。

また、`tabindex=0`を指定して、タブパネルをフォーカス可能にすることも勧められています。これによって、`aria-controls`に対応しない支援技術でも、キーボード操作でタブパネルに簡単に移動できるようになります。

タブパネルをフォーカス可能にする場合、タブパネルにはラベルをつけるべきです。通常は、タブのラベルをそのまま使えるはずですので、タブにIDをつけて`aria-labelledby`で参照すると良いでしょう。タブパネルの中に見出しが含まれる場合は、見出しにIDをつけて参照しても良いでしょう。ラベルにふさわしいテキストがどこにもない場合は、`aria-label`でラベルをつけることも可能です。

表示されていないタブパネルは、JavaScriptで`hidden`属性を指定して非表示にします。CSSの優先度の都合によっては、`hidden`属性では力不足になり、要素を隠しきれないこともあるかもしれません。その場合は、`class`属性にクラス名を与えてCSSで非表示にしても良いでしょう。

通常、`aria-hidden`を利用する必要はありません。非表示のタブパネルは視覚環境からも隠されるべきもので、通常はCSSの`display:none`を適用して、視覚環境とスクリーンリーダーの双方から隠されるようにします。もし、演出状の都合など何らかの理由で`display:none`を適用できず、非表示のタブパネルがスクリーンリーダーで読まれてしまうような場合は、`aria-hidden`の利用を検討しても良いでしょう。

タブパネルはたとえば以下のようなマークアップになります。

```html
<div tabindex="0" role="tabpanel" id="tabpanel01" aria-labelledby="tab01">
<!-- タブパネルの内容 -->
</div>
<div tabindex="0" role="tabpanel" id="tabpanel02" aria-labelledby="tab02" hidden>
<!-- タブパネルの内容 -->
</div>
<div tabindex="0" role="tabpanel" id="tabpanel03" aria-labelledby="tab03" hidden>
<!-- タブパネルの内容 -->
</div>
```

#### スクリプト実装

これでマークアップは完成です。あとは、JavaScriptを実装して動作するようにします。

タブがクリックされた場合だけでなく、タブにフォーカスした際のキーボード操作も忘れずに実装しましょう。`keypress`イベントではカーソルキーの操作を取得できないので、`keydown`イベントと`keyup`イベントを利用することになります。

具体的なコードについてはWAI-ARIA Authoring Practiceを参照してください。

### タブと他の見せ方を切り替える

タブのインターフェイスを導入する大きな目的の一つは、画面スペースの節約です。タブ操作によって表示を切り替える仕組みを導入することで、狭いスペース内で多くの情報を見せることができるようになります。逆に言えば、画面スペースによっては、必ずしもタブインターフェイスが最適解ではないことがあるかもしれません。

最近では、画面サイズに応じて同じコンテンツを別の見せ方にするレスポンシブデザインが普及しています。レスポンシブデザインを採用して、画面が狭い時にはタブで表現し、広い時には全てを展開して見せたい、と思う時があるかもしれません。

タブインターフェイスを構成する要素は、ページ内リンクの目次と相性が良いことが知られています。タブリストは目次のリスト、タブは目次内のリンク、タブパネルはリンク先のセクションに対応します。

```html
<ul>
  <li><a href="#section01">セクション1</a></li>
  <li><a href="#section02">セクション2</a></li>
  <li><a href="#section02">セクション3</a></li>
</ul>
<section>
  <h2 id="section01">セクション1</h1>
  <p>セクション1の内容...</p>
</section>
<section>
  <h2 id="section02">セクション2</h1>
  <p>セクション2の内容...</p>
</section>
<section>
  <h2 id="section03">セクション3</h1>
  <p>セクション2の内容...</p>
</section>
```

このようなページ内リンクをタブに仕立て上げることができます。JavaScriptで`role`属性を付与して以下のようにします。

```html
<ul role="tablist">
  <li role="none"><a role="tab" href="#section01">セクション1</a></li>
  <li role="none"><a role="tab" href="#section02">セクション2</a></li>
  <li role="none"><a role="tab" href="#section02">セクション3</a></li>
</ul>
<section role="tabpanel" aria-labelledby="section01">
  <h2 id="section01">セクション1</h1>
  <p>セクション1の内容...</p>
</section>
<section role="tabpanel" aria-labelledby="section02">
  <h2 id="section02">セクション2</h1>
  <p>セクション2の内容...</p>
</section>
<section role="tabpanel" aria-labelledby="section03">
  <h2 id="section03">セクション3</h1>
  <p>セクション2の内容...</p>
</section>
```

他にも細かい属性やイベントをつける必要がありますが、タブとして成立することは分かるでしょう。このようにすると、状況によってページ内リンクの見せ方とタブの見せ方とを切り替えることが可能になります。また、JavaScriptが動作しない環境でもページ内リンクとして成立するというメリットもあります。

#### タブの操作方法をあえて実装しない選択

上記の例ではページ内リンクをタブの見せ方にした上で、タブ関連のロールと機能を適用してタブとして動作させることを想定しています。タブになると、キーボードででの操作方法は変化します。ページ内リンクだった場合は、`Tab`キーでリンクに次々とフォーカスしていき、希望のリンクを選択するという方法でした。タブになると、現在選択されているタブにフォーカスし、左右キーでタブを選ぶという方法になります。

この操作方法の変更は本当に必要なのでしょうか。見せ方だけ変えて操作は変えず、ロールも変えず、そのままページ内リンクとして操作できれば問題ない、という考え方もありえます。ウェブにはタブ上のコントロールがしばしば登場しますが、その多くは単に省スペースを目的としたもので、ページ内リンクの操作方法でも問題ないことが多いでしょう。タブの操作方法をあえて実装しない、そういう選択肢も現実的です。

ただしこの場合、リンクをクリックした際の挙動には注意してください。ページ内リンクの場合、リンクをクリックすると該当箇所までスクロールし、明確に画面が変化します。それに対し、タブの見せ方にした場合は、リンクを押してもスクロールせず、画面がほとんど変化しない場合が多いでしょう。この場合、画面を拡大している利用者は画面の変化に気づかず、リンクを押しても何も起きなかったという経験をすることがあります。リンクを押した際に対応する見出しにフォーカスを移す、といった方法で対応すると良いでしょう。

## ダイアログ
<!--
https://www.w3.org/TR/wai-aria-practices/#dialog_modal
https://www.w3.org/TR/wai-aria-practices/examples/dialog-modal/dialog.html
https://qiita.com/ishimasar/items/47f29b958946a2c53e93

http://www.tohoho-web.com/bootstrap/modal.html
-->

「ダイアログ」(dialog)は、Webコンテンツの上に覆いかぶさるように出現するウィンドウ領域です。基本的には、ユーザーに対して注意を促したり、何かを入力させるために用います。

ダイアログには、大きく分けて2つのモードがあります。

- 「モーダルダイアログ」(modal dialog): ダイアログが出現するとダイアログに対して操作を行うモードになり、その間、ダイアログ以外の要素を操作できくなるもの
- 「モードレスダイアログ」(modeless dialog): ダイアログが出ても他のコンテンツを引き続き操作できるもの

Webではモードレスダイアログはあまり利用されません。他のコンテンツを引き続き操作できる場合、ダイアログではない見せ方をすることが多いでしょう。

モーダルダイアログの場合、他のコンテンツが操作できないことがわかるように、ダイアログの外を暗くする演出が一般的です。

![](../img/4-4-04.png)

図4-4-04 モーダルダイアログのイメージ図

ダイアログの実装にはいくつかの方法があります。

### `window.confirm`による簡素なダイアログ

簡易なダイアログであれば、JavaScriptの機能だけで簡単に実装することができます。`window.confirm()`を利用すると、ユーザーにOK/キャンセルの2択を問うモーダルダイアログを出すことができます。

以下は、フォームをリセットする際に警告のダイアログを出す例です。

```html
<form onreset="confirm('フォームの内容を全て初期化します。よろしいですか?')">
    <!-- さまざまなフォームコントロール -->
    <button>送信</button>
    <button type="reset">リセット</button>
</form>
```

![](../img/4-4-05.png)

このダイアログはブラウザーの機能で出ています。そのため、ダイアログの見た目を制御することはできません。見た目はブラウザーの実装に依存しますが、ほとんどの場合は非常に素っ気ない見た目になってしまいます。

そのかわり、コンテンツ製作者は細かい機能を自前で実装する必要がなく、上記の例のように非常に簡素な記述だけで実現できます。ユーザーに対して簡潔にYes/Noを問うだけで良いシーンでは、このような簡素な機能で十分な場合もあるでしょう。

### `dialog`要素によるダイアログ

HTMLには、ダイアログを表示するための`dialog`要素が用意されています。`showModal()`メソッドを呼ぶとモーダルダイアログとして呼ぶことができます。

```html
<dialog id="dialog1">
  <form method="dialog">
    <p>OKですか?</p>
    <button type="submit" value="OK">OK</button>
    <button type="submit" value="Cancel">Cancel</button>
  </form>
</dialog>
<script>
  const d = document.getElementById('dialog1');
  const dialogOpen = () =>{
      d.showModal();
      d.onclose = () => {alert (d.returnValue)};
  }
</script>
<button type="button" onclick="dialogOpen()">ダイアログを開く</button>
```

単にこれだけで、モーダルダイアログの外にある要素を暗く表示し、操作できないようにするところまで実現します。

初期状態でダイアログを隠す処理も実現されています。ただし、初期状態でダイアログを隠す処理は、ユーザーエージェント側のスタイルシートで`dialog:not([open])`に`display:none`が与えられているだけです。より強いセレクタで`display`プロパティを上書きすると見えてしまうことがあるので注意してください。

ネイティブの`dialog`要素にはダイアログとしてのセマンティクスもあるため、`role`属性を追加する必要もありません。

これは非常に便利なのですが、残念なことに、ブラウザーによる`dialog`要素のサポートはまだ不十分です。2021年8月現在、iOSとmacOSのSafariがサポートしていない状況です[^9]。

[^9]: <https://developer.mozilla.org/ja/docs/Web/HTML/Element/dialog>

ブラウザーの種類を限定できる業務アプリなどであれば問題なく利用できるかもしれませんが、そうでない場合、Safariでサポートされていない機能を利用することは難しいしいでしょう。

### WAI-ARIAを駆使した実装

`dialog`要素をサポートしないブラウザーを想定すると、他の要素やWAI-ARIAを駆使して自前でダイアログを実装するという選択肢が現実的です。

ダイアログのマークアップは、たとえば以下のようになります。

<!-- https://w3c.github.io/aria-practices/examples/dialog-modal/dialog.html のサンプルのうち、4番目のダイアログを少しシンプルにして、DOM操作で追加される要素を入れたたもの -->
```html
<div id="dialog_layer" class="dialogs">
  <div tabindex="0"></div>
  <div id="dialog4" class="dialog"
    role="dialog"
    aria-labelledby="dialog_label"
    aria-describedby="dialog_desc"
    aria-modal="true">
  <h2 id="dialog_label">ダイアログの見出し</h2>
  <p id="dialog_desc">
  ダイアログのメッセージ...
  </p>
  <!-- その他さまざまな中身が入る -->
  <button type="button"
    id="dialog_close_button"
    aria-label="閉じる">x</button>
  </div>
  <div tabindex="0"></div>
</div>
```

`div`要素に`dialog`ロールを指定して、ダイアログであることを示します。ダイアログが警告やエラーを表示するものであれば、かわりに`alertdialog`ロールを指定します。

`aria-labelledby`属性で見出しを、`aria-describedby`属性でメッセージを提供しています。この例ではダイアログの内部に見える形で見出しと説明文があるため、それらを結びつけています。見える形のテキストラベルがない場合は、`aria-label`を利用しても良いでしょう。

`aria-modal="true"`により、このダイアログがモーダルであることを示しています。`aria-modal`に対応した支援技術の場合、これだけでモーダルの外の要素を操作できないようにしてくれる場合があります。とはいえ、仕様上この処理は必須ではなく、対応しない支援技術もあるため、モーダルダイアログの外の要素が読まれないようにしたり、キーボードフォーカスを制御する処理も必要です。
<!--
When a modal element is displayed, assistive technologies SHOULD navigate to the element unless focus has explicitly been set elsewhere. Assistive technologies MAY limit navigation to the modal element's contents. If focus moves to an element outside the modal element, assistive technologies SHOULD NOT limit navigation to the modal element.
-->

キーボードフォーカスの制御のために、ダイアログの前後に `<div tabindex="0"></div>` を挿入しています。これは、ダイアログを表示した際にJavaScriptによるDOM操作で挿入する想定です。キーボード操作の場合、ダイアログの外にフォーカスを出そうとすると、この`div`にフォーカスが当たることになります。この`div`に`focus`イベントをつけておき、フォーカスをトラップする制御を行います。

モーダルダイアログの内部には、必ず閉じるボタンを置きます。`aria-modal`を指定するとダイアログの外側にはアクセスできなくなることがあるため、ボタンはダイアログの内部に配置しなければなりません。ダイアログを開いたボタンをトグルさせたい場合などには注意してください。また、`Esc`キーが押された際にダイアログが閉じるようにしておくと良いでしょう。

ここではJavaScriptの具体的な実装までは紹介しません。JavaScriptの実装やその他の細部については、WAI-ARIA Authoring Practiceのダイアログの例[^9]を参考にしてください。

[^9]: <https://w3c.github.io/aria-practices/examples/dialog-modal/dialog.html>


## インラインSVGのアクセシビリティを担保する

HTMLに直接インラインでSVGを記述したい、という場面も珍しくないでしょう。その場合、WAI-ARIAを付与する必要が出てきます。

`svg`要素はSVG 2仕様によれば`graphics-document`というロール[^5]を持っていることになります。これは端的に言えば、文書である`document`ロールの性質も持っているという位置付けになります。そのため、通常の画像として扱いたい場合は`img`ロールを付与します。

[^5]: <https://www.w3.org/TR/SVG2/struct.html#implicit-aria-semantics>

意味のある画像については、代替テキストを（SVGの）`title`要素で与えます。

```html
<svg role="img">
  <title>代替テキスト</title>
  ...
</svg>
```

`aria-describedby`で明示的に`svg`要素と`title`要素を結びつける方法がありますが、仕様上[^6]はそのようにする必要はありません。

[^6] <https://www.w3.org/TR/svg-aam-1.0/#mapping_additional>

```html
<!-- 冗長な例 -->
<svg role="img" aria-describedby="svgdesc">
  <title id="svgdesc">代替テキスト</title>
  ...
</svg>
```

画像が意味を持たない純粋に装飾的な画像である場合は、支援技術に無視させればよく、`aria-hidden`属性を用います。この場合、支援技術に何も伝えないため、`role`属性を指定する必要はありません。

```html
<svg aria-hidden="true">
  <!-- 純粋に装飾的な画像 -->
  ...
</svg>
```

#### 画像にありがちなアクセシビリティの問題

画像を`img`要素で表す場合は、代替テキストについては単に`alt`を考えるだけでよいのですが、前述のインラインSVGのように`img`要素でない方法で画像を表す場合、代替テキストを用意することを考える必要があります。

`alt`による代替テキストは、何らかの原因で画像が読み込めなかったときに、ブラウザー上で画像の代わりに表示されるという特性があります。代替テキストを提供する場合は、この特性と同等の挙動を実現する必要があります。

<!-- 4-3に移動すべきか？ -->

例えば、font awesomeのようなフォントアイコンで、`aria-label`属性で代替テキストの代わりにする実装を見かけることがありますが、`aria-label`はラベルであって代替テキストではありません。画面上に見えないラベルであるため、`alt`と同じ挙動にはなりません。

```html
<!-- 好ましくない実装例 -->
<i class="..." aria-label="開く"></i>
```

このような手法は既存サイトの緊急避難的な改修の場合に留め、新規にサイトを構築する際は避けることが望ましいです。