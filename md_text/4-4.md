# WAI-ARIAの実践
<!-- class="hidden" のかわりに aria-hiden="true" を使ったらどうかという話。4ページも書くことがあるのかは謎。-->

Chapter4-2ではWAI-ARIAと関連仕様についてとりあげました。このChapterでは、実際にウェブでよく使われる部品の事例を通じて、WAI-ARIAをどのように利用するのか、その検討の過程や考え方について紹介します。より詳しい具体的なコード例については、WAI-ARIA Authoring Practices[^1]などを参照してください。

[^1]: <https://www.w3.org/TR/wai-aria-practices/>

## 基本テクニック

具体的な事例に入る前に、ARIAを使用する考え方として、基本的なコンセプトについて3つ説明します。HTMLのネイティブ機能と同様な機能の実装が求められる、というものがコンセプトの前提となります。

### ARIAコンセプト1：マウスやタップ操作可能なものは、キーボードでも操作可能にする

コンテンツ制作者は、`div`要素や`span`要素などの要素にJavaScriptを駆使して機能を追加し、独自のウィジェットを作りだすことがあります。このようなケースはまさにWAI-ARIAの活用の場であり、`role`属性などを駆使して、それが操作可能なコントロールであることを伝わるようにできます。

注意しなければならないのは、WAI-ARIAは原則として情報を追加するだけであり、機能を追加しないということです。適切なロールを指定しても、自動的に操作可能になるわけではありません。とくに、コントロールがキーボードで操作できるかどうかという点には細心の注意を払ってください。ユーザーがクリック、タップ、ドラッグ、ドロップ、スライド、スクロールといった各種の操作を行えるとき、キーボードのみの環境でも同等の操作を実現できるようにする必要があります。これは、WCAG 2.1達成基準2.1.1キーボード[^2]の要請であり、アクセシビリティ上の重要事項でもあります。

ちなみに、スマートフォンなどのモバイル環境では典型的にはタップ操作を行うため、キーボード操作を考慮する必要がないのではという反論も考えられます。しかし、Bluetoothキーボードを接続してキーボード操作を行うことも可能です。モバイル環境でもキーボード操作を考慮する必要があります。

[^2]: <https://www.w3.org/TR/WCAG21/#keyboard>

たとえば、以下のように`div`要素に`role=button`を指定すると、この要素はボタンとしてのセマンティクスを持ち、支援技術にはボタンであると伝えられます。ボタンを押した際の動作は`onclick`属性に記述したJavaScriptで実現しています。

```html
<div role="button" onclick="pushedButton()">素敵なボタン</div>
<script>
const pushed = () =>{
  alert('押されました'); // ボタンを押されたときの処理
}
</script>
```

この`div`要素のボタンはマウスでクリックすると動作し、一見すると問題ないように見えるかもしれませんが、以下のような機能がありません。

- キーボードの<kbd>Tab</kbd>キーでフォーカスを当てる
- キーボードの<kbd>Enter</kbd>キー、<kbd>Return</kbd>キー、<kbd>space</kbd>キーでボタンを押す

つまりキーボード操作ができません。このような場合には、キーボード操作に対応する機能を明示的に実装する必要があります（Chapter4-2のARIAルール1に従ってHTMLの`button`要素を用いれば、これらの機能はネイティブの機能として提供されることになります）。

ARIAを併用したキーボード操作の考え方については、WAI-ARIA Authoring PracticesのDeveloping a Keyboard Interfaceが参考になります。[^aria-keyboard]

[^aria-keyboard]: <https://www.w3.org/TR/wai-aria-practices-1.2/#keyboard>

### ARIAコンセプト2：操作可能な要素を隠さない

要素に`aria-hidden="true"`を指定すると、支援技術からその要素を隠すことができます。その要素は、視覚環境では表示され、しかしスクリーンリーダーでは読み上げられなくなります。

フォーカス可能な要素に`aria-hidden="true"`を指定した場合、不都合が起きます。その要素は支援技術には「見えない」のですが、視覚環境では表示されており、フォーカスは当たります。支援技術のユーザーの場合、見えない要素にフォーカスが当たり、フォーカスを見失ってしまいます。

<!-- 望ましくない例 -->
```html
<button aria-hidden="true">支援技術に「見えない」がフォーカスは当たるボタン</button>
```

なお、フォーカスが当たらなければ問題は起きません。視覚環境も含めたすべての環境から要素を隠したり、無効にするなどしてフォーカスが当たらないようにすれば問題を回避できます。以下はこの問題が起きない例です。

<!-- 問題のない例 -->
```html
<button hidden>すべての環境から隠されたボタン</button>
<button aria-hidden="true" disabled>無効のボタン</button>
<button aria-hidden="true" tabindex="-1">フォーカスの当たらないボタン</button>
```

このテクニックについては、見方を変えると、視覚的に隠れているものを操作可能にしてはならないことを意味します。ここいう隠れているものとは、ある要素が別の要素に重なって視覚的に見えないものや、ある領域が操作不能であることを示すために視覚的にグレーアウトされているものが挙げられます。

### ARIAコンセプト3：操作可能な要素にアクセシブルな名前を持たせる

操作可能な要素、すなわちインタラクティブな要素には、アクセシブルな名前を付けなければなりません。

アクセシビリティAPIを通じて支援技術に公開される要素のラベルのことを、アクセシブルな名前と呼びます。詳細はAccessible Name and Description Computation仕様で定義されています。以下は不適切な例です。

<!-- 不適切な例 -->
```html
<span>ユーザー名</span>
<input type="text">
```

入力欄の隣にテキストがあり、視覚環境であれば、この入力欄に「ユーザー名」を入れればよいことがわかるかもしれません。しかし、このテキストは`input`要素と関連付けられておらず、アクセシブルな名前を持っているとはいえません。スクリーンリーダーの利用者が入力欄にフォーカスした場合、「テキスト入力」などと読み上げられるだけで、何を入力すればよいのかわからないことがあります。

次のように`label`要素としてマークアップし、`input`要素に関連付けることで、この入力欄に「ユーザー名」というアクセシブルな名前を与えることができます。

<!-- 望ましい例 -->
```html
<label>ユーザー名
<input type="text"></label>

<label for="uname">ユーザー名</label>
<input type="text" id="uname">
```

このようにすると、入力欄へフォーカスした際に「ユーザー名 テキスト入力」のように読み上げられ、何を入力するのかがわかります。アクセシブルな名前を与える方法はいくつかあり、`title`属性やARIAのプロパティを使用する方法もあります。

<!-- 問題ない例 -->
```html
<input type="text" title="検索">

<input type="text" aria-label="検索">

<span id="search-label">検索</span>
<input type="text" aria-labelledby="search-label">
```

ヘッダーの検索フォームなど、可視のラベルを用意することが難しいケースでは、属性を利用してもよいでしょう。HTMLの要素の中には、`button`要素のように、内容がそのまま名前となるものもあります。

<!-- 問題ない例 -->
```html
<button>保存して終了</button>
```

ブラウザーの開発者ツールを利用すると、アクセシブルな名前を確認できる場合があります。たとえばChromeでは、要素を「検証」して開発者ツールを開き、"Accessibility"パネルを開くとアクセシブルな名前を確認できます。

![Chrome開発者ツールのAccessibilityパネル](../img/4-2-02.png)

#### アクセシブルな名前の計算

要素にアクセシブルな名前を提供する方法は複数あります。HTMLの`label`要素や`title`属性、先に紹介したWAI-ARIAの`aria-label`属性や`aria-labelledby`属性は、いずれも要素にアクセシブルな名前を提供できます。

複数の手段で同時に名前が与えられた場合は、そのうち1つだけが採用されます。どの手段が採用されるかは要素によって異なります[^14]。厳密にはAccessible Name and Description Computation仕様に定義されたアルゴリズムで決定されますが[^15]、おおよそ以下の優先順位となります。

[^14]: <https://www.w3.org/TR/html-aam/#accessible-name-and-description-computation>

[^15]: <https://www.w3.org/TR/accname/#mapping_additional_nd_te>

- `aria-labelledby`属性
- `aria-label`属性
- `title`属性、`alt`属性、`label`要素などのHTMLネイティブ要素・属性

上に挙げられているものが優先されます。たとえば、`aria-labelledby`属性と`aria-label`属性が同時に指定される場合、`aria-labelledby`属性が優先され`aria-label`属性は無視されます。

#### アクセシブルな名前の提供方針

前述したように、要素にアクセシブルな名前を提供する方法は複数あります。WAI-ARIA Authoring Practices 1.2のCardinal Rules of Naming[^aria-accnameing]で考え方が述べられています。このうち、可視のテキストを使うことと、HTMLのネイティブテクニックを使うことが筆者が特に重要だと考えます。

これはつまり、インタラクティブなインターフェイスには`label`要素で名前を付けるのが基本であり、原則ということになります。特に入力欄であれば、ビジュアルデザインの制約などでラベルを設けるスペースがないために、可視のラベルを付けられないこともあるかもしれません。そのような場合でも、フローティング（floating label）[^floating-label]と呼ばれる手法を用いるなどして、可視のラベルテキストを確保することが考えられます。

[^aria-accnameing]: <https://www.w3.org/TR/wai-aria-practices-1.2/#naming_cardinal_rules>

[^floating-label]: Bootstrapの例が参考になります。 <https://getbootstrap.com/docs/5.1/forms/floating-labels/>

#### ランドマークリージョンとアクセシブルな名前

インタラクティブでない要素の場合、とくにランドマークリージョンにアクセシブルな名前を持たせ、その領域がどのようなものかを支援技術に伝えるという用法があります。1つのページに複数のランドマークリージョン、たとえば`nav`要素について2つある場合に互いを区別するために`aria-label`属性でアクセシブルな名前を与えることができます。しかし、アクセシブルな名前を与えることが常によいことではありません。

<!-- 不自然な望ましくない例 -->
```html
<header>
  <nav aria-label="ヘッダーナビゲーション">
    <!-- ヘッダーナビゲーション -->
  </nav>
</header>
...
<footer>
  <nav aria-label="フッターナビゲーション">
    <!-- フッターナビゲーション -->
  </nav>
</footer>
```

これは`header`要素の`nav`要素に「ヘッダーナビゲーション」、`footer`要素についても同様に「フッターナビゲーション」と付けていますが、そのことは要素のセマンティクスから明らかです。コンテキストから明らかであるものに`aria-label`属性を付与するのは冗長なだけであり、不要です。

また、`aria-label`属性は不可視であり、目の見えるユーザーにはそのことが伝わらないという性質があります。基本的には`aria-label`属性を用いてまで伝える必要があるシーンはそこまで多くないでしょう。複数の`nav`要素に対して区別を明示的にする必要がある場合、そもそも`nav`要素を用いるのが適当かどうかを見直したほうがよいと考えられます。

その上で名前を付けることが適当である場合、画像の代替テキストと考え方と同様に、可視の情報としては伝わっていない名前を付けないようにします。

一方で、可視のテキストとして提供できるのであれば、`aria-labelledby`属性を用いて可視のテキストと関連付けることができます。こうすることで、支援技術を必要としないユーザーにも情報が伝わります。

<!-- 可視テキストを関連付けた例 -->
```html
<nav aria-labelledby="product">
  <div id="product">製品</div>
  <!-- 製品ページへのリンクのナビゲーションリスト -->
</nav>
```

上記の例では、可視の`div`要素に含まれる「製品」というテキストをナビゲーションの名前として利用しました。しかし、`nav`要素はセクショニングコンテンツでもあるため、内容の先頭に見出しがあればセクションの見出しとして扱われます。よって、次のように書くのがより適当でしょう。

<!-- 冗長な望ましくない例 -->
```html
<nav aria-labelledby="product">
  <h2 id="product">製品</h2>
  <!-- 製品ページへのリンクのナビゲーションリスト -->
</nav>
```

`div`要素を`h2`要素に変更したことで、セクションに見出しが付き、`nav`要素の名前として機能するようになりました。この場合、`aria-labelledby`属性がなくてもナビゲーションの名前がわかります。「ARIAルール1：HTML自身に備わっている機能を利用する」を考慮すると、`aria-labelledby`属性は削除してしまってもよいでしょう。

<!--
以下にaria-labelに関する記述があるが、筆者としてはネガティブな立場。（わざわざ見出しと関連付けしなくてもよい）
https://www.w3.org/TR/wai-aria-practices-1.2/#aria_landmark
https://www.w3.org/TR/wai-aria-practices-1.2/#naming_with_aria-label
-->

ここでは`nav`要素を例に挙げましたが、インタラクティブでない領域に`aria-label`属性や`aria-labelledby`属性を用いてアクセシブルな名前を与える場合は、本当に必要かどうかを考えた上で提供するようにしましょう。

## 事例1. ハンバーガーメニューを改良する

ボタンを押すとメニューが開く、というのはよくあるウィジェットです。特にモバイル用のページでは、メニューボタンに3本の横棒のアイコンがよく利用され、その形状から「ハンバーガーメニュー」と呼ばれます。一般的なハンバーガーメニューは、以下のような機能を持ちます。

- ユーザーがボタンを押すと、メニューが出現する
- メニューにはサイト内の主要なコンテンツへのリンクが含まれる
- メニューはコンテンツに覆いかぶさるような形で現れ、メニューが開いている間はメニューの外のコンテンツは利用できない
- メニューが出現したときに、ハンバーガーボタン自体はメニューを閉じるボタンに変化する
- 閉じるボタンを押すとメニューは消え、元の状態に戻る

<!-- サイトから借りてきたが、実際にはポンチ絵の想定 -->
![ハンバーガーメニューの例。左側は初期状態、右側はボタンを押してメニューが開いている状態。](../img/4-4-01.png)

ウェブ制作ではおなじみのパーツですが、アクセシビリティ上の留意点がいくつかあります。深く考えずに作られたハンバーガーメニューは、たとえば以下のようなマークアップになっていることがあります。

```html
<div class="hamburgerMenu">
  <div class="button">
    <span class="menu-icon"></span>
    <span class="close-icon"></span>
  </div>
  <ul>
    <li><a href="/">ホーム</a></li>
    <!-- メニュー -->
  </ul>
</div>
```

`<div class="button">`がボタンに相当します。中に入っている2つの`span`要素は、それぞれハンバーガーアイコンと閉じるアイコンに相当し、CSSの`background-image`プロパティを使ってアイコン画像を表示します。そして、`div`要素に`click`イベントのイベントハンドラーを付けて動くようにします。

```JavaScript
const hamburgerMenu = document.querySelector('.hamburgerMenu');
const hamburgerMenuButton = hamburgerMenu.querySelector('.button');
hamburgerMenuButton.addEventListener('click', () => {
  hamburgerMenu.classList.toggle('js-opened');
});
```

さまざまなJavaScriptの実装方法が考えられますが、ここでは単純に、外側の`div`要素に`js-opend`クラスを付けたり外したりしています。あとは、CSSで`ul`要素を非表示にし、`js-opened`クラスが付いたときだけ`ul`要素が表示されるようにすれば、ひとまずは完成です。

```CSS
.hamburgerMenu ul{
    display: none;
}
.hamburgerMenu.js-opened ul{
    display: block;
}
/* 実際には別のスタイル定義が必要だが省略 */
```

これでメニューボタンは動作しますが、このメニューにはアクセシビリティ上の問題点が複数あります。ここでは、このマークアップで作成されたメニューが既に存在すると仮定して、WAI-ARIAを利用しない方法も含めて、アクセシビリティを向上していく過程の考え方を紹介します。

### キーボード操作を可能にする

このメニューの最大の問題は、ARIAコンセプト1に反してキーボード操作できないことです。メニューボタンは`div`要素で実装されています。`click`イベントを付けているため、マウスでのクリックやタップには反応しますが、キーボードではこのボタンを押すことができません。そもそもフォーカスを当てることができないのです。

ARIAコンセプト1を満たすためのいくつかの方法があります。

#### 方法1 `button`要素を使用する

Chapter4-2のARIAルール1でも触れたように、WAI-ARIAを使う上で最も重要なことは、一見矛盾しますがWAI-ARIAを使わないことです。HTMLにはボタンの機能を提供する`button`要素があるのですから、ここでは`button`要素を使うべきです。

```html
<button>
  <span class="menu-icon"></span>
  <span class="close-icon"></span>
</button>
```

これだけでキーボード操作が可能になります。`role`属性だけでなく、`tabindex`属性も`keypress`イベントも必要ありません。`button`要素はそれらの機能を既に備えているからです。

#### 方法2 `a`要素を使用する

お勧めはしませんが、`a`要素でもフォーカスを受け取ることはできます。`a`要素に`role=button`を指定すると、ボタンであると宣言できます。

`role`属性の指定は単に役割を宣言するだけです。`role=button`を指定したからといって、ボタンと同じ挙動にはならないことに注意してください。

`a`要素は`button`要素とは細部の動作が異なります。たとえば、`button`要素ではフォーカスしたあとに<kbd>スペース</kbd>キーでボタンを押すことができますが、`a`要素ではできません。基本的には`button`要素を利用するべきです。

#### 方法3 `div`要素のままキーボード操作できるようにする

まったくお勧めしませんが、何らかの理由で`button`要素が利用できない場合、`div`要素のままキーボード操作を可能にもできます。

まずは、フォーカスが当たるようにするために、`tabindex=0`を指定します。そして`role=button`を指定すると、スクリーンリーダーでも「ボタン」と読み上げられるようになります。

<!-- 望ましくない例 -->
```html
<div class="button" role="button" tabindex="0">
  <span class="menu-icon"></span>
  <span class="close-icon"></span>
</div>
```

さらに、キーボード操作の対応のために`keypress`イベントを付けます。

<!-- 望ましくない例 -->
```JavaScript
hamburgerMenuButton.addEventListener('keypress', event => {
  // Enterキーやスペースキーでボタンが押せ、かつTabキーではボタンが押されないような実装...
});
```

このイベント内では、押されたキーを判定して、<kbd>Enter</kbd>キーや<kbd>スペース</kbd>キーならばボタンが押されるように、かつ<kbd>Tab</kbd>キーなどの操作を横取りしないように実装します。

ただし、繰り返しになりますが、この方法はお勧めしません。複雑で労力がかかる上に、考慮すべきことが多数あるために、考慮漏れも生じやすくなります。基本的に`button`要素を使うべきです。

### 何のボタンかわかるようにする

ボタンを`button`要素にすると、スクリーンリーダーを使ってボタンにフォーカスを当てたときに、「ボタン」と読み上げられるようになります。ただし、これだけでは、このボタンが何をするものなのかわかりません。視覚環境であれば、ボタンにハンバーガーのアイコンが付けられていることがわかりますが、スクリーンリーダーなどの支援技術には何のボタンなのかが伝わりません。

ARIAコンセプト3にあるような、何のボタンかわかるようにするには、ボタンにラベルを与えます。たとえば、「メニュー」というラベルを与えると、「メニュー ボタン」などと読み上げられて、何をするボタンか理解できるようになります。

ボタンにラベルを与える方法はいくつかあります。

#### 方法1 画像を`img`要素にして`alt`属性でテキストを指定する

1つは、`button`要素の中にラベルとなるテキストを追加する方法です。最もシンプルな方法は、CSSの背景画像ではなく、`img`要素で画像を指定し`alt`属性を指定する方法です。

```html
<button>
  <!-- 閉じている場合にのみ表示され、開くとdisplay:noneになる -->
  <span class="menu-icon"><img src="menu.png" alt="メニュー"></span>

  <!-- 開いている場合にのみ表示され、閉じるとdisplay:noneになる -->
  <span class="close-icon"><img src="close.png" alt="閉じる"></span>
</button>
```

このようにすると、スクリーンリーダーで読み上げられることに加え、画像が表示できないケースで代替テキストを利用することが期待できます。通信速度の問題で画像を表示しないようにしている場合などにも活用できる可能性があるでしょう（実際に代替テキストが表示されるかどうかはブラウザーによります）。

ところで、「メニュー」や「閉じる」アイコンは意味を持つ画像コンテンツと考えられます。意味を持つ画像はアクセシビリティの観点から代替テキストが必要です（WCAG 2.1達成基準1.1.1非テキストコンテンツ[^3]）。代替テキストを提供するシンプルな方法が`img`要素の`alt`属性です。

[^3]: <https://www.w3.org/TR/WCAG21/#non-text-content>

なお、`img`要素を用いるこの方法は、「CSSスプライト」と呼ばれる技法と相性が悪いという問題はあります。最近はCSSスプライトが使われることも少なくなってきましたが、とはいえCSSの背景画像を使う実装を避けられないこともあるでしょう。その場合には他の方法を考えることもできます。

#### 方法2 スクリーンリーダー用テキストを入れる

スクリーンリーダーで読み上げさせる専用のテキストを入れる方法もあります。

```html
<button>
  <span class="visually-hidden">メニュー</span>
  <span class="menu-icon"></span>
  <span class="close-icon"></span>
</button>
```

`visually-hidden`は、視覚環境で表示されず、かつスクリーンリーダーでは読み上げられるようなスタイルを定義したクラスです。CSSフレームワークは、このようなクラスをあらかじめ用意していることがあります（クラス名はフレームワークによって異なります。ほかには`sr-only`などが使われることもあります）。たとえば、Bootstrap 5.0の`visually-hidden`[^4]には、以下のようなスタイルが定義されています。

[^4]: <https://github.com/twbs/bootstrap/blob/main/scss/mixins/_visually-hidden.scss>

```css
.visually-hidden {
  position: absolute !important;
  width: 1px !important;
  height: 1px !important;
  padding: 0 !important;
  margin: -1px !important;
  overflow: hidden !important;
  clip: rect(0, 0, 0, 0) !important;
  white-space: nowrap !important;
  border: 0 !important;
}
```

こうしておくと、テキストはスクリーンリーダーで読み上げられ、かつ視覚環境には影響を与えません。

#### 方法3 `aria-label`属性を利用する

別の選択肢として、`aria-label`属性も利用できます。

```html
<button aria-label="メニュー">
  <span class="menu-icon"></span>
  <span class="close-icon"></span>
</button>
```

このようにすると、`aria-label`属性に対応しているスクリーンリーダーでは「メニュー ボタン」と読み上げられることが期待できます。

しかし、この方法はCSS無効時にフォールバックテキストが存在しないという問題があります。ラベルを与えるスマートな方法ではありますが、お勧めはしません。

<!-- さすがに遠すぎると思うのでとりあえずコメントアウト -->
<!-- 
ほかにも、`aria-labelledby`属性や`label`要素を利用する方法も考えられますが、これらは不可視のラベルを与えるのには向きません。どこかに見えているラベルがある場合は、これらの方法を検討するとよいでしょう。なお、ボタンの外にあるテキストを`label`要素として結び付けた場合、ラベルテキストをクリックしてもボタンが反応するようになるので注意してください。
-->

#### 方法4 `aria-haspopup`属性を利用する

ボタンのラベルとはまた別の方法として、`aria-haspopup`属性を指定する方法もあります。

```html
<button aria-haspopup="menu">
```

こうすると、`aria-haspopup`属性に対応したスクリーンリーダーでは、ラベルがなくても「ボタン メニュー ポップアップ」などと読み上げられるようになります。これにより、メニューがポップアップするボタンであることは伝わるようになります。

ボタンにラベルがある場合、それもあわせて読み上げられます。「メニュー」というラベルがある場合、「メニュー ボタン メニュー ポップアップ」と読み上げられることになります。これは冗長ですので、ボタンのラベルだけで動作が十分に伝わる場合は、`aria-haspopup`属性を指定しないという考え方もあります。

なお、メニューを開いたときにこのボタンが閉じるボタンに変化する場合、これにあわせて`aria-haspopup`属性を削除する必要があります。メニューを閉じるボタンが「メニュー ポップアップ」と読み上げられると、混乱を招いてしまうためです。

最後に、メニューがポップアップなのかという点についてはケースバイケースと考えられます。ポップアップの場合にのみ`aria-haspopup`属性を使用します。

### メニューの開閉状態がわかるようにする

ここまでで、キーボード操作ができ、ボタンも「メニュー ボタン」と読み上げられるようになりました。これで、メニューボタンを利用できる最低限の条件は満たしていますが、スクリーンリーダーのユーザーにはメニューを開いたことが伝わりにくいという問題がまだ残っています。

これは、視覚的にはメニューが開いたことは一目瞭然ですが、スクリーンリーダーではそのことが伝わらないともいうことができます。ボタンをもう一度読み上げさせても「メニュー ボタン」と読み上げられるだけですし、何度押しても状況は変わりません。今回はボタンに「メニュー」というラベルを付けましたから、メニューが開いただろうと想像はできるでしょう。しかし、実際にどこがどう変化したかはわからないのです。

現在のメニューの開閉状態がわからない、つまりメニューが開いているのか、閉じているのかがわからない問題について、対応を検討していきます。

#### 方法1 開いたメニューにフォーカスを移す

メニューを開いたことを直接伝える方法は、開いたメニューにキーボードフォーカスを移してしまうことです。メニューにはフォーカスを受け取ることのできる`a`要素が含まれていますから、先頭の`a`要素にフォーカスを移動します。こうすると、ボタンを押した直後にメニューのリンクの内容を読み上げ始めますから、メニューが開いたことは間違いなく伝わるでしょう。

先のJavaScriptにあったボタンクリック時のイベントに、フォーカス移動の処理を追加します。

```JavaScript
hamburgerMenuButton.addEventListener('click', () => {
  hamburgerMenu.classList.toggle('js-opened');
  hamburgerMenu.querySelector('ul a').focus(); // この行を追加
});
```

この方法はわかりやすい反面、フォーカスを強制的に移動させてしまう点に注意が必要です。フォーカス移動が予測できなかったり、移動元と移動先が離れていて戻り方がわかりにくいような場合、ユーザーを混乱させることがあります。この例では、「メニュー」というボタンを押すと直後のメニューに移動するという挙動ですから、大きな問題はないでしょう。

なお、HTMLソースコード上で、移動元と移動先が離れている、言いかえればDOM上で親子や隣接する兄弟関係にない場合、WCAG 2.1達成基準1.3.2意味のある順序[^5]の問題となってくる点に留意する必要があります。

[^5]: <https://www.w3.org/TR/WCAG21/#meaningful-sequence>

#### 方法2 ボタンのラベルで状態を伝える

フォーカスを移さない場合、ボタンのラベルで現在の状態を伝えるという方法もあります。たとえば、メニューを開いたときに、JavaScriptでボタンのラベルを変更し、「メニューを閉じる」に変えるという方法です。こうすると、ボタンを再度読み上げさせれば「メニューを閉じる ボタン」と読み上げられますから、現在メニューが開いている（だから閉じることができる）と推測できるようになるでしょう。

```html
<button>
  <!-- 閉じている場合にのみ表示され、開くとdisplay:noneになる -->
  <span class="menu-icon"><img src="menu.png" alt="メニュー"></span>

  <!-- 開いている場合にのみ表示され、閉じるとdisplay:noneになる -->
  <span class="close-icon"><img src="close.png" alt="メニューを閉じる"></span>
</button>
```

ただし、これだけでは開いたメニューがページ内のどこに存在するかはわかりません。ボタンの直後にメニューがあれば大きな問題はありませんが、ボタンから離れた場所にメニューが存在する場合に、フォーカスの管理をしなければ、WCAG 2.1達成基準2.4.3フォーカス順序[^6]の問題が生じます。その観点からも、メニューをボタンに隣接する兄弟として提供する必要があります。

[^6]: <https://www.w3.org/TR/WCAG21/#focus-order>

#### 方法3 `aria-expanded`属性を利用する

WAI-ARIAには開閉状態を通知する`aria-expanded`属性があります。メニューが開いたとき、`button`要素に`aria-expanded=true`を追加するようにします。

```html
<button aria-expanded="true">
```

こうすると「メニュー ボタン 開いています」などと読み上げられます。同様に、`aria-expanded=false`を指定すると「メニュー ボタン 閉じています」などと読み上げられます（「隠されました」などと読み上げるものもあります）。

ボタンのラベルだけで挙動が十分に伝わる場合は、あえて`aria-expanded`属性を指定しないほうが簡潔になる場合もあります。たとえば、メニューが開いたときにボタンのラベル自体を変更して「メニューを閉じる」としている場合、「メニューを閉じる ボタン」だけで伝わるでしょう。「メニューを閉じる ボタン 開いています」と読み上げられても害はありませんが、冗長になります。

初期状態では`aria-expanded`属性を付けないようにしておき、開いたときだけ`aria-expanded=true`を付ける方法もあります。この場合、メニューが閉じているときは「メニュー ボタン」と読み上げられ、開いているときは「メニュー ボタン 開いています」と読み上げられるようになります。ボタンのラベルや他のARIA属性も合わせた状態で実際に読み上げさせて、ボタンの挙動が伝わるかどうかを考えて用いるとよいでしょう。

ただし、`aria-expanded`属性が何に対して開閉しているのかを明示できていないという問題が残ります。これについては、`aria-controls`属性で制御対象を明示します。`aria-controls`属性についてはChapter4-2を参照してください。

### メニューの裏側にフォーカスが当たらないようにする

メニューを開いたとき、視覚環境ではメニューがコンテンツに覆いかぶさり、メニューに隠れてコンテンツが画面では見えない状態になります。

しかしキーボード操作の場合、メニューが開いた状態でも背後のコンテンツにフォーカスを移せてしまう場合があります。メニューの裏側の要素にフォーカスが移ると、視覚環境のキーボードユーザーはフォーカスを見失い、混乱することがあります。ちなみにスクリーンリーダーのユーザーの場合、メニューが開いたままであることに気づかず、普通に利用できてしまうことが多いでしょう。

これは、WCAG 2.1達成基準2.4.3フォーカス順序の問題となってきます。ARIAコンセプト2を満たすように、このようなフォーカス順序の問題を避けるいくつかの方法を検討します。

#### 方法1 メニューの外の要素をすべてフォーカス不可能にする

メニューが開いたときに、メニューの外の要素をすべてフォーカス不可能にするという方法です。実装方法は複数存在します。

- メニューの外側のフォーカス可能な要素すべてに`tabindex=-1`を指定する
- メニューの外側の要素すべてを`display: none;`や`visibility: hidden`などで削除する
- メニューを`dialog`要素として実装し、`showModal()`メソッドで呼び出す

詳細な実装方法はここでは説明しません。`dialog`要素についてはChapter3-10を参照してください。

なお、`aria-hidden`属性はこの目的では利用できないことに注意してください。`aria-hidden`属性を指定してもフォーカス移動には影響しません。スクリーンリーダーのユーザーは読み上げられない要素にフォーカスを奪われて混乱することになります。

#### 方法2 メニューの最後の要素からフォーカスを移動するとき、メニューの先頭に戻す

メニューからフォーカスが外に出るのは、メニューの最後の要素からさらにフォーカスを移動しようとしたときです。そのタイミングで<kbd>Tab</kbd>キーの挙動をフックして、メニューの先頭に戻してしまえば、フォーカスはメニューの外に出られなくなります。これは、フォーカストラップとも呼ばれます。

フォーカストラップを実現する方法の1つは、メニューの最後の要素からフォーカスが離れようとする際に処理することです。JavaScriptで`keypress`イベントを付けておき、<kbd>Tab</kbd>キーが押されたらメニューの先頭の要素にフォーカスが戻るようにします。

もう1つの方法は、たとえば、メニューの前後に`tabindex`属性を指定した`div`要素を挿入します。

```html
<div tabindex="0"></div>
  <ul id="menu01">
      <li><a href="/">ホーム</a></li>
      <!-- メニュー -->
  </ul>
<div tabindex="0"></div>
```

キーボード操作でメニューの外にフォーカスを移動しようとすると、この`div`要素にフォーカスが当たります。`focus`イベントを付けておき、フォーカスが当たったときにフォーカスをメニューの先頭、もしくは末尾に移動します。

いずれの場合も、フォーカスが脱出不能にならないように気を付けてください。メニューを閉じるボタンが押せなくなると、キーボードを使ってフォーカスが外せなくなるWCAG 2.1達成基準2.1.2キーボードトラップの問題となってしまいます。また、ユーザーはブラウザーのアドレスバーにフォーカスしたい場合、<kbd>Shift+Tab</kbd>キーで戻ることもあります。先頭の要素から前に戻ろうとすることは許容してもよいでしょう。

なお、スクリーンリーダーのユーザーは<kbd>Tab</kbd>キーを使用せずにフォーカスを移動できる場合もあります。また、フォーカスを移動せずに外の要素を読み上げる場合もあります。そのため、フォーカスを制御しきれない場合がありますが、スクリーンリーダーのユーザーは視覚的にフォーカスを見失っても困ることはないので、そこまで気にしないという考え方もあるでしょう。

#### 方法3 メニュー末尾からフォーカス移動しようとした場合、メニューを自動的に閉じる

上記と似ていますが、フォーカスをメニューの先頭に戻すのではなく、メニューを閉じることで解決します。メニューの最後の要素に`keypress`イベントを付けるか、フォーカストラップを利用して、メニューの外にフォーカスが出ようとしたときにメニューを閉じるようにします。

メニューを閉じたときには、フォーカスを適切な場所に移動する必要があります。メニュー項目にフォーカスしたままメニューが閉じると、フォーカスが行方不明になってしまうためです。通常は、メニューを開く直前にフォーカスがあった場所、すなわちメニューボタンにフォーカスを戻すとよいでしょう。

ただしこの方法は、特にスクリーンリーダーのユーザーが高速でフォーカスを移動する場合に、意図せずにメニューが閉じてしまい、<kbd>Shift+Tab</kbd>キーで直前のメニュー項目に戻ることができません。開くボタンにフォーカスがあることで再度開くことができるものの、メニューを閉じることを意図していないために混乱したり、ストレスを感じてしまうようなケースがあるでしょう。

## 事例2. カルーセルのライブラリーを選定する

「カルーセル」（Carousel）とは、回転木馬、メリーゴーランドの意味です。ウェブでは、画像やカードなどが横に並び、左右にスライドして順繰りに表示されるようなコンポーネントを指します。スライドショーと呼ばれたり、イメージローテーターと呼ばれることもあります。

```text
--+ +---+ +--
1 | | 2 | | 3
--+ +---+ +--
```

図4-4-02 左右のスライドが見切れているカルーセルの例

カルーセルにはさまざまなパターンが見られますが、一般的には以下のような機能を持ちます。

- 複数の「スライド」(slide)を持ち、順番に表示できる。スライドには画像やカードなど、視覚的に提示される項目が含まれる
- 1度に表示するスライドは1つだけ（ただし、左右に見切れた状態で前後のスライドが表示されることはある）
- ユーザーの操作により、次のスライド、前のスライドを表示させることができる。多くの場合、カルーセル領域の左右に矢印状のボタンが表示される
- 表示されているスライドをクリックすると、そのスライドに対応するリンク先へ遷移する

また、これらに加えて以下の機能を持つケースも見られます。

- 「スライドピッカーコントロール」(Slide Picker Controls)を持つ。これはスライドが全部で何枚あり、現在表示中のものが何番目かを示すインジケータであり、インジケータ部分をクリックすると、対応するスライドを直接表示させることもできる。多くの場合、カルーセル領域の下部に、円が横に並んだ形で表示される
- ページが読み込まれると同時に自動的にカルーセルの回転が始まる
- スライドにマウスポインターが乗った場合や、キーボードフォーカスが移った場合に、カルーセルの自動回転を停止する
- 「ローテーションコントロール」(Rotation Control)を持つ。これは、カルーセルの自動回転を停止・再開できる機能で、多くの場合、オーディオ機器の一時停止・再生ボタンを模したボタンで表現される

こうしてみると、カルーセルは多数の機能を持つ複雑なものといえます。これらのすべてを自前で実装するのはかなり大変です。実際には、カルーセルを扱う専用のライブラリーを利用するケースが多いでしょう。カルーセルのライブラリーにはさまざまなものがありますが、アクセシビリティに配慮したものもあれば、そうでないものもあります。ここでは、ライブラリーを選定するときに注意したいポイントを見ていくことにしましょう。

すべてを自前で実装する必要がある場合は、WAI-ARIA Authoring Practicesの3.6 Carousel (Slide Show or Image Rotator)[^7]やWeb Accessibility TutorialsのCarousel[^8]を参考にするとよいでしょう。

[^7]: <https://www.w3.org/TR/wai-aria-practices/#carousel>

[^8]: <https://www.w3.org/WAI/tutorials/carousels/>

### キーボード操作が可能か

カルーセルもキーボードで操作できなければなりません。ライブラリー選定時には、動作サンプルをキーボードで実際に操作してみるとよいでしょう。特に問題になりやすいのは以下の点です。

- 現在表示されているスライドにフォーカスし、リンクを辿ることができるか
- 隠れているスライドにフォーカスが当たってしまい、フォーカスが行方不明になることはないか
- 次のスライド/前のスライドボタンにフォーカスし、操作できるか
- スライドピッカーコントロールにフォーカスし、操作できるか
- ローテーションコントロールにフォーカスし、操作できるか

キーボードフォーカスが見えなくなっていて事実上操作できないケースもよく見かけます。フォーカスが明確に見えるかどうかも確認しましょう。

#### フォーカス時の自動停止

カルーセルが自動回転する場合、スライドにフォーカスを移したタイミングでスライドが動くと、フォーカスが行方不明になることがあります。多くのカルーセル実装では、スライドへフォーカスしたときに自動回転を止めることで、これを防いでいます。

同様に、マウスポインターがスライドに乗ったときにも自動回転を止めることが一般的です。スライドをクリックする瞬間にスライドが切り替わると、意図しない遷移先に移動してしまうためです。このような配慮がなされているかどうかも確認しておきましょう。

### スクリーンリーダーで操作できるか

視覚環境だけでなく、スクリーンリーダーで問題なく操作できるかどうかを確認しましょう。

- 現在表示されているスライドが適切に読み上げられるか
- 各種のボタンにラベルが付けられているか
- 隠れているスライドが読み上げられて混乱することはないか

実装方法によっては、隠れているスライドまで読み上げられてしまうことがあります。スライドの内容によっては大きな問題がないケースもありますが、場合によっては混乱を招くこともあるので注意しましょう。自前で実装する場合は、隠れているスライドに`aria-hidden`属性を適用するのも1つの方法です。ただし、`aria-hidden`属性だけではキーボードフォーカスが当たってしまうことに注意してください。

#### 他の箇所の読み上げを妨害しないか

カルーセルが自動回転する場合、1つ重要な注意点があります。他の箇所を読み上げている場合にカルーセルの自動回転が起きたとき、どのように読み上げられるかという点です。

カルーセルのライブラリーの中には、カルーセル領域をライブリージョンとして実装するものがあります。たとえば、Slick[^9]というライブラリーの古いバージョンでは、以下のようにカルーセル領域に`aria-live="polite"`を指定していました。

[^9]: <https://kenwheeler.github.io/slick/>

```html
<div aria-live="polite" class="slick-list draggable">
  <!-- カルーセル領域 -->
</div>
```

カルーセルのスライドが切り替わると、その都度、内容が読み上げられます。カルーセルを手動で操作したときに読み上げられるのは問題ありませんが、ユーザーが他の場所を読んでいる場合でも、カルーセルが自動回転したタイミングで読み上げられることになります。

`aria-live=polite`の指定は、現在の読み上げに対して即座に割り込むのではなく、読み上げが一段落したところで割り込む指定となります。そのため理論上は、現在の読み上げは妨害されないことになっています。しかし実際には、ライブリージョンが読まれるとき、多くのスクリーンリーダーは単に内容を読み上げるだけで、それがライブリージョンであることは伝えません。ユーザーには、現在の場所と異なる場所を読み上げたことがわからない場合があります。たとえば、見出しを読み上げているときにカルーセルが切り替わると、見出しのテキストに続けてそのままカルーセルの内容が読み上げられ、一続きの内容であるように聞こえます。これはユーザーを大いに混乱させることになります。

カルーセルにライブリージョンを採用しているライブラリーを使わざるを得ない場合、スライドのテキストを工夫して、これがスライドであると明確にわかるようにするとよいでしょう。たとえば、テキストの頭に「【広告】」と入れるようにする、といった方法です。

カルーセルを自前で実装する場合、ライブリージョンを使う必要があるかどうかは慎重に検討してください。どうしても利用する必要がある場合は、ユーザーがカルーセル領域から離れたときに`aria-live=off`に切り替えるか、カルーセルの自動回転を止めるようにするとよいでしょう。

### ローテーションコントロールがあるか

ローテーションコントロールは、自動回転するカルーセルを停止する機能です。自動でスライドが切り替わり続けるカルーセルは多く見られますが、その一方で、スライドを停止させる機能を提供しないことがあります。カルーセルが自動回転する場合、ローテーションコントロールが提供されていること、それがアクセシブルであることを確認しましょう。

WCAG 2.1達成基準2.2.2一時停止、停止、非表示[^10]は、動き続けるコンテンツが停止できることを求めています。これはレベルAの要求で、「非干渉」の条件にもなっている重要な基準です。WCAGへの対応が求められる場合には、この基準を必ず満たさなければなりません。

[^10]: <https://www.w3.org/TR/WCAG21/#pause-stop-hide>

## 事例3. タブのマークアップを検討する

「タブ」(Tabs)は、複数のコンテンツを切り替えて表示する機能です。典型的には、パーツ一式の上部に「タブリスト」(Tab List)があり、下部にコンテンツが入る「タブパネル」(Tab Panel)があります。タブリストの中には「タブ」(Tab)が並び、いずれかのタブを選択すると、タブパネルが対応するものに切り替わります。

![](../img/4-4-03.png)

図4-4-03 タブの例（WAI-ARIA Authoring Practicesより）

タブは以下のような機能を持ちます。

- 複数のタブとタブパネルから構成される。タブとタブパネルは1対1対応している
- タブリスト内のすべてのタブは見えている状態になっており、初期状態ではいずれか1つのタブが選択されている
- タブパネルは、選択されているタブに対応したものだけが表示され、他のタブパネルは見えない
- 他のタブをクリックすると、そのタブが選択状態になり、選択したタブに対応するタブパネルが表示される。他のタブパネルは表示されなくなる

タブがキーボード操作を受け付ける場合、以下のような操作になるのが一般的です。

- タブリストにフォーカスを移すと、選択されているタブがアクティブになる
- キーボードの左右キーを押すと、左右にある他のタブを選択することができる

キーボードの左右キーによる操作は、他のウェブコンポーネントではあまり見られない、独自のものとなっています。これは、OSが提供するタブコントロールの操作に合わせたものです。

ウェブコンテンツでは、タブのような見せ方は頻繁に使われます。実際に現場でマークアップを行う機会も多いでしょう。ここでは、タブのマークアップについていくつかのパターンを検討しながら、考え方の過程を見ていきます。

### タブのマークアップと実装

HTMLにはタブを表現する要素がありませんが、WAI-ARIAでは、タブの部品に対応するロールが用意されています。

- タブ：`tab`
- タブリスト：`tablist`
- タブパネル：`tabpanel`

各部品にこれらのロールを適用していくのですが、実際にどのようなマークアップにするべきか検討していきましょう。

#### タブ

タブはユーザーの操作の対象となる要素です。タブをクリックしたとき、タブパネルが切り替わるようにする必要があります。また、キーボードフォーカスを受け取る必要もあります。これらの機能をすべて自前での実装も不可能ではありませんが、お勧めしません。フォーカスを受け取れる要素、`a`要素か`button`要素のいずれかを使うべきでしょう。WAI-ARIA Authoring Practicesのタブの例[^11]では`button`要素を使用していますが、`a`要素が使われることもあります。

[^11]: <https://www.w3.org/TR/wai-aria-practices/#tabpanel>

タブには `aria-controls`属性を指定して、このタブに対応するタブパネルを示すようにします。一部のスクリーンリーダーでは、対応するタブパネルへジャンプできるようになります。

`id`属性を指定しておくと、タブのラベルを`aria-labelledby`属性で参照できるようになります。後述のタブパネルで利用します。

また、JavaScriptで以下の属性を付けます。これらの値は、タブが切り替わったときに動的に変化する想定です。

- `aria-selected`属性 : このタブが現在選択されているかどうかを示します。選択されているタブには"true"を、そうでないタブには"false"を指定します。
- `tabindex`属性 : 選択されていないタブに `tabindex=-1` を指定します。前述のように、キーボード操作ではタブにフォーカスしてから左右キーでタブを切り替える想定となるため、選択されていないタブには直接フォーカスが当たらないようにします。

タブが3つある場合、たとえば以下のようなマークアップになります。`aria-selected`属性と`tabindex`属性はJavaScriptで動的に付けられている想定です。

```html
<button type="button" role="tab" id="tab01" aria-controls="tabpanel01"
 aria-selected="true">タブその1</button>
<button type="button" role="tab" id="tab02" aria-controls="tabpanel02"
 aria-selected="false" tabindex="-1">タブその2</button>
<button type="button" role="tab" id="tab03" aria-controls="tabpanel03"
 aria-selected="false" tabindex="-1">タブその3</button>
```

タブには必ずラベルを付けるようにしてください。上記の例のように、要素の中にラベルテキストが入っていれば問題ありません。タブにテキストを持たせられないような場合は、`aria-label`属性でラベルを与えることを検討しましょう。タブパネルに見出しが含まれており、その見出しのテキストをそのままタブのラベルにできるならば、その見出しにIDを付けて`aria-labelledby`属性で参照してもよいでしょう。

#### タブリスト

タブリストは、タブが列挙される部分です。`tablist`ロールを適用しますが、どのHTML要素を採用するかは議論の余地があります。

ARIA in HTMLでは、`menu`、`ol`、`ul`、`nav`要素に`tablist`ロールが適用できることになっています。ほかにも、すべてのロール（Any role）が適用可能とされている要素には`tablist`ロールを適用できますので、`p`要素や`div`要素などが候補になります。なお、`dl`要素には`tablist`ロールを指定できないため、候補にはなりません。

タブリストにはタブが複数列挙されますし、名前に「リスト」と付いていますから、`ul`要素は有力候補です。しかし、WAI-ARIAの`tablist`ロールは`list`ロールと派生関係になく、`listitem`ロールの親にはなれません。`ul`要素のロールを`tablist`に変更すると、`li`要素の`listitem`ロールが破綻を起こすことになります。`li`要素に`tab`ロールの指定も可能ではありますが、先に述べたように、`tab`ロールは`button`要素か`a`要素に指定したほうがよいでしょう。そうすると、`li`要素には`role=presentation`を指定することになります<!--（指定しなくても、ブラウザーによって同等の意味の`role=generic`に上書きされ、`listitem`ロールは失われます）-->。

`ul`要素を使っても、結局はリストの意味を失わせることになりますので、最初から`div`要素を使うという考え方も有力です。実際、WAI-ARIA Authoring Practicesのタブの例では`div`要素を使用しています。どちらが正解というわけでもなく、前後の文脈や互換性など、周辺の事情を考えて採用するとよいでしょう。後述の「タブと他の見せ方を切り替える」も参照してください。

<!--タブリストには、必要に応じて、`aria-label`属性を用いてラベルを与えてもよいでしょう。文脈によっては、タブリストに含まれるタブが何であるのか、何を切り替えるのかが伝わらない場合もあります。前後の文脈から十分に伝わるようであれば、`aria-label`属性は指定しなくてもよいでしょう。

```html
<div role="tablist" aria-label="XX機能の切り替え">
  <button type="button" role="tab" id="tab01" aria-controls="tabpanel01"
  aria-selected="true">タブその1</button>
  <button type="button" role="tab" id="tab02" aria-controls="tabpanel02"
  aria-selected="false" tabindex="-1">タブその2</button>
  <button type="button" role="tab" id="tab03" aria-controls="tabpanel03"
  aria-selected="false" tabindex="-1">タブその3</button>
</div>
```
-->

#### タブパネル

タブパネルは実際に表示される内容を含む部分で、`tabpanel`ロールを適用します。

`tabpanel`ロールは、ARIA in HTMLでは`section`要素に適用可能とされています<!--[^1]-->。そのほか、任意のロールを適用可能な要素で利用できますが、タブパネルの中にさまざまな要素が入る可能性を考えると`p`要素などは使いにくく、事実上`section`要素と`div`要素のどちらかになるでしょう。タブパネルの中に見出しが入ってセクションとして成立しているならば`section`要素、そうでなければ`div`要素を利用するのがよいでしょう。WAI-ARIA Authoring Practicesのタブの例では`div`要素を使用しています。

<!--
[^1]: 当初のARIA in HTMLでは`section`要素に`tabpanel`ロールを指定することは許されていませんでしたが、2016年11月の更新で可能となりました。

抜粋:: ヘイドン・ピカリング  “コーディングWebアクセシビリティ”。 Apple Books  
-->

タブから`aria-controls`属性で参照するために、タブパネルには`id`属性を指定します。

タブパネルをフォーカス可能にする場合、タブパネルにはラベルを付けるべきです。通常は、タブのラベルをそのまま使えるはずですので、タブにIDを付けて`aria-labelledby`属性で参照するとよいでしょう。タブパネルの中に見出しが含まれる場合は、見出しにIDを付けて参照してもよいでしょう。ラベルにふさわしいテキストがどこにもない場合は、`aria-label`属性でラベルを付けることも可能です。

タブパネルはたとえば以下のようなマークアップになります。

```html
<div tabindex="0" role="tabpanel" id="tabpanel01" aria-labelledby="tab01">
<!-- タブパネルの内容 -->
</div>
<div tabindex="0" role="tabpanel" id="tabpanel02" aria-labelledby="tab02" hidden>
<!-- タブパネルの内容 -->
</div>
<div tabindex="0" role="tabpanel" id="tabpanel03" aria-labelledby="tab03" hidden>
<!-- タブパネルの内容 -->
</div>
```

表示されていないタブパネルは、JavaScriptで`hidden`属性を指定して非表示にします。CSSの優先度によっては、`hidden`属性で要素を隠せないこともあるかもしれません。その場合は、`class`属性にクラス名を与えてCSSで非表示にしてもよいでしょう。

通常、`aria-hidden`属性を利用する必要はありません。非表示のタブパネルは視覚環境からも隠されるべきもので、典型的にはCSSの`display:none`を適用して、視覚環境とスクリーンリーダーの双方から隠されるようにします。演出上の都合など何らかの理由で`display:none`を適用できず、非表示のタブパネルがスクリーンリーダーで読み上げられてしまうような場合には、`aria-hidden`属性の利用を検討してもよいでしょう。

#### JavaScript実装

これでマークアップは完成です。あとは、JavaScriptを実装して動作するようにします。

具体的なコード例についてはWAI-ARIA Authoring Practicesに譲りますが、タブがクリックされた場合だけでなく、タブにフォーカスしたときのキーボード操作も忘れずに実装します。`keypress`イベントではカーソルキーの操作を取得できないので、`keydown`イベントと`keyup`イベントを利用することになります。

### タブと他の見せ方を切り替える

タブインターフェイスを導入する大きな目的の1つは、画面スペースの節約です。タブ操作によって表示を切り替える仕組みを導入することで、狭いスペース内で多くの情報を見せることができるようになります。

逆に言えば、画面スペースによっては、必ずしもタブインターフェイスが最適ではないかもしれません。たとえば、レスポンシブデザインを採用して、画面が狭い場合にはタブで表現し、広い場合にはすべてを展開して見せたいと考えるケースもあるでしょう。

タブインターフェイスを構成する要素は、ページ内リンクの目次と相性がよいことが知られています。タブリストは目次のリスト、タブは目次内のリンク、タブパネルはリンク先のセクションに対応します。

```html
<ul>
  <li><a href="#section01">セクション1</a></li>
  <li><a href="#section02">セクション2</a></li>
  <li><a href="#section03">セクション3</a></li>
</ul>
<section>
  <h2 id="section01">セクション1</h1>
  <p>セクション1の内容...</p>
</section>
<section>
  <h2 id="section02">セクション2</h1>
  <p>セクション2の内容...</p>
</section>
<section>
  <h2 id="section03">セクション3</h1>
  <p>セクション2の内容...</p>
</section>
```

このようなページ内リンクをタブに仕立て上げることができます。JavaScriptで`role`属性を付与して以下のようにします。

```html
<ul role="tablist">
  <li role="none"><a role="tab" href="#section01">セクション1</a></li>
  <li role="none"><a role="tab" href="#section02">セクション2</a></li>
  <li role="none"><a role="tab" href="#section03">セクション3</a></li>
</ul>
<section role="tabpanel" aria-labelledby="section01">
  <h2 id="section01">セクション1</h1>
  <p>セクション1の内容...</p>
</section>
<section role="tabpanel" aria-labelledby="section02">
  <h2 id="section02">セクション2</h1>
  <p>セクション2の内容...</p>
</section>
<section role="tabpanel" aria-labelledby="section03">
  <h2 id="section03">セクション3</h1>
  <p>セクション2の内容...</p>
</section>
```

ほかにも細かい属性やイベントを付ける必要がありますが、タブとして成立することはわかるでしょう。このようにすると、状況によってページ内リンクの見せ方とタブの見せ方とを切り替えることが可能になります。また、JavaScriptが動作しない環境でも、ページ内リンクとして成立させることができます。

#### タブの操作方法をあえて実装しない選択

上記の例ではページ内リンクをタブの見せ方にするだけでなく、タブ関連のロールと機能を適用して、実際にタブとして動作させることを想定しています。タブになると、キーボードでの操作方法は変化します。ページ内リンクだった場合は、<kbd>Tab</kbd>キーでリンクに次々とフォーカスしていき、希望のリンクを選択するという方法でした。タブになると、現在選択されているタブにフォーカスし、左右キーでタブを選ぶという方法になります。

この操作方法の変更は本当に必要なのでしょうか。見せ方だけ変えて操作は変えず、ロールも変えず、そのままページ内リンクとして操作させるという考え方もあります。タブを提供するコンテンツがウェブアプリケーションである場合は、デスクトップアプリケーションと同じ操作感が求められることがあります。その場合には、タブはタブとして操作できたほうがよいでしょう。そうではなく、単に省スペースを目的としてタブの見せ方にしているだけであれば、ページ内リンクの操作方法でも問題ないことが多いでしょう。

ただし、リンクをクリックした場合の挙動には注意してください。ページ内リンクの場合、基本の動作としては、リンクをクリックすると該当箇所までスクロールし、明確に画面を変化させます。しかし、タブの見せ方にした場合、リンクを押しても画面がスクロールしない場合があります。画面を拡大しているユーザーの場合、タブの部分を画面いっぱいに拡大していると、その外で起きた変化に気づかず、何が起きたかわからないことがあります。リンクを押したときに、対応する見出しにフォーカスを移すなどして対応するとよいでしょう。

## 事例4. モーダルダイアログ

「ダイアログ」(dialog)は、ウェブコンテンツの上に覆いかぶさるように出現するウィンドウ領域です。基本的には、ユーザーに対して注意を促したり、何かを入力させるために用います。ダイアログには、大きく分けて2つのモードがあります。

- 「モーダルダイアログ」(modal dialog): ダイアログが出現するとダイアログに対して操作を行うモードになり、その間、ダイアログ以外の要素を操作できなくなるもの
- 「モードレスダイアログ」(modeless dialog): ダイアログが出ても他のコンテンツを引き続き操作できるもの

モーダルダイアログの場合、他のコンテンツが操作できないことがわかるように、ダイアログの外を暗くする演出が一般的です。

![](../img/4-4-04.png)

図4-4-04 モーダルダイアログのイメージ図

ウェブではモードレスダイアログはあまり利用されません。他のコンテンツを引き続き操作できる場合、ダイアログではない見せ方をすることが多いでしょう。モーダルダイアログはしばしば利用されます。ここでは、モーダルダイアログの実装についていくつかの方法をとりあげ、内容を見ていくことにします。

### `window.confirm()`メソッドによる簡易なダイアログ

簡易なダイアログであれば、JavaScriptの機能だけで簡単に実装できます。`window.confirm()`メソッドを利用すると、ユーザーにOKかキャンセルかの2択を問うモーダルダイアログを出すことができます。以下は、フォームをリセットする場合に警告のダイアログを出す例です。

```html
<form onreset="return confirm('フォームの内容をすべて初期化します。よろしいですか?')">
  <input value="初期値">
  <button>送信</button>
  <button type="reset">リセット</button>
</form>
```

これはたとえば以下のように表示されます。

![スクリーンショット: Chromeのconfirmダイアログ](../img/4-4-05.png)

ユーザーがキャンセルボタンを押した場合は`confirm()`の戻り値が`false`となり、`return false`が実行されてリセットの動作がキャンセルされる仕組みになっています。Chapter4-1のイベントハンドラー属性も参照してください。

このダイアログはブラウザーの機能でできているため、ダイアログの見た目を制御できません。見た目はブラウザーによって異なりますが、ほとんどの場合は非常にシンプルな見た目になります。とはいえユーザーに対して簡潔にYes/Noを問うだけでよいシーンでは機能として十分でしょう。

### `dialog`要素によるダイアログ

HTMLには、ダイアログを表示するための`dialog`要素が用意されています。`showModal()`メソッドを呼ぶとモーダルダイアログとして呼ぶことができます。

```html
<dialog id="confirm_dialog">
  <form method="dialog">
    <p>OKですか?</p>
    <button type="submit" value="OK">OK</button>
    <button type="submit" value="Cancel">Cancel</button>
  </form>
</dialog>
<script>
const dialog = document.getElementById('confirm_dialog');
const dialogOpen = () => {
  dialog.showModal();
};
dialog.onclose = () => {
  alert(dialog.returnValue);
};
</script>
<button type="button" onclick="dialogOpen()">ダイアログを開く</button>
```

単にこれだけで、モーダルダイアログの外にある要素を暗く表示し、操作できないようにするところまで実現します。`dialog`要素にはダイアログとしてのネイティブのセマンティクスもあるため、`role`属性を追加する必要もありません。

なお、初期状態でダイアログを隠す処理も実現されていますが、単にユーザーエージェントのスタイルシートで`dialog:not([open]){display:none;}`というスタイルが与えられているだけです。より強いセレクターで`display`プロパティを上書きすると、ダイアログが表示されてしまうこともあるので注意してください。

`dialog`要素は非常に便利ですが、2021年10月時点で、一部のブラウザーによるサポートはまだ不十分です。詳細については、Chapter3-10の`dialog`要素を参照してください。

### WAI-ARIAを駆使した実装

`dialog`要素をサポートしないブラウザーを想定すると、他の要素とWAI-ARIAを組み合わせて自前でダイアログを実装する選択肢が現実的になります。ダイアログのマークアップは、たとえば以下のようになります。

<!-- https://w3c.github.io/aria-practices/examples/dialog-modal/dialog.html のサンプルのうち、4番目のダイアログを少しシンプルにして、DOM操作で追加される要素を入れたたもの -->
```html
<div id="dialog_layer" class="dialogs">
  <div tabindex="0"></div>
  <div id="dialog4" class="dialog"
    role="dialog"
    aria-labelledby="dialog_label"
    aria-describedby="dialog_desc"
    aria-modal="true">
    <h2 id="dialog_label">ダイアログの見出し</h2>
    <p id="dialog_desc">
      ダイアログのメッセージ...
    </p>
    <!-- その他さまざまな中身が入る -->
    <button type="button"
      id="dialog_close_button">
      <img src="close.png" alt="閉じる">
    </button>
  </div>
  <div tabindex="0"></div>
</div>
```

`div`要素に`dialog`ロールを指定して、ダイアログであることを示します。ダイアログが警告やエラーを表示する場合は、代わりに`alertdialog`ロールを指定します。

`aria-labelledby`属性で見出しを、`aria-describedby`属性でメッセージを提供しています。これにより、ダイアログにフォーカスすると、スクリーンリーダーで見出しとメッセージが読み上げられるようになります。この例ではダイアログの内部に見える形で見出しと説明文があるため、それらを利用して結び付けています。見える形のテキストラベルがない場合は、`aria-label`属性などを利用してもよいでしょう。

`aria-modal="true"`により、このダイアログがモーダルであることを示しています。`aria-modal`属性に対応した支援技術の場合、これだけでモーダルの外の要素を操作できないようにする場合があります。とはいえ、この処理は仕様上必須とはされておらず、対応していない支援技術もあるため、モーダルダイアログの外の要素が読み上げられないようにしたり、キーボードフォーカスを制御する処理の実装も必要です。
<!--
When a modal element is displayed, assistive technologies SHOULD navigate to the element unless focus has explicitly been set elsewhere. Assistive technologies MAY limit navigation to the modal element's contents. If focus moves to an element outside the modal element, assistive technologies SHOULD NOT limit navigation to the modal element.
-->

キーボードフォーカスの制御のために、ダイアログの前後に`<div tabindex="0"></div>`を挿入しています。これは、ハンバーガーメニューの事例で紹介したフォーカストラップです。先に挙げたコード例では直接HTMLとして書かれていますが、実際にはJavaScriptによるDOM操作で`div`要素を挿入します。同時に、`focus`イベントを付けてフォーカスをトラップする制御します。

モーダルダイアログの内部には、閉じるボタンを置きます。`aria-modal`属性を指定するとダイアログの外側にアクセスできなくなることがあるため、ダイアログを開いたボタンをトグルさせたい場合などは、ボタンが必ずダイアログの内部に来るように配慮してください。また、<kbd>Esc</kbd>キーが押されたときにダイアログが閉じるようにしておくとよいでしょう。

あとはJavaScriptで動作を制御するだけですが、コードは長くなるため、ここでは紹介しません。具体的なJavaScriptのコードやその他の細部については、WAI-ARIA Authoring Practicesのdialogの例[^13]を参考にしてください。

[^13]: <https://www.w3.org/TR/wai-aria-practices/examples/dialog-modal/dialog.html>

## テストを行う

ここまで、WAI-ARIAを利用する事例を紹介してきました。HTMLだけでアクセシビリティを担保できない場合に、WAI-ARIAを利用することで、アクセシビリティを向上できることがあります。

しかし、常にWAI-ARIAを利用するのがよいわけではありません。WAI-ARIAの実践例を多数紹介しているWAI-ARIA Authoring Practicesのセクション2.1[^17]の見出しに"No ARIA is better than Bad ARIA"とあります。これはARIAを不適切に利用するくらいなら、使わないほうがよいという意味です。

[^17]: <https://www.w3.org/TR/wai-aria-practices/#no_aria_better_bad_aria>

このChapterでも見てきたように、WAI-ARIA以外の手段のほうがよいケースや、WAI-ARIAを無理に使わなくても十分に伝わり、WAI-ARIAによる補足がむしろ冗長になるケースなどもあります。

では、WAI-ARIAの利用が適切かどうかは、どうやって判断すればよいのでしょうか。筆者は、実際に動作検証をすることが重要だと考えています。Chapter4-2でも触れたように、実際にスクリーンリーダーなどの支援技術を用いてアクセスすることは難しくありません。

このChapterで触れたような複雑な事例では、ユーザビリティの観点も重要になるはずです。実際にユーザーに触れてもらい、テストを行うことがより重要になってくるでしょう。
