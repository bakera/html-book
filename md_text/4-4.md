# WAI-ARIAの実践

Chapter4-2ではWAI-ARIAと関連仕様についてとりあげました。このChapterでは、実際にウェブでよく使われる部品の事例を通じて、WAI-ARIAをどのように利用するのか、その検討の過程や考え方について紹介します。より詳しい具体的なコード例については、WAI-ARIA Authoring Practices[^1]などを参照してください。

[^1]: <https://www.w3.org/TR/wai-aria-practices/>

## 事例1. ハンバーガーメニューを改良する

ボタンを押すとメニューが開く、というのはよくあるウィジェットです。特にモバイル用のページでは、メニューボタンに3本の横棒のアイコンがよく利用され、その形状から「ハンバーガーメニュー」と呼ばれます。一般的なハンバーガーメニューは、以下のような機能を持ちます。

- ユーザーがボタンを押すと、メニューが出現する
- メニューにはサイト内の主要なコンテンツへのリンクが含まれる
- メニューはコンテンツに覆いかぶさるような形で現れ、メニューが開いている間はメニューの外のコンテンツは利用できない
- メニューが出現したときに、ハンバーガーボタン自体はメニューを閉じるボタンに変化する
- 閉じるボタンを押すとメニューは消え、元の状態に戻る

<!-- サイトから借りてきたが、実際にはポンチ絵の想定 -->
![ハンバーガーメニューの例。左側は初期状態、右側はボタンを押してメニューが開いている状態。](../img/4-4-01.png)

ウェブ制作ではおなじみのパーツですが、アクセシビリティ上の留意点がいくつかあります。深く考えずに作られたハンバーガーメニューは、たとえば以下のようなマークアップになっていることがあります。

```html
<div class="hamburgerMenu">
  <div class="button">
    <!-- 閉じている場合にのみ表示され、開くとdisplay:noneになる -->
    <span class="menu-icon"></span>
    <!-- 開いている場合にのみ表示され、閉じるとdisplay:noneになる -->
    <span class="close-icon"></span>
  </div>
  <ul>
    <li><a href="/">ホーム</a></li>
    <!-- メニュー -->
  </ul>
</div>
```

`<div class="button">`がボタンに相当します。中に入っている2つの`span`要素は、それぞれハンバーガーアイコンと閉じるアイコンに相当し、CSSの`background-image`プロパティを使ってアイコン画像を表示しています。マークアップ上は2つのアイコンがありますが、実際にはどちらか片方だけが表示されるように制御し、必要に応じて表示を切り替える想定です。

そして、`div`要素に`click`イベントのイベントハンドラーを付けて動くようにします。

```JavaScript
const hamburgerMenu = document.querySelector('.hamburgerMenu');
const hamburgerMenuButton = hamburgerMenu.querySelector('.button');
hamburgerMenuButton.addEventListener('click', () => {
  hamburgerMenu.classList.toggle('js-opened');
});
```

さまざまなJavaScriptの実装方法が考えられますが、ここでは単純に、外側の`div`要素に`js-opend`クラスを付けたり外したりしています。あとは、CSSで`ul`要素を非表示にし、`js-opened`クラスが付いたときだけ`ul`要素が表示されるようにすれば、ひとまずは完成です。

```CSS
.hamburgerMenu ul{
    display: none;
}
.hamburgerMenu.js-opened ul{
    display: block;
}
/* 実際には別のスタイル定義も必要だが省略 */
```

これでメニューボタンは動作しますが、このメニューにはアクセシビリティ上の問題点が複数あります。ここでは、こうして作られたメニューが既に存在すると仮定して、WAI-ARIAを利用しない方法も含めて、アクセシビリティを向上していく過程の考え方を紹介します。

### キーボード操作を可能にする

このメニューの最大の問題は、キーボード操作ができないことです。メニューボタンは`div`要素で実装されています。`click`イベントを付けているため、マウスでのクリックやタップには反応しますが、キーボード操作ではフォーカスを当てることができません。キーボード操作を可能にする方法はいくつかあります。

#### 方法1 `button`要素を使用する

ここまで何度か触れてきたように、WAI-ARIAを使う前に、まずHTMLのネイティブ機能が使えないか検討すべきです。HTMLにはボタンの機能を提供する`button`要素がありますから、`div`要素を`button`要素に変更します。

```html
<button>
  <span class="menu-icon"></span>
  <span class="close-icon"></span>
</button>
```

たったこれだけでキーボード操作が可能になります。この場合、WAI-ARIAは必要ありませんし、`tabindex`属性も必要ありません。`onclick`イベントによるボタンの動作を実装する必要はありますが、`keypress`イベントを用意してキーボード操作に考慮する必要もありません。`button`要素はそれらの機能を既に備えているからです。

#### 方法2 `a`要素を使用する

お勧めはしませんが、`a`要素でもフォーカスを受け取ることはできます。`a`要素に`role=button`を指定すると、ボタンであると宣言できます。ただし、`role`属性は単に役割を宣言するだけです。`role=button`を指定したからといって、ボタンと同じ挙動になるわけではないことに注意してください。

`a`要素の動作は、`button`要素とは異なります。たとえば、`button`要素ではフォーカスしたあとに<kbd>スペース</kbd>キーでボタンを押すことができますが、`a`要素ではできません。基本的には`button`要素を利用するべきです。

#### 方法3 `div`要素のままキーボード操作できるようにする

まったくお勧めしませんが、何らかの理由で`button`要素も`a`要素も利用できない場合、`div`要素のままキーボード操作を実装する方法もあります。

まずは、フォーカスが当たるように`tabindex="0"`を指定します。そして`role="button"`を指定すると、スクリーンリーダーでも「ボタン」と読み上げられるようになります。

<!-- 望ましくない例 -->
```html
<div class="button" role="button" tabindex="0">
  <span class="menu-icon"></span>
  <span class="close-icon"></span>
</div>
```

さらに、キーボード操作の対応のために`keypress`イベントを付けます。

<!-- 望ましくない例 -->
```JavaScript
hamburgerMenuButton.addEventListener('keypress', event => {
  // Enterキーやスペースキーでボタンが押せ、かつTabキーではボタンが押されないような実装...
});
```

このイベント内では、押されたキーを判定して、<kbd>Enter</kbd>キーや<kbd>スペース</kbd>キーならばボタンが押されるように、かつ<kbd>Tab</kbd>キーなどの操作を横取りしないように実装します。

ただし、繰り返しになりますが、この方法はお勧めしません。複雑で労力がかかる上に、考慮すべきことが多数あり、考慮漏れも生じやすくなります。基本的には`button`要素を使うべきです。

### 何のボタンかわかるようにする

ボタンを`button`要素にすると、スクリーンリーダーを使ってボタンにフォーカスを当てたときに、「ボタン」と読み上げられるようになります。ただし、これだけでは、このボタンが何をするものなのかわかりません。視覚環境であればハンバーガーのアイコンから用途が推察できますが、スクリーンリーダーなどの支援技術のユーザーには、何のボタンかわかりません。

そこで、ボタンにアクセシブルな名前を与えます。たとえば、「メニュー」という名前を与えると、「メニュー ボタン」などと読み上げられて、何をするボタンか理解できるようになります。

ボタンにアクセシブルな名前を与える方法はいくつかあります。

#### 方法1 画像を`img`要素にして`alt`属性でテキストを指定する

最もシンプルな方法は、アイコンをCSSの背景画像で実装することをやめて、`img`要素の`alt`属性で代替テキストを提供することです。「メニュー」や「閉じる」アイコンは、意味を持つ画像コンテンツと考えられます。アクセシビリティの観点から、意味を持つ画像には代替テキストが必要です（WCAG 2.1達成基準1.1.1非テキストコンテンツ[^3]）。

[^3]: <https://www.w3.org/TR/WCAG21/#non-text-content>

アイコンを`img`要素に置き換えると、以下のようになります。

```html
<button>
  <!-- 閉じている場合にのみ表示され、開くとdisplay:noneになる -->
  <span class="menu-icon"><img src="menu.png" alt="メニュー"></span>
  <!-- 開いている場合にのみ表示され、閉じるとdisplay:noneになる -->
  <span class="close-icon"><img src="close.png" alt="閉じる"></span>
</button>
```

こうすると、スクリーンリーダーで読み上げられる上に、通信速度の問題で画像を非表示にしている場合でも「メニュー」というラベルが読めるようになります（実際に代替テキストが表示されるかどうかはブラウザーによります）。

なお、`img`要素を用いるこの方法は、「CSSスプライト」と呼ばれる技法と相性が悪いという問題はあります。最近はCSSスプライトが使われることも少なくなってきましたが、とはいえCSSの背景画像を使う実装を避けられないこともあるでしょう。その場合には他の方法を考えることもできます。

#### 方法2 スクリーンリーダー用テキストを入れる

スクリーンリーダーで読み上げさせる専用のテキストを入れる方法もあります。
基本テクニックの「スクリーンリーダー向けテキストを提供する」で紹介した`visually-hidden`を利用して、以下のようにします。

```html
<button>
  <span class="visually-hidden">メニュー</span>
  <span class="menu-icon"></span>
  <span class="close-icon"></span>
</button>
```

こうすると、`button`要素の中に「メニュー」というテキストがあるため、スクリーンリーダーでは読み上げられます。かつ、このテキストは視覚環境では表示されません。

#### 方法3 `aria-label`属性を利用する

別の選択肢として、`aria-label`属性も利用できます。

```html
<button aria-label="メニュー">
  <span class="menu-icon"></span>
  <span class="close-icon"></span>
</button>
```

このようにすると、`aria-label`属性に対応しているスクリーンリーダーでは「メニュー ボタン」と読み上げられることが期待できます。

しかし、この方法には、CSS無効時にフォールバックテキストが存在しないという問題点があります。ラベルを与えるスマートな方法ではありますが、お勧めはしません。

#### 方法4 `aria-haspopup`属性を利用する

ボタンのラベルとはまた別の方法として、`aria-haspopup`属性を指定する方法もあります。

```html
<button aria-haspopup="menu">
  <span class="menu-icon"></span>
  <span class="close-icon"></span>
</button>
```

こうすると、`aria-haspopup`属性に対応したスクリーンリーダーは「ボタン メニュー ポップアップ」などと読み上げます。メニューがポップアップするボタンであることは伝わるようになります。

ボタンにラベルがある場合は、あわせて読み上げます。たとえば「メニュー」というラベルがあると、「メニュー ボタン メニュー ポップアップ」と読み上げられ、冗長です。ボタンのラベルだけで動作が十分に伝わる場合は、無理に`aria-haspopup`属性を指定しなくてもよいでしょう。

メニューを開くと、このボタンは閉じるボタンに変化します。その際には、javaScriptで`aria-haspopup`属性を削除するか、あるいは`aria-haspopup="false"`に変更する必要があります。閉じるボタンが「メニュー ポップアップ」と読み上げられてしまうと、混乱を招くためです。

なお、もしこのメニューがポップアップではない形で表示されるなら、そもそも`aria-haspopup`属性を使用すべきではありません。

### メニューの開閉状態がわかるようにする

ここまでで、キーボード操作ができ、ボタンも「メニュー ボタン」と読み上げられるようになりました。これで、メニューボタンを利用できる最低限の条件は満たしていますが、問題はまだ残っています。

メニューを開いた際、視覚的には、実際にメニューが開いたことは一目瞭然です。しかし、スクリーンリーダーのユーザーにはメニューが開いたかどうかわかりません。ボタンに「メニュー」というラベルを付けたため、メニューが開いただろうと想像はできるでしょう。しかし、本当にメニューが開いたのか、どこにメニューが現れたのかはわからないのです。

この問題への対応を検討していきましょう。

#### 方法1 開いたメニューにフォーカスを移す

実際にはメニューが開いたことを伝える方法の1つは、開いたメニューにキーボードフォーカスを移してしまうことです。メニューにはフォーカスを受け取ることのできる`a`要素が含まれていますから、先頭の`a`要素にフォーカスを移動します。こうすると、ボタンを押した直後にメニューのリンクの内容を読み上げ始めますから、メニューが開いたことは間違いなく伝わるでしょう。

先のJavaScriptにあったボタンクリック時のイベントに、フォーカス移動の処理を追加します。

```JavaScript
hamburgerMenuButton.addEventListener('click', () => {
  hamburgerMenu.classList.toggle('js-opened');
  hamburgerMenu.querySelector('ul a').focus(); // この行を追加
});
```

この方法はわかりやすい反面、フォーカスを強制的に移動させてしまう点に注意が必要です。フォーカス移動が予測できない場合、ユーザーを混乱させることがあります。

なお、WCAG 2.1の達成基準 3.2.5 要求による変化[^5]では、フォーカス移動のようなコンテキストの変化は、ユーザーの要求によってだけ生じるようにすることが望ましいとされています。この例では、ユーザーが「メニュー」というボタンを押すことによってフォーカスが移動しますから、この達成基準に抵触することはありません。

[^5]: <https://waic.jp/docs/WCAG21/#change-on-request>

また、移動元と移動先が離れている場合、戻り方がわかりにくいという問題があります。メニューボタンを押したあと、ユーザーは<kbd>Shift+Tab</kbd>キーでフォーカスを戻そうとするかもしれません。フォーカス移動先がHTMLのDOMツリー上で離れた位置にあると、<kbd>Shift+Tab</kbd>キーの操作では元に戻れない場合があります。出現するメニューは、メニューボタンの直後に置くことが望ましいでしょう。

#### 方法2 ボタンのラベルで状態を伝える

フォーカスを移さずに、ボタンのラベルで現在の状態を伝える方法もあります。たとえば、メニューを開いたときに、JavaScriptでボタンのラベルを「メニューを閉じる」に変更します。ボタンを再度読み上げさせれば「メニューを閉じる ボタン」と読み上げられますから、現在メニューが開いている（だから閉じることができる）と推測できるようになるでしょう。

```html
<button>
  <!-- 閉じている場合にのみ表示され、開くとdisplay:noneになる -->
  <span class="menu-icon"><img src="menu.png" alt="メニュー"></span>

  <!-- 開いている場合にのみ表示され、閉じるとdisplay:noneになる -->
  <span class="close-icon"><img src="close.png" alt="メニューを閉じる"></span>
</button>
```

ただし、これだけでは開いたメニューがページ内のどこに存在するかはわかりません。ボタンから離れた場所にメニューが出現すると、メニューを探し出してたどり着かなければなりません。この場合も、出現するメニューはメニューボタンの直後に置くことが望ましいでしょう。

#### 方法3 `aria-expanded`属性を利用する

WAI-ARIAには開閉状態を通知する`aria-expanded`属性があります。メニューが開いたとき、`button`要素に`aria-expanded=true`を追加するようにします。

```html
<button aria-expanded="true">
```

こうすると「メニュー ボタン 開いています」などと読み上げます。同様に、`aria-expanded=false`を指定すると「メニュー ボタン 閉じています」などと読み上げます（「隠されました」などと読み上げるものもあります）。

`aria-haspopup`と同様、ボタンのラベルとあわせて読み上げることに注意してください。メニューが既に開いていて、ボタンのラベルが「メニューを閉じる」となっている場合、`aria-expanded=true`を指定すると、「メニューを閉じる ボタン 開いています」と読み上げられます。これは冗長ですし、むしろ混乱を招くことがあります。

初期状態では`aria-expanded`属性を付けないようにしておき、開いたときだけ`aria-expanded=true`を付ける方法もあります。この場合、メニューが閉じているときは「メニュー ボタン」と読み上げられ、開いているときは「メニュー ボタン 開いています」と読み上げられるようになります。ボタンのラベルや他のARIA属性も合わせた状態で実際に読み上げさせて、ボタンの挙動が伝わるかどうかを考えて用いるとよいでしょう。

なお、この方法も、開いたメニューがページ内のどこに存在するかはわかりません。`aria-controls`属性で制御対象を明示する方法もありますが、`aria-controls`属性に対応している支援技術はほとんどありません。この場合も、出現するメニューはメニューボタンの直後に置くことが望ましいでしょう。

### メニューの裏側にフォーカスが当たらないようにする

メニューを開いたとき、視覚環境ではメニューがコンテンツに覆いかぶさり、メニューに隠れてコンテンツが画面では見えない状態になります。

キーボード操作の場合、メニューが開いた状態でも背後のコンテンツにフォーカスを移せてしまう場合があります。メニューの裏側の要素にフォーカスが移ると、視覚環境のキーボードユーザーはフォーカスを見失い、混乱することがあります[^99]。

[^99]: スクリーンリーダーのユーザーの場合は、メニューが開きっぱなしでコンテンツが見えていなくても、そのことに気づかず、普通にコンテンツを利用できてしまうことが多いでしょう。

このような問題を避ける方法を検討します。

#### 方法1 メニューの外の要素をすべてフォーカス不可能にする

メニューが開いたときに、メニューの外の要素をすべてフォーカス不可能にするという方法です。実装方法は複数存在します。

- メニューの外側のフォーカス可能な要素すべてに`tabindex=-1`を指定する
- メニューの外側の要素すべてを`display: none;`や`visibility: hidden`などで削除する
- メニューを`dialog`要素として実装し、`showModal()`メソッドで呼び出す

詳細な実装方法はここでは説明しません。`dialog`要素についてはChapter3-10を参照してください。

なお、`aria-hidden`属性はこの目的には利用できないことに注意してください。`aria-hidden`属性を指定してもフォーカス移動には影響しません。スクリーンリーダーのユーザーは読み上げられない要素にフォーカスを奪われて混乱することになります。

#### 方法2 メニューの最後の要素からフォーカスを移動するとき、メニューの先頭に戻す

メニューからフォーカスが外に出るのは、メニューの最後の要素からさらにフォーカスを移動しようとしたときです。そのタイミングで<kbd>Tab</kbd>キーの挙動をフックして、メニューの先頭に戻してしまえば、フォーカスはメニューの外に出られなくなります。このテクニックはフォーカストラップとも呼ばれます。

フォーカストラップを実現する方法の1つは、メニューの最後の要素からフォーカスが離れようとする際に処理することです。JavaScriptで`keypress`イベントを付けておき、<kbd>Tab</kbd>キーが押されたらメニューの先頭の要素にフォーカスが戻るようにします。

もう1つの方法は、メニューの前後にフォーカスを受け取る要素を配置し、そこで処理することです。たとえば、`tabindex`属性を指定した`div`要素を挿入します。

```html
<div tabindex="0"></div>
  <ul id="menu01">
      <li><a href="/">ホーム</a></li>
      <!-- メニュー -->
  </ul>
<div tabindex="0"></div>
```

キーボード操作でメニューの外にフォーカスを移動しようとすると、この`div`要素にフォーカスが当たります。`focus`イベントを付けておき、フォーカスが当たったときにフォーカスをメニューの先頭、もしくは末尾に移動します。

いずれの場合も、フォーカスが脱出不能にならないように気を付けてください。メニューを閉じるボタンが押せなくなると、キーボードを使ってフォーカスが外せなくなるWCAG 2.1達成基準2.1.2キーボードトラップの問題となってしまいます。また、ユーザーはブラウザーのアドレスバーにフォーカスしたい場合、<kbd>Shift+Tab</kbd>キーで戻ることもあります。先頭の要素から前に戻ろうとすることは許容してもよいでしょう。

なお、スクリーンリーダーのユーザーは<kbd>Tab</kbd>キーを使用せずにフォーカスを移動できる場合もあります。また、フォーカスを移動せずに外の要素を読み上げる場合もあります。そのため、フォーカスを制御しきれない場合がありますが、スクリーンリーダーのユーザーは視覚的にフォーカスを見失っても困ることはないので、そこまで気にしないという考え方もあるでしょう。

#### 方法3 メニュー末尾からフォーカス移動しようとした場合、メニューを自動的に閉じる

上記と似ていますが、フォーカスをメニューの先頭に戻すのではなく、メニューを閉じることで解決します。メニューの最後の要素に`keypress`イベントを付けるか、フォーカスを受け取る要素を配置して、メニューの外にフォーカスが出ようとしたときにメニューを閉じるようにします。

メニューを閉じたときには、フォーカスを適切な場所に移動する必要があります。メニュー項目にフォーカスしたままメニューが閉じると、フォーカスが行方不明になってしまうためです。通常は、メニューを開く直前にフォーカスがあった場所、すなわちメニューボタンにフォーカスを戻すとよいでしょう。

ただしこの方法では、メニューが閉じることをユーザーが推測できない場合があります。意図せずにメニューが閉じてしまうと、ユーザーは混乱することがあります。メニューが閉じてしまった後に<kbd>Shift+Tab</kbd>キーを押しても、直前のメニュー項目に戻ることができません。

意図せずにメニューが閉じても、開くボタンにフォーカスがあるため、再度メニューを開くことは容易です。ただし、その際にはまたメニュー項目を先頭から見ていくことになります。メニューが長い場合には、ユーザーが大きなストレスを感じることもあるでしょう。

## 事例2. カルーセルのライブラリーを選定する

「カルーセル」（Carousel）とは、回転木馬、メリーゴーランドの意味です。ウェブでは、画像やカードなどが横に並び、左右にスライドして順繰りに表示されるようなコンポーネントを指します。スライドショーと呼ばれたり、イメージローテーターと呼ばれることもあります。

```text
--+ +---+ +--
1 | | 2 | | 3
--+ +---+ +--
```

図4-4-02 左右のスライドが見切れているカルーセルの例

カルーセルにはさまざまなバリエーションがありますが、一般的には以下の機能を持ちます。

- 複数の「スライド」(slide)を持ち、順番に表示できる。スライドには画像やカードなど、視覚的に提示される項目が含まれる
- 1度に表示するスライドは1つだけ（ただし、左右に見切れた状態で前後のスライドが表示されることはある）
- ユーザーの操作により、次のスライド、前のスライドを表示させることができる。多くの場合、カルーセル領域の左右に矢印状のボタンが表示される
- 表示されているスライドをクリックすると、そのスライドに対応するリンク先へ遷移する

また、これらに加えて以下の機能を持つケースも見られます。

- スライドの全体枚数と、現在の表示が何枚目かを示すインジケータを持つ。これは「スライドピッカーコントロール」(Slide Picker Controls)と呼ばれる。インジケータ部分をクリックすると、対応するスライドを直接表示させることもできる。多くの場合、カルーセル領域の下部に、円が横に並んだ形で表示される
- ページが読み込まれると同時に、自動的にカルーセルの回転が始まる
- スライドにマウスポインターが乗った場合や、キーボードフォーカスが移った場合に、カルーセルの自動回転を停止する
- カルーセルの自動回転を停止・再開できる機能を持つ。これは「ローテーションコントロール」(Rotation Control)と呼ばれる。多くの場合、オーディオ機器の一時停止・再生ボタンを模したボタンで表現される

このように、カルーセルは多数の機能を持つ複雑なものです。これらすべてを自前で実装するのは大変です。実際には、カルーセルを扱う専用のライブラリーを利用するケースが多いでしょう。カルーセルのライブラリーにはさまざまなものがあり、アクセシビリティに配慮したものも、そうでないものもあります。

ここでは、ライブラリー選定時に注意するポイントを見ていきましょう。もし、
すべてを自前で実装する必要がある場合は、WAI-ARIA Authoring Practicesの3.6 Carousel (Slide Show or Image Rotator)[^7]やWeb Accessibility TutorialsのCarousel[^8]を参考にするとよいでしょう。

[^7]: <https://www.w3.org/TR/wai-aria-practices/#carousel>

[^8]: <https://www.w3.org/WAI/tutorials/carousels/>

### キーボード操作が可能か

カルーセルもキーボードで操作できなければなりません。ライブラリー選定時には、動作サンプルをキーボードで実際に操作してみましょう。特に注意したいのは以下の点です。

- 現在表示されているスライドにフォーカスし、リンクを辿ることができるか
- 隠れているスライドにフォーカスが当たってしまい、フォーカスが行方不明になることはないか
- 次のスライド/前のスライドボタンにフォーカスし、操作できるか
- スライドピッカーコントロールにフォーカスし、操作できるか
- ローテーションコントロールにフォーカスし、操作できるか

キーボードフォーカスが見えず、事実上操作できないケースもよく見かけます。フォーカスが明確に見えるかどうかも確認しましょう。

#### フォーカス時に自動停止するか

カルーセルが自動回転する場合、スライドにフォーカスを移したタイミングでスライドが動くと、フォーカスが行方不明になります。そのため、多くのカルーセル実装では、スライドがフォーカスを受け取ると自動回転を止めます。

同様に、マウスポインターがスライドに乗ったときも自動回転を止めることが一般的です。クリックしようとした瞬間にスライドが切り替わると、意図しない遷移先に移動してしまうためです。このような停止が行われるか確認しましょう。

### スクリーンリーダーで操作できるか

視覚環境だけでなく、スクリーンリーダーで問題なく操作できるかどうかを確認しましょう。

- 現在表示されているスライドが適切に読み上げられるか
- 各種のボタンにラベルが付けられているか
- 隠れているスライドが読み上げられて混乱することはないか

実装方法によっては、隠れているスライドまで読み上げてしまうことがあります。スライドの内容によっては大きな問題がないケースもありますが、場合によっては混乱を招くことがあります。

自前で実装する場合は、隠れているスライドに`aria-hidden`属性を適用するのも1つの方法です。ただし、`aria-hidden`属性だけではキーボードフォーカスが当たってしまうことに注意してください。

#### 他の箇所の読み上げを妨害しないか

カルーセルが自動回転する場合は、他の箇所を読み上げている際の挙動に注意が必要です。ライブラリーの中には、カルーセル領域をライブリージョンとして実装するものがあります。たとえば、Slick[^9]というライブラリーの古いバージョンは、以下のように`aria-live="polite"`を使用していました。

[^9]: <https://kenwheeler.github.io/slick/>

```html
<div aria-live="polite" class="slick-list draggable">
  <!-- カルーセル領域 -->
</div>
```

この場合、カルーセルのスライドが切り替わる都度、内容が読み上げられます。カルーセルを手動で操作したときは問題ありませんが、ユーザーが他の場所を読んでいる際にカルーセルが自動回転すると、その内容が読み上げられます。

`aria-live=polite`は、即時に割り込むのではなく、読み上げが一段落してから割り込む指定ですが、問題がないわけではありません。たとえば、見出しを読み上げているときにカルーセルが切り替わると、見出しのテキストを読み上げた後、続けてカルーセルの内容を読み上げます。これは一続きの内容であるように聞こえ、ユーザーを混乱させることになります。

カルーセルにライブリージョンを採用しているライブラリーを使わざるを得ない場合、スライドのテキストを工夫するとよいでしょう。たとえば、頭に「【広告】」と入れれば、本文の一部ではないことが明確にわかります。

カルーセルを自前で実装する場合、ライブリージョンを使う必要があるかどうかは慎重に検討してください。どうしても利用する必要がある場合は、ユーザーがカルーセル領域から離れたときに`aria-live=off`に切り替えるか、カルーセルの自動回転を止めるとよいでしょう。

### ローテーションコントロールがあるか

ローテーションコントロールは、自動回転するカルーセルを停止する機能です。WCAG 2.1達成基準2.2.2一時停止、停止、非表示[^10]では、動き続けるコンテンツを停止できることが求められています。これはレベルAの要求で、「非干渉」の条件でもある重要な基準です。WCAGに対応する場合は、この基準を必ず満たさなければなりません。

[^10]: <https://www.w3.org/TR/WCAG21/#pause-stop-hide>

カルーセルが自動回転する場合、ローテーションコントロールが提供されていること、それがアクセシブルであることを確認しましょう。

## 事例3. タブのマークアップを検討する

「タブ」(Tabs)は、複数のコンテンツを切り替えて表示する機能です。コンテンツが入る「タブパネル」(Tab Panel)を複数持っており、その表示を切り替えるための「タブ」(Tab)を持ちます。タブは、「タブリスト」(Tab List)としてグループ化されます。

![](../img/4-4-03.png)

図4-4-03 タブの例（WAI-ARIA Authoring Practicesより）

タブは以下のような機能を持ちます。

- 複数のタブとタブパネルから構成される。タブとタブパネルは1対1対応している
- タブリスト内のすべてのタブは見えている状態になっており、初期状態ではいずれか1つのタブが選択されている
- 選択されているタブに対応したタブパネルが表示されている。他のタブパネルは見えない
- 他のタブをクリックすると、そのタブが選択状態になり、選択したタブに対応するタブパネルが表示される。他のタブパネルは表示されなくなる

タブがキーボード操作を受け付ける場合、以下のような操作が一般的です。

- タブリストにフォーカスを移すと、選択されているタブがアクティブになる
- キーボードの左右キーを押すと、左右にある他のタブを選択する

キーボードの左右キーによる操作は、他のウェブコンポーネントではあまり見られませんが、OSが提供するタブコントロールの操作に合わせたものです。

ウェブコンテンツでは、タブのような見せ方は頻繁に使われます。実際に現場でマークアップを行う機会も多いでしょう。ここでは、タブのマークアップについていくつかのパターンを検討しながら、考え方の過程を見ていきます。

### タブのマークアップと実装

WAI-ARIAの基本はネイティブの機能を利用することですが、残念ながら、HTMLにはタブに対応するネイティブ要素がありません。一方、WAI-ARIAは、タブの部品に対応するロールを用意しています。

- タブ：`tab`
- タブリスト：`tablist`
- タブパネル：`tabpanel`

タブの実装ではこれらのロールを利用することになりますが、HTMLのどの要素を使うべきでしょうか。ここでは、実際にどのようなマークアップにするべきか検討していきましょう。

#### タブ

タブは、ユーザーが操作するインタラクティブな要素です。タブをクリックすれば、タブパネルが切り替わります。また、キーボードフォーカスを受け取る必要もありますから、フォーカス可能な要素を使うべきでしょう。WAI-ARIA Authoring Practicesのタブの例[^11]では`button`要素を使用していますが、`a`要素が使われることもあります。

[^11]: <https://www.w3.org/TR/wai-aria-practices/#tabpanel>

タブが3つある場合、たとえば以下のようなマークアップになります。ただし、`aria-selected`属性と`tabindex`属性はJavaScriptで動的に付けられている想定です。

```html
<button type="button" role="tab" id="tab01" aria-controls="tabpanel01"
 aria-selected="true">タブその1</button>
<button type="button" role="tab" id="tab02" aria-controls="tabpanel02"
 aria-selected="false" tabindex="-1">タブその2</button>
<button type="button" role="tab" id="tab03" aria-controls="tabpanel03"
 aria-selected="false" tabindex="-1">タブその3</button>
```

タブには `aria-controls`属性を指定して、このタブに対応するタブパネルを示しています。一部のスクリーンリーダーでは、対応するタブパネルへジャンプできるようになります。

`id`属性を指定しておくと、タブのラベルを`aria-labelledby`属性で参照できるようになります。後述のタブパネルで利用します。

また、JavaScriptで以下の属性を付けます。これらの値は、タブが切り替わったときに動的に変化する想定です。

- `aria-selected`属性 : このタブが現在選択されているかどうかを示します。選択されているタブには"true"を、そうでないタブには"false"を指定します。
- `tabindex`属性 : 選択されていないタブに `tabindex=-1` を指定します。前述のように、キーボード操作ではタブにフォーカスしてから左右キーでタブを切り替える想定となるため、選択されていないタブには直接フォーカスが当たらないようにします。

タブには、必ずアクセシブルな名前を付けてください。上記の例のように、`button`要素の中にテキストが入っていれば問題ありません。テキストを持たせられない場合、タブパネルに含まれている見出しにIDを付けて`aria-labelledby`属性で参照してもよいでしょう。

#### タブリスト

タブリストは、タブが列挙される部分です。`tablist`ロールを適用しますが、どのHTML要素を採用するかは議論の余地があります。

ARIA in HTMLでは、`menu`、`ol`、`ul`、`nav`要素に`tablist`ロールが適用できることになっています。ほかにも、すべてのロール（Any role）が適用可能とされている要素には`tablist`ロールを適用できますので、`p`要素や`div`要素などが候補になります。なお、`dl`要素には`tablist`ロールを指定できないため、候補になりません。

タブリストにはタブが複数列挙されますし、名前に「リスト」と付いていますから、`ul`要素は有力候補です。しかし、WAI-ARIAの`tablist`ロールは`list`ロールと派生関係になく、`listitem`ロールの親にはなれません。`ul`要素のロールを`tablist`に変更すると、`li`要素の`listitem`ロールが破綻を起こすことになります。`li`要素に`tab`ロールを指定すればロールの矛盾はなくなりますが、先に述べたように、`tab`ロールは`button`要素か`a`要素に指定したほうがよいでしょう。そうすると、`li`要素には`role="none presentation"`を指定することになります。

`ul`要素を使っても、結局はリストの意味を失わせることになりますので、最初から`div`要素を使うという考え方も有力です。実際、WAI-ARIA Authoring Practicesのタブの例では`div`要素を使用しています。どちらが正解というわけでもなく、前後の文脈や互換性など、周辺の事情を考えて採用しましょう。後述の「タブと他の見せ方を切り替える」も参照してください。

#### タブパネル

タブパネルは実際に表示される内容を含む部分で、`tabpanel`ロールを適用します。

`tabpanel`ロールは、ARIA in HTMLでは`section`要素に適用可能とされています<!--[^1]-->。そのほか、任意のロールを適用可能な要素で利用できますが、さまざまな要素が入る可能性を考えると`p`要素などは使いにくく、事実上`section`要素と`div`要素のどちらかになるでしょう。タブパネルの中に見出しが入ってセクションとして成立しているならば`section`要素、そうでなければ`div`要素を利用するのがよいでしょう。WAI-ARIA Authoring Practicesのタブの例では`div`要素を使用しています。
<!--
[^1]: 当初のARIA in HTMLでは`section`要素に`tabpanel`ロールを指定することは許されていませんでしたが、2016年11月の更新で可能となりました。
-->

タブパネルはたとえば以下のようなマークアップになります。

```html
<div tabindex="0" role="tabpanel" id="tabpanel01" aria-labelledby="tab01">
<!-- タブパネルの内容 -->
</div>
<div tabindex="0" role="tabpanel" id="tabpanel02" aria-labelledby="tab02" hidden>
<!-- タブパネルの内容 -->
</div>
<div tabindex="0" role="tabpanel" id="tabpanel03" aria-labelledby="tab03" hidden>
<!-- タブパネルの内容 -->
</div>
```

タブから`aria-controls`属性で参照するために、`id`属性を指定しています。

タブパネルにはアクセシブルな名前が必要です[^99]。通常は、タブのラベルをそのまま使えるはずですので、タブにIDを付けて`aria-labelledby`属性で参照するとよいでしょう。タブパネルの中に見出しが含まれる場合は、見出しにIDを付けて参照してもよいでしょう。

[^99]: WAI-ARIA 1.2のRoles Supporting Name from Authorにおいて、`tabpanel`ロールは名前が必須 (name required) とされています。 <https://www.w3.org/TR/wai-aria-1.2/#namefromauthor>

表示されていないタブパネルは、JavaScriptで`hidden`属性を指定して非表示にします。CSSの`display:none`を適用しても問題ありません。

通常、`aria-hidden`属性を利用する必要はありません。非表示のタブパネルは、視覚環境からも隠されるべきものです。表示の演出上の都合など、何らかの理由で`display:none`を適用できず、非表示のタブパネルがスクリーンリーダーで読み上げられてしまう場合は、`aria-hidden`属性の利用を検討してもよいでしょう。

#### JavaScript実装

これでマークアップは完成です。あとは、JavaScriptを実装して動作するようにします。

具体的なコード例はWAI-ARIA Authoring Practicesに譲りますが、タブがクリックされた場合だけでなく、タブにフォーカスしたときのキーボード操作も忘れずに実装してください。`keypress`イベントではカーソルキーの操作を取得できないので、`keydown`イベントと`keyup`イベントを利用します。

### レスポンシブデザインでタブの見せ方を切り替える

タブインターフェイスを導入する大きな目的の1つは、画面スペースの節約です。タブ操作によって表示を切り替える仕組みを導入することで、狭いスペース内で多くの情報を見せることができるようになります。

画面スペースがある時には、タブ以外の見せ方をしたくなるかもしれません。レスポンシブデザインを採用して、画面が狭い場合にはタブで表現し、広い場合にはすべてを展開して見せたいと考えることもあるでしょう。

以下のマークアップは、単なるページ内リンクの目次です。

```html
<ul>
  <li><a href="#section01">セクション1</a></li>
  <li><a href="#section02">セクション2</a></li>
  <li><a href="#section03">セクション3</a></li>
</ul>
<section>
  <h2 id="section01">セクション1</h1>
  <p>セクション1の内容...</p>
</section>
<section>
  <h2 id="section02">セクション2</h1>
  <p>セクション2の内容...</p>
</section>
<section>
  <h2 id="section03">セクション3</h1>
  <p>セクション2の内容...</p>
</section>
```

このような目次の構造は、タブに対応させることができます。目次のリストがタブリストに、目次内の個々のリンクがタブに、リンク先のセクションがタブパネルに対応します。先のマークアップに対し、JavaScriptで`role`属性を付与すると以下のようになります。

```html
<ul role="tablist">
  <li role="none"><a role="tab" href="#section01">セクション1</a></li>
  <li role="none"><a role="tab" href="#section02">セクション2</a></li>
  <li role="none"><a role="tab" href="#section03">セクション3</a></li>
</ul>
<section role="tabpanel" aria-labelledby="section01">
  <h2 id="section01">セクション1</h1>
  <p>セクション1の内容...</p>
</section>
<section role="tabpanel" aria-labelledby="section02">
  <h2 id="section02">セクション2</h1>
  <p>セクション2の内容...</p>
</section>
<section role="tabpanel" aria-labelledby="section03">
  <h2 id="section03">セクション3</h1>
  <p>セクション2の内容...</p>
</section>
```

ほかにも細かい属性やイベントを付ける必要がありますが、タブとして成立することはわかるでしょう。このようにすると、状況によってページ内リンクの見せ方とタブの見せ方とを切り替えることが可能になります。また、JavaScriptが動作しない環境でも、ページ内リンクとして成立します。

#### タブの操作方法をあえて実装しない選択

上記の例ではページ内リンクをタブの見せ方にするだけでなく、タブ関連のロールと機能を適用して、実際にタブとして動作させることを想定しています。

タブになると、キーボードでの操作方法は変化します。ページ内リンクだった場合は、<kbd>Tab</kbd>キーでリンクに次々とフォーカスしていき、希望のリンクを選択するという方法でした。タブになると、現在選択されているタブにフォーカスし、左右キーでタブを選ぶという方法になります。

この操作方法の変更は本当に必要でしょうか。見せ方だけ変えて、操作もロールも変えず、そのままページ内リンクとして操作させるという考え方もあります。

タブを提供するコンテンツがウェブアプリケーションである場合は、デスクトップアプリケーションと同じ操作感にするため、タブとして操作できたほうがよいでしょう。そうではなく、単に省スペースを目的としてタブの見せ方にしているだけならば、ページ内リンクの操作方法で問題ないことが多いでしょう。

ただし、リンクをクリックした場合の挙動には注意してください。ページ内リンクの場合、基本の動作としては、リンクをクリックすると該当箇所までスクロールし、明確に画面が変化します。しかし、タブの見せ方にした場合、リンクを押しても画面がスクロールしない場合があります。画面を拡大しているユーザーの場合、タブの部分を画面いっぱいに拡大していると、その外で起きた変化に気づかず、何が起きたかわからないことがあります。リンクを押したときに、対応する見出しにフォーカスを移すなどして対応するとよいでしょう。

## 事例4. モーダルダイアログ

「ダイアログ」(dialog)は、ウェブコンテンツの上に覆いかぶさるように出現するウィンドウ領域です。ユーザーに対して注意を促したり、何かを入力させるために用います。ダイアログには、大きく分けて2つのモードがあります。

- 「モーダルダイアログ」(modal dialog): ダイアログが出現するとダイアログに対して操作を行うモードになり、その間、ダイアログ以外の要素を操作できなくなるもの
- 「モードレスダイアログ」(modeless dialog): ダイアログが出ても他のコンテンツを引き続き操作できるもの

モーダルダイアログの場合、他のコンテンツが操作できないことがわかるように、ダイアログの外を暗くする演出が一般的です。

![](../img/4-4-04.png)

図4-4-04 モーダルダイアログのイメージ図

ウェブではモードレスダイアログはあまり利用されません。他のコンテンツを引き続き操作できる場合、ダイアログではない見せ方をすることが多いでしょう。モーダルダイアログはしばしば利用されます。ここでは、モーダルダイアログの実装についていくつかの方法をとりあげ、内容を見ていくことにします。

### `window.confirm()`メソッドによる簡易なダイアログ

簡易なダイアログであれば、JavaScriptの機能だけで簡単に実装できます。`window.confirm()`メソッドを利用すると、ユーザーにOKかキャンセルかの2択を問うモーダルダイアログを出すことができます。以下は、フォームをリセットする場合に警告のダイアログを出す例です。

```html
<form onreset="return confirm('フォームの内容をすべて初期化します。よろしいですか?')">
  <input value="初期値">
  <button>送信</button>
  <button type="reset">リセット</button>
</form>
```

これはたとえば以下のように表示されます。

![スクリーンショット: Chromeのconfirmダイアログ](../img/4-4-05.png)

ユーザーがキャンセルボタンを押した場合は`confirm()`の戻り値が`false`となり、`return false`が実行されてリセットの動作がキャンセルされます。Chapter4-1のイベントハンドラー属性も参照してください。

このダイアログはブラウザーの機能でできているため、見た目を制御できません。ブラウザーによっても異なりますが、シンプルで事務的な見た目になります。簡潔にYes/Noを問うだけでよい場合は、これでも十分でしょう。

### `dialog`要素によるダイアログ

HTMLには、ダイアログを表示するための`dialog`要素が用意されています。`showModal()`メソッドを呼ぶと、モーダルダイアログとして表示されます。
詳細とコード例はChapter3-10の`dialog`要素を参照してください。

`dialog`要素を適切に利用すると、それだけで、モーダルダイアログの外にある要素を暗く表示し、操作できないようにすることまで実現できます。`dialog`要素にはダイアログとしてのネイティブのセマンティクスもあるため、`role`属性も不要です。

なお、初期状態でダイアログを隠す処理も実現されていますが、単にユーザーエージェントのスタイルシートに`dialog:not([open]){display:none;}`というスタイルがあるだけです。より強いセレクターで`display`プロパティを上書きすると、ダイアログが表示されてしまうので注意してください。

`dialog`要素は便利ですが、2021年10月時点で、ブラウザーによるサポートは不十分です。

### WAI-ARIAを駆使した実装

`dialog`要素をサポートしないブラウザーを想定すると、他の要素とWAI-ARIAを組み合わせて自前でダイアログを実装することが現実的になります。ダイアログのマークアップは、たとえば以下のようになります。

<!-- https://w3c.github.io/aria-practices/examples/dialog-modal/dialog.html のサンプルのうち、4番目のダイアログを少しシンプルにして、DOM操作で追加される要素を入れたたもの -->
```html
<div id="dialog_layer" class="dialogs">
  <div tabindex="0"></div>
  <div id="dialog4" class="dialog"
    role="dialog"
    aria-labelledby="dialog_label"
    aria-describedby="dialog_desc"
    aria-modal="true">
    <h2 id="dialog_label">ダイアログの見出し</h2>
    <p id="dialog_desc">
      ダイアログのメッセージ...
    </p>
    <!-- その他さまざまな中身が入る -->
    <button type="button"
      id="dialog_close_button">
      <img src="close.png" alt="閉じる">
    </button>
  </div>
  <div tabindex="0"></div>
</div>
```

`div`要素に`dialog`ロールを指定して、ダイアログであることを示します。ダイアログが警告やエラーを表示する場合は、代わりに`alertdialog`ロールを指定します。

ダイアログにはアクセシブルな名前が必要です[^99]。多くの場合、ダイアログの内部には見出しがあるため、`aria-labelledby`属性で関連づけるとよいでしょう。見出しがない場合は、`aria-label`属性を利用します。

[^99]: WAI-ARIA1.1ではラベルを与えるべき (SHOULD) であるとされ、WAI-ARIA 1.2ではアクセシブルな名前を提供しなければならない (MUST) とされています。いずれにしても名前は付けるべきです。 <https://www.w3.org/TR/wai-aria-1.2/#dialog>

また、`aria-describedby`属性でメッセージを提供しています。これにより、ダイアログにフォーカスすると、スクリーンリーダーで見出しとメッセージが読み上げられるようになります。

`aria-modal="true"`により、このダイアログがモーダルであることを示しています。`aria-modal`属性に対応した支援技術の場合、これだけでモーダルの外の要素を操作できないようにする場合があります。とはいえ、この処理は仕様上必須とはされておらず、対応していない支援技術もあるため、モーダルダイアログの外の要素が読み上げられないようにしたり、キーボードフォーカスを制御する処理の実装も必要です。
<!--
When a modal element is displayed, assistive technologies SHOULD navigate to the element unless focus has explicitly been set elsewhere. Assistive technologies MAY limit navigation to the modal element's contents. If focus moves to an element outside the modal element, assistive technologies SHOULD NOT limit navigation to the modal element.
-->

キーボードフォーカスの制御のために、ダイアログの前後に`<div tabindex="0"></div>`を挿入しています。これは、ハンバーガーメニューの事例で紹介したフォーカストラップのテクニックです。先に挙げたコード例では直接HTMLとして書かれていますが、実際にはJavaScriptによるDOM操作で`div`要素を挿入し、`focus`イベントを付けてフォーカスを制御します。

モーダルダイアログの内部には、閉じるボタンを置きます。`aria-modal`属性を指定するとダイアログの外側にアクセスできなくなることがあるため、ダイアログを開いたボタンをトグルさせたい場合は、ボタンが必ずダイアログの内部に来るように配慮してください。また、<kbd>Esc</kbd>キーが押されたときにダイアログが閉じるようにしておくとよいでしょう。

あとはJavaScriptで動作を制御するだけですが、コードは長くなるため、ここでは紹介しません。具体的なJavaScriptのコードやその他の細部については、WAI-ARIA Authoring Practicesのdialogの例[^13]を参考にしてください。

[^13]: <https://www.w3.org/TR/wai-aria-practices/examples/dialog-modal/dialog.html>

## テストを行う

ここまで、WAI-ARIAを利用する事例を紹介してきました。HTMLだけでアクセシビリティを担保できない場合に、WAI-ARIAを利用することで、アクセシビリティを向上できることがあります。

しかし、常にWAI-ARIAを利用することがよいわけではありません。Chapter4-2でも紹介したように、WAI-ARIA Authoring Practicesでは"No ARIA is better than Bad ARIA"という警句を掲げています[^17]。ARIAを不適切に利用するくらいなら、使わないほうがよいということです。

[^17]: <https://www.w3.org/TR/wai-aria-practices/#no_aria_better_bad_aria>

これは、ARIAの不適切な利用が多いということでもあります。このChapterでも見てきたように、WAI-ARIA以外の手段がよいケースや、WAI-ARIAを使わなくても十分に伝わ流ケース、WAI-ARIAがむしろ冗長になるケースがあります。

WAI-ARIAの利用が適切かどうか、どうやって判断すればよいのでしょうか。筆者は、実際に動作検証をすることが重要だと考えています。Chapter4-2でも触れたように、実際にスクリーンリーダーなどの支援技術を用いてアクセスすることは難しくありません。

このChapterで触れたような複雑な事例では、ユーザビリティの観点も重要になります。実際にユーザーに触れてもらい、テストを行うことが、より重要になってくるでしょう。
