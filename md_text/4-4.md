# WAI-ARIAの実践と活用
<!-- class="hidden" のかわりに aria-hiden="true" を使ったらどうかという話。4ページも書くことがあるのかは謎。-->

4-2節ではWAI-ARIAと関連仕様についてとりあげました。この節では、実際によく使われる部品を取り上げ、アクセシビリティを向上する方法や、その際の検討事項について解説します。より詳しい具体的な実践例については、WAI-ARIA Authoring Practices[^1]を参照すると良いでしょう。

[^1]: <https://www.w3.org/TR/wai-aria-practices/>

## ハンバーガーメニュー

ボタンを押すとメニューが開く、というのはよくあるウィジェットです。特にモバイル用のページでは、メニューボタンに三本の横棒のアイコンがよく利用され、その形状から「ハンバーガーメニュー」と呼ばれます。一般的なハンバーガーメニューは、以下のような機能を持ちます。

- ユーザーがボタンを押すと、メニューが出現する
- メニューにはサイト内の主要なコンテンツへのリンクが含まれる
- メニューはコンテンツに覆いかぶさるような形で現れ、メニューが開いている間はメニューの外のコンテンツは利用できない
- メニューが出現した際、ハンバーガーボタン自体はメニューを閉じるボタンに変化する
- 閉じるボタンを押すとメニューは消え、元の状態に戻る

<!-- サイトから借りてきたが、実際にはポンチ絵の想定 -->
![ハンバーガーメニューの例。左側は初期状態、右側はボタンを押してメニューが開いている状態。](../img/4-4-01.png)

ウェブ制作者にとってはおなじみのパーツですが、アクセシビリティ上の留意点がいくつかあります。深く考えずに作られたハンバーガーメニューは、たとえば以下のようなマークアップになっていることがあります。

```html
<div class="hamburgerMenu">
  <div class="button">
    <span class="menu-icon"></span>
    <span class="close-icon"></span>
  </div>
  <ul>
      <li><a href="/">ホーム</a></li>
      <!-- メニュー -->
  </ul>
</div>
```

`<div class="button">`がボタンに相当します。中に入っている2つの`span`要素は、それぞれハンバーガーアイコンと閉じるアイコンに相当し、CSSの`background-image`を使ってアイコン画像を表示します。そして、`div`に`click`イベントをつけて動くようにします。

```JavaScript
const hamburgerMenu = document.querySelector('.hamburgerMenu');
const hamburgerMenuButton = hamburgerMenu.querySelector('.button');
hamburgerMenuButton.addEventListener('click', event => {
    hamburgerMenu.classList.toggle('js-opened');
});
```

JavaScriptの実装方法はいろいろ考えられますが、ここでは単純に、外側の`div`要素に`js-opend`クラスをつけたり外したりするようにしました。あとは、CSSで`ul`を非表示にし、`js-opened`クラスがついたときだけ`ul`が表示されるようにすれば、ひとまずは完成です。

これでメニューボタンはいちおう動作しますが、このメニューには致命的な問題点があります。

### キーボード操作を可能にする

このメニューの最大の問題は、キーボード操作ができないということです。メニューボタンは`div`要素で実装されています。`click`イベントをつけたのでマウスクリックには反応しますが、キーボードではそもそもフォーカスを当てることができず、このボタンを押すことができないのです。

キーボード操作は、WCAG 2.1の達成基準2.1.1 Keyboard [^2] でも要求されている重要事項です。まずはこれを行えるようにする必要があります。

[^2]: <https://www.w3.org/TR/WCAG21/#keyboard>

#### `div`をキーボード操作できるように……

この`div`にフォーカスが当たるようにするために、`tabindex=0`を指定します。そして`role=button`を指定すると、スクリーンリーダーでも「ボタン」と読まれるようになります。

<!-- 望ましくない例 -->
```html
<div class="button" role="button" tabindex="0">
  <span class="menu-icon"></span>
  <span class="close-icon"></span>
</div>
```

さらに、キーボード操作に対応するためには`keypress`イベントをつける必要もあります。

<!-- 望ましくない例 -->
```JavaScript
hamburgerMenuButton.addEventListener('keypress', event => {
  // Enterキーやスペースキーでボタンが押せ、かつTabキーではボタンが押されないような実装...
});
```

このイベント内では、押されたキーを判定して、Enterキーやスペースキーならばボタンが押されるように、かつTabキーなどの操作を横取りしないように実装します。

この方法は全くお勧めできません。複雑で労力がかかる上、考慮すべきことも多数あります。他の方法を考えるべきです。

#### `button`要素を使用する

WAI-ARIAを使う上で最も重要なことは、WAI-ARIAを使わないことです。HTMLにはボタンの機能を提供する`button`要素があるのですから、ここでは`button`要素を使うべきです。

```html
<button>
  <span class="menu-icon"></span>
  <span class="close-icon"></span>
</button>
```

これだけでキーボード操作が可能になります。`role`属性も`tabindek`属性も`keypress`イベントも必要ありません。`button`要素はそれらの機能を既に備えているからです。

これでキーボード操作はできるようになりましたが、まだ問題は残っています。

### 何のボタンかわかるようにする

ボタンを`button`要素にしたことで、ボタンにフォーカスが当たるようになりました。スクリーンリーダーを使ってボタンにフォーカスを当てると「ボタン」と読まれますが、いったい何のボタンなのかは分かりません。視覚環境ではボタンにハンバーガーのアイコンが付けられていることがわかりますが、スクリーンリーダーでは何のボタンなのかわからないのです。

これは、ボタンにラベルとなるテキストが含まれていないことが原因です。ラベルを与えて、「メニュー ボタン」と読まれるようにしてみましょう。ボタンにラベルを与える方法はいくつかあります。

#### 画像を`img`要素にして`alt`でテキストを指定する

ひとつは、`button`要素の中にラベルとなるテキストを追加する方法です。最もシンプルな方法は、CSSの背景画像を使うのをやめてしまい、`img`要素で画像を指定して`alt`属性にテキストを入れる方法です。

```html
<button>
  <span class="menu-icon"><img src="menu.png" alt="メニュー"></span>
  <span class="close-icon"></span>
</button>
```

この方法は「CSSスプライト」と呼ばれる技法と相性が悪いという問題はあります。最近はCSSスプライトが使われることも少なくなってきましたが、とはいえCSSの背景画像を使うという実装を避けられないということもあるでしょう。その場合には他の方法を考えることもできます。

#### スクリーンリーダー用テキストを入れる

スクリーンリーダーで読ませる専用のテキストを入れる方法もあります。

```html
<button>
  <span class="visually-hidden">メニュー</span>
  <span class="menu-icon"></span>
  <span class="close-icon"></span>
</button>
```

`visually-hidden`は、視覚環境で表示されず、かつスクリーンリーダーでは読まれるようなスタイルを定義したクラスです。CSSフレームワークは、このようなクラスをあらかじめ用意していることがあります (クラス名は異なる場合があり、他に`sr-only`などが使われることもあります)。たとえば、Bootstrap 5.0のvisually-hidden[^4]には、以下のようなスタイルが定義されています。

[^4]: <https://github.com/twbs/bootstrap/blob/main/scss/mixins/_visually-hidden.scss>

```css
.visually-hidden {
  position: absolute !important;
  width: 1px !important;
  height: 1px !important;
  padding: 0 !important;
  margin: -1px !important;
  overflow: hidden !important;
  clip: rect(0, 0, 0, 0) !important;
  white-space: nowrap !important;
  border: 0 !important;
}
```

こうしておくと、テキストはスクリーンリーダーで読まれ、かつ視覚環境には影響を与えません。

#### `aria-label`を利用する

別の選択肢として、我らが`aria-label`属性も利用できます。

```html
<button aria-label="メニュー">
  <span class="menu-icon"></span>
  <span class="close-icon"></span>
</button>
```

このようにすると、`aria-label`に対応しているスクリーンのリーダーでは「メニュー ボタン」と読まれることが期待できます。

他にも、`aria-labelledby`属性や`label`要素を利用する方法も考えられますが、これらは不可視のラベルを与えるのには向きません。どこかに見えているラベルがある場合は、これらの方法を検討すると良いでしょう。なお、ボタンの外にあるテキストを`label`要素として結び付けた場合、ラベルテキストをクリックしてもボタンが反応するようになるので注意してください。

#### `aria-haspopup`を利用する

ボタンのラベルとはまた別の軸として、`aria-haspopup`属性を指定する方法もあります。

```html
<button aria-haspopup="menu">
```

このようにすると、`aria-haspopup`に対応したスクリーンリーダーでは「ボタン メニュー ポップアップ」などと読まれます。これにより、たとえラベルがなくても、メニューがポップアップするボタンであることは伝わるようになります。

ボタンにラベルがある場合は、それもあわせて読まれます。たとえば「メニュー」というラベルがある場合、「メニュー ボタン メニュー ポップアップ」と読まれることになります。これはやや冗長になりますので、ボタンのラベルだけで動作が十分に伝わる場合は、`aria-haspopup`をあえて指定しないという考え方もあります。

メニューを開いた際に、このボタンがメニューを閉じるボタンに変化するのであれば、その際には`aria-haspopup`属性を削除するようにしましょう。メニューを閉じるボタンが「メニュー ポップアップ」と読まれると混乱を招いてしまいます。

### メニューの開閉状態が分かるようにする

ここまでで、キーボード操作ができ、ボタンも「メニュー ボタン」と読まれるようになったので、メニューボタンを利用できる最低限の条件は満たすことができました。ただし、まだ軽微な問題は残っています。

ひとつは、メニューが開いたことが分からない点です。「メニュー ボタン」と読まれるボタンを押したとき、視覚環境ではメニューが開いたことが分かりますが、スクリーンリーダーではそのことが伝わりません。

今回の例では、ボタンに「メニュー」というラベルをつけましたから、おそらくメニューが開くだろうと想像することはできるかもしれません。しかし、実際にどういう変化が起きたかはわからないのです。ボタンをもう一度読ませても「メニュー ボタン」と読まれるだけですし、何度押しても状況は変わりません。

ここには問題が2つあります。

- どこが変化したかわからない (どこにメニューが開いたのか、どうやってそこにたどり着けるのかがわからない)
- 現在の状態がわからない (今メニューが開いているのか、閉じているのかがわからない)

これを改善する方法を考えていきましょう。

#### 開いたメニューにフォーカスを移す

メニューを開いたことが最大限にダイレクトに伝わる方法は、開いたメニューにフォーカスを移してしまうことです。こうすると、ボタンを押した直後にメニューのリンクの内容を読み始めますから、メニューが開いたことは間違いなく伝わるでしょう。

メニューにはフォーカスを受け取ることのできる`a`要素が含まれていますから、先頭の`a`要素にフォーカスを移動します。先のスクリプトにあったボタンクリック時のイベントに、フォーカス移動の処理を追加します。

```JavaScript
hamburgerMenuButton.addEventListener('click', event => {
    hamburgerMenu.classList.toggle('js-opened');
    hamburgerMenu.querySelector('ul a').focus(); // ← これを追加 
});
```

この方法はわかりやすい反面、フォーカスを強制的に移動させてしまう点には注意が必要です。フォーカス移動が予測できなかったり、移動元と移動先が離れていて戻り方がわかりにくいような場合、ユーザーを混乱させることがあります。この例では、「メニュー」というボタンを押すと直後のメニューに移動するという挙動ですから、大きな問題はないでしょう。

#### ボタンのラベルで状態を伝える

ボタンのラベルを変更することで現在の状態を伝えるという方法もあります。たとえば、メニューを開いた際にボタンのラベルも「メニューを閉じる」に変更すれば、現在メニューが開いていること (そして、このボタンを押すとメニューが閉じるということ) が伝わるようになるでしょう。

```html
<button>
  <span class="menu-icon"><img src="menu.png" alt="メニュー"></span>
  <span class="close-icon"><img src="close.png" alt="メニューを閉じる"></span>
</button>
```

ただし、これだけではどこでメニューが開いているのかはわかりません。直後にメニューがある場合は大きな問題はありませんが、メニューと離れている場合には、メニューまで移動する方法も考える必要があるでしょう。

#### `aria-expanded`を利用する

WAI-ARIAには開閉状態を通知するための属性があります。`button`要素に`aria-expanded`属性を指定することで、現在の状態を通知することができます。メニューが開いた状態になったときに`aria-expanded=true`を追加するようにします。

```html
<button aria-expanded="true">
```

こうすると「メニュー ボタン 開いています」などと読まれます (スクリーンリーダーによって読まれ方は異なります。「拡大」などと読むものもあります)。

同様に、`aria-expanded=false`を指定すると「メニュー ボタン 閉じています」などと読まれます (「隠されました」などと読むものもあります)。ただし、この例の場合には、「メニュー ボタン」と読まれるだけで、これからメニューが開くであろうことは十分に予想できかもしれません。

ボタンのラベルだけで挙動が十分に伝わる場合は、あえて`aria-expanded`を指定しない方が簡潔になる場合もあります。たとえば、メニューが開いた時にボタンのラベル自体を変更して「メニューを閉じる」としている場合、「メニューを閉じる ボタン 開いています」と読まれなくても、「メニューを閉じる ボタン」だけで伝わるでしょう。

初期状態では何もつけず、開いた時だけ`aria-expanded=true`をつけるという方法もあります。たとえば、ボタンのラベルが「メニュー」のとき、閉じている時は「メニュー ボタン」と読まれ、開いている時は「メニュー ボタン 開いています」と読まれれば、それでも伝わるでしょう。

ボタンのラベルや他のARIA属性も合わせた状態で実際に読んでみて、ボタンの挙動が伝わるかどうかを考えて用いるとよいでしょう。

#### `aria-controls`を利用する

WAI-ARIAには、制御対象の要素を伝え、そこに移動する手段を提供するための属性があります。`button`要素に`aria-controls`属性を指定し、制御対象となるメニューのIDを指定します。

```html
<div class="hamburgerMenu">
  <button aria-controls="menu01">
    <span class="menu-icon"><img src="menu.png" alt="メニュー"></span>
  </button>
  <ul id="menu01">
      <li><a href="/">ホーム</a></li>
      <!-- メニュー -->
  </ul>
</div>
```

`aria-controls`に対応しているスクリーンリーダーは、制御対象に移動できる機能を提供することがあります。たとえばJAWSの場合、このボタンを「メニュー ボタン」と読んだ後、“use JAWS key+ALT+M to move to controlled element”と読みます。<!--編集注: これは数年前の状況。当時は対応しているのがJAWSのみで、中根さんに当時のJAWS日本語版での読み上げ内容を確認してもらったところ、このように英語で読むということだった。最新版の挙動や他の支援技術の挙動を要確認-->指示に従ってキー操作すると、メニューの`ul`要素に移動し、メニュー内のリンクを読んでいくことができます。ただし、移動した後に元のボタンに戻ってくる方法はありません。

`aria-controls`属性を指定するのは悪いことではありませんが、全てのスクリーンリーダーが問題なく対応できていると考えるべきではありません。開いたメニューに移動する手段と、このボタンに戻ってくる手段について、別途考えておくほうが良いでしょう。対象の要素をこのボタンと隣接させることが最善の対応策ですが、それができない場合、先に紹介したように、ボタンを押した際に対象にフォーカスを移動してしまうというのも一つの方法です。

### メニューの裏側にフォーカスが当たらないようにする

メニューを開いた際、視覚環境ではメニューがコンテンツに覆いかぶさり、コンテンツ側の操作ができなくなるケースが多いでしょう。

しかしキーボード操作の場合、メニューが開いた状態でも背後のコンテンツにフォーカスを移せてしまう場合があります。メニューの裏側の要素にフォーカスが移ると、視覚環境のキーボードユーザーはフォーカスを見失い、混乱することがあります (なお、スクリーンリーダーのユーザーの場合、メニューが開きっぱなしであることに気づかず、普通に利用できてしまうことが多いでしょう)。

これを避ける方法はいくつかあります。

#### メニューの外の要素を全てフォーカス不可能にする

メニューが開いた際、メニューの外の要素を全てフォーカス不可能にするという方法です。実装方法はまたいくつかに別れます。

- メニューの外側のフォーカス可能な要素全てに`tabindex=-1`を指定する
- メニューの外側の要素全てを`display: none;`や`visibility: hidden`などで削除する
- メニューを`dialog`要素として実装し、`showModal()`メソッドで呼び出す

詳細な実装方法はここでは説明しません。`dialog`要素については`dialog`要素の項を参照してください。

なお、`aria-hidden`は利用できないことに注意してください。`aria-hidden`を指定してもフォーカス移動には影響しません。スクリーンリーダーのユーザーは読まれない要素にフォーカスを奪われて混乱することになります。

#### メニューの最後の要素からフォーカス移動するとき、メニューの先頭に戻す

メニューからフォーカスが外に出るのは、メニューの最後の要素からさらにフォーカス移動しようとした時です。そのタイミングで`Tab`キーの挙動をフックして、メニューの先頭に戻してしまえば、フォーカスはメニューの外に出られなくなます。メニューの最後の要素に`keypress`イベントをつけて、`Tab`キーが押された時にメニューの先頭の要素にフォーカスが戻るようにします。

フォーカスが永遠に脱出不能にならないように気をつけてください。メニューを閉じるボタンが押せなくなると詰んでしまいます。また、ユーザーはブラウザのアドレスバーにフォーカスしたい場合に`Shift`+`Tab`を連打して戻ろうとすることもあります。先頭の要素から前に戻ろうとすることは許容する方が良いでしょう。

また、スクリーンリーダーのユーザーは外に出られる場合があることに注意してください。スクリーンリーダーではフォーカスを移動せずに後ろの要素を読むことができますし、`Tab`キーを使用しないフォーカス移動方法もあるため、外に出られてしまいます。もっとも、スクリーンリーダーのユーザーは視覚的にフォーカスを見失っても困ることはないので、特に気にしないという考え方もあります。

#### メニュー末尾からフォーカス移動しようとした場合、メニューを自動的に閉じる

上記と似ていますが、フォーカスをメニューの先頭に戻すのではなく、メニューを閉じることで解決します。メニューの最後の要素に`keypress`イベントをつけ、`Tab`キーが押された時にメニューを閉じるようにします。

メニューを閉じた際には、フォーカスを移動させる必要もあります。メニュー項目にフォーカスしたままメニューが閉じると、フォーカスが行方不明になってしまうため、見えているどこかにフォーカスを移動させる必要があります。

ユーザーにとって予想外の場所にフォーカスが移動すると、フォーカスを見失って混乱することがあるので注意してください。WCAG 2.1の達成基準2.4.3 Focus Order[^3]でも、脈絡のないフォーカス移動は避けるように求められています。

[^3]: <https://www.w3.org/TR/WCAG21/#focus-order>

メニューを閉じた際は、メニューを開く直前にフォーカスがあった場所、すなわちメニューボタンにフォーカスを戻すと良いでしょう。ユーザーが意図せずにメニューを閉じてしまった場合でも、開くボタンにフォーカスがあれば、またすぐに開くことができます。


## カルーセル

「カルーセル」（Carousel）とは、回転木馬、メリーゴーランドの意味です。Webでは、画像やカードなどが横に並び、左右にスライドして順繰りに表示されるようなコンポーネントを指します。スライドショーと呼ばれたり、イメージローテーターと呼ばれることもあります。

```
--+ +---+ +--
1 | | 2 | | 3
--+ +---+ +--

```
図4-4-02 左右のスライドが見切れているカルーセルの例

カルーセルにはさまざまなパターンが見られますが、一般的には以下のような機能を持ちます。

- 複数の「スライド」(slide)を持ち、順番に表示することができる。スライドには画像やカードなど、視覚的に提示される項目が含まれる。
- 1度に表示するスライドは1つだけ (ただし、左右に見切れた状態で前後のスライドが表示されることはある)
- ユーザーの操作により、次のスライド、前のスライドを表示させることができる。多くの場合、カルーセル領域の左右に矢印状のボタンが表示される
- 表示されているスライドをクリックすると、そのスライドに対応するリンク先に遷移する。スライドによってリンク先は異なる

また、これらに加えて以下の機能を持つケースも多く見られます。

- 「スライドピッカーコントロール」(Slide Picker Controls)を持つ。これはスライドが全部で何枚あり、現在表示中のものが何番目かを示すインジケータであり、インジケータ部分をクリックすると、対応するスライドを直接表示させることもできる。多くの場合、カルーセル領域の上部か下部に、円が横に並んだ形で表示される
- ユーザーが操作しなくても、ページが読み込まれると自動的にカルーセルの回転が始まる
- スライドにマウスポインタが乗った場合や、キーボードフォーカスが移った場合にも、カルーセルの自動回転を停止する
- 「ローテーションコントロール」(Rotation Control)を持つ。これは、カルーセルの自動回転を停止/再開できる機能で、多くの場合、オーディオ機器の一時停止/再生ボタンを模したボタンで表現される

こうしてみると、カルーセルの仕組みは非常に複雑で、多数の機能を持つことがわかります。これら全てを自前で実装するのはかなり大変ですから、専用のライブラリを利用するケースが多いでしょう。ここでは、ライブラリを選定する際の観点として、アクセシビリティ上の注意点をいくつか述べることにします。

もしすべてを自前で実装する必要がある場合は、WAI-ARIA Authoring Practicesの3.6 Carousel (Slide Show or Image Rotator)[^4]を参考にすると良いでしょう。

[^4]: <https://w3c.github.io/aria-practices/#carousel>

### キーボード操作が可能か

カルーセルもキーボードで操作できなければなりません。ライブラリ選定時には、動作サンプルをキーボードで実際に操作してみると良いでしょう。特に問題になりやすいのは以下の点です。

- 現在表示されているスライドにフォーカスし、リンクを辿ることができるか
- 隠れているスライドにフォーカスがあたってしまい、フォーカスが行方不明になることはないか
- 次のスライド/前のスライドボタンにフォーカスし、操作できるか
- スライドピッカーコントロールにフォーカスし、操作できるか
- ローテーションコントロールにフォーカスし、操作できるか

キーボードフォーカスが見えなくなっていて事実上操作できないケースもよく見かけますので、あわせて注意しましょう。

また、現在表示されているスライドにフォーカスが移った際、カルーセルが自動回転するとフォーカスが行方不明になることがあります。これを防ぐため、多くのカルーセル実装では、スライドにフォーカスした際に自動回転を止めるようにしています。同様に、マウスポインタがスライドに乗った際にも自動回転を止めることが一般的です。これは、スライドをクリックしようとした瞬間にスライドが切り替わると、意図しない遷移先に移動して混乱するためです。

### スクリーンリーダーで操作できるか

視覚環境だけでなく、スクリーンリーダーで問題なく操作できるかどうかを確認しましょう。

- 現在表示されているスライドが適切に読まれるか
- 各種のボタンにラベルが付けられているか
- 隠れているスライドが読まれて混乱することはないか

実装方法によっては、隠れているスライドがスクリーンリーダーで読まれることがあります。それが問題ないケースもあるかもしれませんが、混乱を招くこともあるので注意しましょう。自前で実装する場合は、隠れているスライドに`aria-hidden`を適用するのも一つの方法です。ただし、`aria-hidden`だけではキーボードフォーカスは当たってしまうことに注意が必要です。

### 他の箇所の読み上げを妨害しないか

カルーセルとスクリーンリーダーの読み上げに関しては、一つ重要な事項があります。それは、他の箇所を読んでいる際に自動回転が起きた時、読み上げを邪魔することがないかという点です。

カルーセルのライブラリの中には、カルーセル領域をライブリージョンとして実装しているものがあります。たとえば、Slick[^6]というライブラリの古いバージョンでは、以下のようにカルーセル領域に`aria-live="polite"`を指定していました。

[^6]: <https://kenwheeler.github.io/slick/>

```html
<div aria-live="polite" class="slick-list draggable">
```

カルーセル内のスライドが切り替わると、切り替わった内容が読み上げられることになります。カルーセルを手動で操作した場合に読まれるのは問題ありませんが、ユーザーが他の場所を読んでいるときにカルーセルが自動回転すると、読み上げが一段落したところでカルーセルの内容が読み上げられることになります。

ライブリージョンが読まれる際、多くのスクリーンリーダーでは、単に内容がそのまま読まれます。現在の場所と異なる場所が読まれたということはわかりませんので、たとえば、見出しを読んでいる際にカルーセルが切り替わると、見出しのテキストに続けてそのままカルーセルの内容が読まれ、一続きの内容であるように聞こえます。文脈と関係のない読み上げが挟まってくるため、これはユーザーを大いに混乱させることになります。

自前で実装する場合、カルーセルにライブリージョンを使う必要があるかどうかは慎重に検討してください。どうしても利用する必要がある場合は、ユーザーがカルーセル領域から離れた際に`aria-live=off`に切り替えるか、カルーセルの自動回転を止めるようにすると良いでしょう。

### ローテーションコントロールがあるか

ローテーションコントロールは、自動回転するカルーセルを停止する機能です。自動でスライドが切り替わり続けるカルーセルは多く見られますが、その一方で、スライドを停止す機能が提供されないことがあります。

WCAG 2.1の達成基準2.2.2 Pause, Stop, Hide[^4]は、動き続けるコンテンツが停止できることを求めています。これはレベルAの要求で、「非干渉」の条件にもなっている重要な基準ですので、WCAGへの対応が求められる場合には必ず満たさなければなりません。

[^4]: <https://www.w3.org/TR/WCAG21/#pause-stop-hide>


## タブ

「タブ」(Tabs)は、複数のコンテンツを切り替えて表示する機能です。典型的には、パーツ一式の上部に「タブリスト」(Tab List)があり、下部にコンテンツが入る「タブパネル」(Tab Panel)があります。タブリストの中には「タブ」(Tab)が並び、いずれかのタブを選択すると、タブパネルが対応するものに切り替わります。

![](../img/4-4-03.png)

図4-4-03 タブの例 (WAI-ARIA Authoring Practiceより)

タブは以下のような機能を持ちます。

- 複数のタブとタブパネルから構成される。タブとタブパネルは一対一対応している。
- タブリスト内の全てのタブは見えている状態になっており、初期状態ではいずれか一つのタブが選択されている
- タブパネルは、選択されているタブに対応したものだけが表示され、他のタブパネルは見えない
- 他のタブをクリックすると、そのタブが選択状態になり、選択したタブに対応するタブパネルが表示される。他のタブパネルは表示されなくなる。

タブがキーボード操作を受け付ける場合、以下のような操作になるのが一般的です。

- タブリストにフォーカスを移すと、選択されているタブがアクティブになる
- キーボードの左右キーを押すと、左右にある他のタブを選択することができる

キーボードの左右キーによる操作は、他のWebコンポーネントではあまり見られない、独自のものとなっています。これは、OSが提供するタブコントロールの操作に合わせたものです。

### タブのマークアップ

HTMLにはタブを表現する要素がありませんが、WAI-ARIAでは、タブの部品に対応するロールが用意されています。

- タブ : tab
- タブリスト : tablist
- タブパネル : tabpanel

各部品にこれらのロールを適用していくのですが、実際にどのようなマークアップにするべきか検討していきましよう。

#### タブ

タブはユーザーの操作の対象となる要素です。タブをクリックしたとき、タブパネルが切り替わるようにする必要があります。また、キーボードフォーカスを受け取る必要もあります。これらの機能を全て自前で実装することも不可能ではありませんが、お勧めしません。フォーカスを受け取れる要素、`a`要素か`button`要素のいずれかを使うべきでしょう。WAI-ARIA Authoring Practiceのタブの例[^6]では`button`要素を使用していますが、`a`要素が使われることもあります。

[^6]: <https://w3c.github.io/aria-practices/#tabpanel>

さらに、以下のARIA属性を追加するとよいでしょう。

- `aria-controls`属性 : このタブに対応するタブパネルを示します。
- `aria-selected`属性 : このタブが現在選択されているかどうかを示します。タブが選択されていれば"true"、そうでなけば"false"になるようにします。

タブが3つあるとするなら、たとえば以下のようなマークアップになります。

```html
<button type="button" role="tab" aria-selected="true" aria-controls="tabpanel01" id="tab01">タブその1</button>
<button type="button" role="tab" aria-selected="false" aria-controls="tabpanel02" id="tab02">タブその2</button>
<button type="button" role="tab" aria-selected="false" aria-controls="tabpanel03" id="tab03">タブその3</button>
```

タブにラベルがついていることを確認してください。通常は、要素の中にそのままラベルテキストを入れれば問題ありません。もし、タブにテキストを持たせられないような場合は、`aria-label`でラベルを与えることを検討しましょう。タブパネルに見出しが含まれており、その見出しのテキストをそのままタブのラベルにできるならば、その見出しを`aria-labelledby`で参照しても良いでしょう。

#### タブリスト

タブリストは、タブが列挙される部分です。`tablist`ロールを適用しますが、どのHTML要素を採用するかは議論の余地があります。

タブが複数列挙されますし、名前に「リスト」とついていますから、これをリストと考えて`ul`でマークアップするという考え方もあります。しかし、WAI-ARIAの`tablist`ロールは`list`ロールとは派生関係になく、子孫に`listitem`ロールを持ちません。そのため、`ul`要素に`role=tablist`を指定すると、`li`要素の`listitem`ロールが宙に浮いてしまうことになります。結局、`li`には`role=presentation`を指定することになります (指定しなくても、ブラウザーによって同等の意味の`role=generic`に上書きされることがあります)。

`ul`を使っても、結局はリストとしての意味を失わせることになりますので、最初から`div`を使うという考え方もあるでしょう。WAI-ARIA Authoring Practiceのタブの例では`div`要素を使用しています。

必要に応じて、`aria-label`を用いてラベルを与えても良いでしょう。文脈によっては、タブリストに含まれるタブが何であるのか、どのような情報を切り替えるのかが伝わらない場合もあります。前後の文脈から十分に伝わるようであれば、`aria-label`は指定しなくてもよいでしょう。




```html
<div class="tabs">
  <div role="tablist" aria-label="Entertainment">
    <button type="button" role="tab" aria-selected="true" aria-controls="nils-tab" id="nils">Nils Frahm</button>
    <button type="button" role="tab" aria-selected="false" aria-controls="agnes-tab" id="agnes" tabindex="-1">Agnes Obel</button>
    <button type="button" role="tab" aria-selected="false" aria-controls="complex-complex" id="complex" tabindex="-1" data-deletable="">Joke</button>
  </div>

  <div tabindex="0" role="tabpanel" id="nils-tab" aria-labelledby="nils">
    <p>Nils Frahm is a German musician, composer and record producer based in Berlin. He is known for combining classical and electronic music and for an unconventional approach to the piano in which he mixes a grand piano, upright piano, Roland Juno-60, Rhodes piano, drum machine, and Moog Taurus.</p>
  </div>

  <div tabindex="0" role="tabpanel" id="agnes-tab" aria-labelledby="agnes" class="is-hidden">
    <p>Agnes Caroline Thaarup Obel is a Danish singer/songwriter. Her first album, Philharmonics, was released by PIAS Recordings on 4 October 2010 in Europe. Philharmonics was certified gold in June 2011 by the Belgian Entertainment Association (BEA) for sales of 10,000 Copies.</p>
  </div>

  <div tabindex="0" role="tabpanel" id="complex-complex" aria-labelledby="complex" class="is-hidden">
    <p>Fear of complicated buildings:</p>
    <p>A complex complex complex.</p>
  </div>
</div>
```

タブに`tab`ロールを付与し、複数のタブを`tablist`ロールを持つ要素でグループ化します。選択しているアクティブなタブは`aria-selected="true"`とし、選択していないタブについては属性値`false`を与えます。

アクティブでないタブに`tabindex="-1"`を与え、各タブパネルに`tabindex="0"`を与えることで、<kbd>Tab</kbd>キーでの移動はアクティブなタブから関連付けられたタブパネル間となります。これにより、タブ間の移動は左右の矢印キーを用いることになります。

タブとタブパネルの関連付けは`aria-controls`属性と`id`属性を用いています。また、`aria-labelledby`でタブパネルに対する名前を提供します。アクティブでないタブパネルについては`hidden`属性で非表示にしています。


### モーダルダイアログ

モーダルダイアログは、メインコンテンツの上に重ねられて表示されるダイアログです。ダイアログが表示されている間、言い換えるとダイアログを閉じるまで、メインコンテンツは無効になります。

<!--
https://www.w3.org/TR/wai-aria-practices/#dialog_modal
https://www.w3.org/TR/wai-aria-practices/examples/dialog-modal/dialog.html
https://qiita.com/ishimasar/items/47f29b958946a2c53e93

http://www.tohoho-web.com/bootstrap/modal.html
-->

![](../img/4-4-04.png)

図4-4-04 モーダルダイアログのイメージ図


```html
<div role="dialog" aria-labelledby="modal-label" aria-modal="true">
  <div class="modal-header">
    <h5 id="modal-label">Modal title</h5>
    <button type="button" aria-label="Close">
      <span aria-hidden="true">×</span>
    </button>
  </div>
  <div class="modal-body">
    Modal body
  </div>
  <div class="modal-footer">
    <button type="button">Close</button>
    <button type="button">OK</button>
  </div>
</div>
```

`dialog`ロールは、ダイアログコンテナ要素に対して付与し、ダイアログであることを表します。`aria-modal="true"`により、モーダルであることを表します。

このモーダルの名前は、`aria-labelledby`属性により、見出しで提供されます。

モーダルダイアログの右上にある「Close」ボタンは、テキストの「×」として提供されています。そのため、「×」自身は`aria-hidden`属性で無視させ、`aria-label`属性でボタンのラベルを提供しています。


### 画像をインラインSVGで表す

HTMLに直接インラインでSVGを記述したい、という場面も珍しくないでしょう。その場合、WAI-ARIAを付与する必要が出てきます。

`svg`要素はSVG 2仕様によれば`graphics-document`というロール[^5]を持っていることになります。これは端的に言えば、文書である`document`ロールの性質も持っているという位置付けになります。そのため、通常の画像として扱いたい場合は`img`ロールを付与します。

[^5]: <https://www.w3.org/TR/SVG2/struct.html#implicit-aria-semantics>

意味のある画像については、代替テキストを（SVGの）`title`要素で与えます。

```html
<svg role="img">
  <title>代替テキスト</title>
  ...
</svg>
```

`aria-describedby`で明示的に`svg`要素と`title`要素を結びつける方法がありますが、仕様上[^6]はそのようにする必要はありません。

[^6] <https://www.w3.org/TR/svg-aam-1.0/#mapping_additional>

```html
<!-- 冗長な例 -->
<svg role="img" aria-describedby="svgdesc">
  <title id="svgdesc">代替テキスト</title>
  ...
</svg>
```

画像が意味を持たない純粋に装飾的な画像である場合は、支援技術に無視させればよく、`aria-hidden`属性を用います。この場合、支援技術に何も伝えないため、`role`属性を指定する必要はありません。

```html
<svg aria-hidden="true">
  <!-- 純粋に装飾的な画像 -->
  ...
</svg>
```

#### 画像にありがちなアクセシビリティの問題

画像を`img`要素で表す場合は、代替テキストについては単に`alt`を考えるだけでよいのですが、前述のインラインSVGのように`img`要素でない方法で画像を表す場合、代替テキストを用意することを考える必要があります。

`alt`による代替テキストは、何らかの原因で画像が読み込めなかったときに、ブラウザー上で画像の代わりに表示されるという特性があります。代替テキストを提供する場合は、この特性と同等の挙動を実現する必要があります。

<!-- 4-3に移動すべきか？ -->

例えば、font awesomeのようなフォントアイコンで、`aria-label`属性で代替テキストの代わりにする実装を見かけることがありますが、`aria-label`はラベルであって代替テキストではありません。画面上に見えないラベルであるため、`alt`と同じ挙動にはなりません。

```html
<!-- 好ましくない実装例 -->
<i class="..." aria-label="開く"></i>
```

このような手法は既存サイトの緊急避難的な改修の場合に留め、新規にサイトを構築する際は避けることが望ましいです。