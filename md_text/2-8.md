# HTMLの細かい文法

これまでにマークアップの基本となるタグの書き方について説明しました。通常のウェブ制作では先の知識で十分ですが、主にセキュリティの観点から、通常はしないようなマークアップがどのように解釈されるのかという議論が必要となることがあります。
ここでは、タグの書き方についてもう一歩踏み込んだところを説明します。

## 細かい文法ルールを知りたいときは

HTMLを解釈するHTMLのパーサーのルールは仕様で明確に定められています。仕様の"Parsing HTML documents"の節[^1]では、ある状況で特定の文字が出現した場合にどのように解釈するのか、というレベルまで挙動が規定されています。「このような書き方は可能か？」「このように書いた場合にどのように解釈されるのか？」という疑問は、ほとんどの場合、仕様をつぶさに読むことで解決できます。

[^1]: Parsing HTML documents <https://html.spec.whatwg.org/multipage/parsing.html>

この節では、豆知識としてその一部を紹介します。

## タグ名に使用できる文字

コメントの節でも触れましたが、HTMLのタグ名はASCII英字で始まる必要があり、数字で始まることは許されません。以下は正しくない例です。

```html
<42>
```

このようなマークアップはエラー[^2]となり、タグではなくテキストとして解釈されます。つまり、以下のようなマークアップと同じ結果になります。

[^2]: invalid-first-character-of-tag-name parse error

```html
&lt;42>
```

これは1文字目だけの制限で、2文字目以降には数字を使用することはできます。実際に`h1`のようなタグ名が使用されているのはご存知のとおりです。

文法上、2文字目以降は数字だけでなく、記号類も使用できます。利用できない文字はわずかしかありません。

- `>` → タグの終了と解釈されます
- 空白類文字 (スペース、タブ、改行など) → 属性値との区切りと解釈されます
- `/` → 自己終了タグもしくは属性値との区切りと解釈されます

面白いことに、タグの開始のマークである`<`も利用できる文字となっており、タグ名の一部として解釈されます。以下のようなマークアップがあったとします。

```html
<body>
<h1<span>test</span></h1>
</body>
```

これは、`<h1>`タグの`>`が抜けた形ですが、エラー処理によって以下のように補われます。

```html
<body>
<h1<span>test</h1<span>
</body>
```

つまり、単純に`h1<span`という名前の要素があるものとみなされます。`</h1>`と`</span>`には対応する開始タグがないため無視され、`</body>`の前に`</h1<span>`という終了タグが補われます。

タグ名に`<`を含めることができるのは、SGMLやXMLとは互換性のない挙動です。SGMLでは、上記は「閉じない開始タグ」(unclosed start tag)とみなされ、`<h1><span>`と補われていました。HTML5ではそのような挙動にならないので注意が必要です。なお、XML構文の場合にはWell-formedではないため、パースエラーとなります。

セキュリティの観点からは、`/`の扱いについて注意が必要です。以下のようなマークアップは、HTMLの仕様としては不正です。

```html
<span/onmouseover="alert(1)">test</span>
```

これはエラー[^3]となるのですが、`<`の場合と異なり、`/`はタグ名の一部とはみなされません。エラー処理の際は、`/`のあとが属性名とみなされます。結果として、これは以下のようなマークアップと等価になります。

[^3]: unexpected-solidus-in-tag parse error

```html
<span onmouseover="alert(1)">test</span>
```

つまり、`onmouseover`属性が有効に機能することになります。タグ内に空白を挿入できなくても、属性を挿入することができる点に注意が必要です。

## 終了タグに属性は書けない

終了タグに属性を書くことはできません。

```html
<p>foo</p class="foo">
```

このように終了タグに属性を書いた場合、エラー[^4]となり、属性は無視されます。終了タグ自体は有効に機能します。

[^4]: end-tag-with-attributes parse error

## 終了タグ末尾の /

終了タグの末尾に`/`を書くことはできません。

```html
<p>foo</p/>
```

この場合、エラー[^5]となり、単に`/`が無視されます。終了タグ自体は有効に機能します。

[^5]: end-tag-with-trailing-solidus parse error

## 空タグ

SGMLでは「空タグ」(empty tag)と呼ばれる記述が許されており、理論上はHTML4でも使用することができました (対応しているブラウザが存在するかどうかはともかく)。文字通り空のタグ、タグ名部分を省略したタグで、空の開始タグ、空の終了タグがあります。たとえば以下のようなものです。

```html
<p>テキスト</>
<>テキスト</>
```

空タグは、最も直近に開いた要素の名前を参照します。上記の例では、`<>`と`</>`は、それぞれ`<p>`と`</p>`の省略とみなされます。

しかし、このような空タグはHTML5では使用できません。空の開始タグはエラーとなり、`<>`という文字列のテキストノードになります。空の終了タグもエラーですが、こちらは終了タグが丸ごと無視されます。上記の例の場合、`p`要素が2つできることはなく、"テキスト <>テキスト" というテキストノードをもった1つの`p`要素になります。

[^6]: invalid-first-character-of-tag-name error
[^7]: missing-end-tag-name error

## 開始タグを省略すると属性は書けない

開始タグを省略できる場合がありますが、開始タグを省略した際に属性のみを書く方法は存在しません。つまり、属性を指定したければ必ず開始タグを書かなければなりません。

たとえば、`html`要素の開始タグは省略可能ですが、`lang`属性を指定したい場合は開始タグを書く必要があります。

```html
<html lang="ja">
```

## 複数の属性

属性の節でも触れましたが、同一の属性名を持つ属性を複数指定することはできません。

```html
<body class="type1" class="type2">
```

上記はエラー[^8]となり、後の方の属性が無視されます。つまり以下のように解釈されます。

[^8]: duplicate-attribute parse error

```html
<body class="type1">
```

なお、属性の種類によっては、1つの属性に複数の値を指定できる場合があります。`class`属性の場合、以下のようにスペース区切りで複数の値を指定することができます。

```html
<body class="type1 type2 type3">
```

## 属性値の省略

ブール型属性の項で触れましたが、属性値の記述は省略することもできます。属性のパース時、属性値の初期値は空文字列 (`""`) になっています。属性名だけを指定し、属性値の記述を省略した場合、属性値が空文字列のまま属性のパースが終わるため、空文字列の属性値が指定されたものとして扱われます。そのため、以下の3つの`img`要素の書き方は同じ意味になります。

```html
<img alt>
<img alt="">
<img alt=''>
```

`<img alt="">`と書いた際、ブラウザの開発者ツールで調査してDOMツリーを見るとすると`<img alt>`と表示される場合があります。これは、最も短い書き方で正規化されているためです。

なお、`alt`属性の場合は特に、`alt`属性を丸ごと省略した場合とは意味が異なることに注意してください。

## 引用符のない属性

属性を書く際には属性値を引用符でくくるのが基本ですが、引用符を省略できる場合もあります。引用符を省略した場合、以下のようになります。

- タブ、改行、空白文字、`>`が出現すると属性値の終了とみなされる。
- `"`、`'`、`<`、`=`、\`が出現するとエラー[^9]となるが、該当の文字は属性値の一部とみなされて処理される。

[^9]: unexpected-character-in-unquoted-attribute-value parse error

属性値を引用符でくくった場合、対応する引用符(`"`もしくは`'`)で終了するのに対し、くくらない場合はさまざまな文字で属性値が終了します。これはクロスサイトスクリプティング(XSS)脆弱性の原因となりやすいため、セキュリティ上の観点からは、属性値を引用符でくくることが強く推奨されています。

## plaintext

HTML4までは`plaintext`要素が定義されていましたが、HTML5では廃止されています (obsolete featureとして記載されています)。

要素としては廃止されているのですが、パーサー仕様には`<plaintext>`というマークアップの処理が定義されています。`plaintext`というタグ名の開始タグに遭遇すると、以降を全てプレーンテキストとして処理し、タグも文字参照も解釈しなくなります。`</plaintext>`という文字列があってもそのまま表示します。

もともと、`plaintext`要素はHTMLの要素として扱われることを意図したものではありませんでした。HTMLとして扱われては困るプレーンテキスト文書の先頭に`<plaintext>`という文字列を書いておくことで、仮にHTMLとして解釈されてもプレーンテキストのように表示される、という挙動が期待できます。

今日では`<plaintext>`を使用することはほとんどないと思いますが、これを書くことで`Content-Type`ヘッダーの誤判定によるXSSを回避できるケースもあるので、セキュリティの視点では意味があるかもしれません。

## 終了タグを書き漏らした際のエラー

終了タグを書き漏らした場合、特殊な方法で補われるケースがあります。まず、問題のない以下のようなマークアップがあったとしましょう。

```html
<p><b>b要素</b></p>
<p>bのないp</p>
```

一方で、以下のように終了タグ`</b>`を書き忘れたとしましょう。

```html
<p><b>b開始タグ</p>
<p>bのないp</p>
```

`b`要素の終了タグは省略できないため、これはエラーになります。エラー処理の結果、これは以下のように解釈されます。

```html
<p><b>b開始タグ</b></p>
<b><p>bのないp</p></b>
```

終了タグが補われただけでなく、次の`p`要素の外側が`b`要素とみなされます。エラー修正のされ方は要素によっても異なり、かなり複雑です。後述のように、直感に反する挙動になることもあるため、エラーが起こらないようにマークアップすることをお勧めします。

## 直感に反するエラー処理

HTML5のエラー処理には、直感に反する面白いルールがいくつかあります。

### ノアの箱舟ルール

先に`<b>`の終了タグを書き忘れた例を紹介しましたが、`<b>`を4つに増やすとどうなるでしょうか。

```html
<p><b><b><b><b>4つのb開始タグ</p>
<p>bのないp</p>
```

これは以下のように補われます。

```html
<p><b><b><b><b>4つのb開始タグ</b></b></b></b></p>
<b><b><b><p>bのないp</p></b></b></b>
```

一見、`<b>`が1つのときと同じルールで補正されているように見えますが、よく見ると、2つめの`p`の外側に補われている`<b>`タグと`</b>`タグの数は3つしかありません。4つあったはずの`b`要素が1つ減っているのです。

これは、要素をまたがって補われる際、同一要素名・同一クラス名の要素は3つまでしか復元されないというルールがあるからです。

正直なところ意味不明なルールですが、仕様の注釈では、これは「ノアの箱舟」(noah's arc) であるとされています。おそらく、過去にそのように処理していたブラウザの挙動を引き継いだ (そして、その挙動の理由を誰も説明できなかった) のでしょう。

## foster parenting

`table`要素には"foster parenting"と呼ばれる特殊なエラー処理があります。以下は`table`要素のマークアップの例です。

```html
<table>
<tr>
    <th>見出しセル</th>
    <td>データセル</td>
</tr>
</table>
```

`table`要素直下には、`caption`,`col`,`colgroup`,`thead`,`tbody`,`tfoot`といったテーブル関連要素が入れられます。また、`tbody`要素は開始タグも終了タグも共に省略可能なため、`tr`が直下に出現してもかまいません (この場合は`tbody`要素が自動的に補われます)。

`tr`もなく、`th`や`td`が直下に出現した場合はどうなるでしょうか。

```html
<table>
    <th>見出しセル</th>
    <td>データセル</td>
</table>
```

この場合はパースエラーとなりますが、エラー処理の結果として`tr`が補われます。結果として、最初のマークアップと同じように解釈されます。ただし、`tbody`が補われるケースと異なり、エラーであることには注意してください。

さて、`table`要素直下に`table`とは関係のない要素が現れた場合はどうなるでしょうか。以下は、`table`要素の末尾に`p`要素を挿入しようとした例です。

```html
<table>
<tr>
    <th>見出しセル</th>
    <td>データセル</td>
</tr>
<p>何かテキスト</p>
</table>
```

これはエラーとなり、以下のように解釈されます。

```html
<p>何かテキスト</p>
<table>
<tr>
    <th>見出しセル</th>
    <td>データセル</td>
</tr>
</table>
```

下の方にあったはずの`p`要素は、`table`要素の前に移動されています。`table`内のどこにあっても、`table`要素の前に追い出されるような形になります。奇妙な挙動に見えますが、これは仕様にのっとった挙動です。

この処理は"foster parenting"と呼ばれています。foster parentは“里親”というような意味です。`table`の子だった要素を、外側の要素が引き取って子にするように見えるのでこう呼ぶのでしょう。

テキストノードでも同様の処理が行われるため注意が必要です。このようなところに意図してテキストを書くことはないと思いますが、`table`の内部を誤って全角スペースでインデントした場合、その全角スペースは全て`table`の前に追い出され、その結果として意図しない余白が生まれることがあります。
