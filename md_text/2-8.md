# HTMLの細かい文法

マークアップの基本となるタグの書き方については先に説明しました。通常のマークアップ業務では先の知識で十分なのですが、主にセキュリティの観点から、通常はしないようなマークアップがどのように解釈されるのか、という観点の議論が必要となることもあります。
ここでは、タグの書き方についてもう一歩踏み込んだところをご説明します。

## 細かい文法ルールを知りたいときは

HTMLのパーサーのルールは仕様で明確に定められています。仕様の "Parsing HTML documents" の節では、どういう状況でどういう文字が出現したらどうなるか、というレベルまで挙動が規定されています。「このような書き方は可能?」「このように書いたらどのように解釈される?」という疑問は、ほとんどの場合、仕様を読み込めば解決できます。

Parsing HTML documents
<https://html.spec.whatwg.org/multipage/parsing.html>

ここでは、そのごく一部を豆知識として紹介します。

## タグ名に使用できる文字

HTMLのタグ名は英大文字小文字で始まる必要があり、数字で始まることは許されません。以下は正しくない例です。

```html
<42>
```

このようなマークアップはエラー (invalid-first-character-of-tag-name parse error) となり、タグではなくテキストとして解釈されます。つまり、以下のようなマークアップと同じ結果になります。

```html
&lt;42>
```

これは1文字目だけの制限で、2文字目以降には数字を使用することもできます。実際に`<h1>`のようなタグ名が使用されているのはご存知でしょう。

文法上、2文字目以降は数字だけでなく、記号類も使用できます。利用できない文字はわずかしかなく、`>`(タグの終了と解釈される)、空白類文字 (属性値との区切りと解釈される)、`/`(自己終了タグもしくは属性値との区切りと解釈される)のみです。

面白いことに、タグの開始区切り子である `<` もタグ名の一部として解釈されます。以下のようなマークアップがあったとします。

```html
<body>
<p<span>test</span></p>
</body>
```

`<p>`の`>`が抜けた形ですが、これは`p`要素とも`span`要素ともみなされません。エラーにもならず、`p<span`という文字列がタグ名とみなされます。上記の場合は`<span>`と`<p>`の開始タグがなく、`p<span`の終了タグもないので、エラー処理によって以下のように補われます。

```html
<body>
<p<span>test<p></p></p<span>
</body>
```

要素名に`<`を含めることができるのは、SGMLやXMLとは互換性のない挙動です。XML構文の場合、上記のようなマークアップはWell-formedではないため、パースエラーとなります。

セキュリティの観点からは、`/`の扱いについて注意が必要です。以下のようなマークアップは、HTMLの仕様としては不正です。

```html
<span/onmouseover="alert(1)">test</span>
```

これはエラー (unexpected-solidus-in-tag parse error) となるのですが、`<` の場合と異なり、`/` はタグ名の一部とはみなされません。エラー処理の際は、`/` のあとが属性名とみなされます。結果として、これは以下のようなマークアップと等価になります。

```html
<span onmouseover="alert(1)">test</span>
```

つまり、`onmouseover`属性が有効に機能することになります。タグ内に空白を挿入できなくても、属性を挿入することができる点に注意が必要です。

## 終了タグに属性は書けない

終了タグに属性を書くことはできません。

```html
<p>foo</p class="foo">
```

このように終了タグに属性を書いた場合、end-tag-with-attributes parse error となり、属性は無視されます。終了タグ自体は有効に機能します。

## 終了タグ末尾の /

終了タグの末尾に`/`を書くことはできません。

```html
<p>foo</p/>
```

書いた場合、 end-tag-with-trailing-solidus parse error となり、単に無視されます。終了タグ自体は有効に機能します。

## エンプティタグ

SGMLでは「エンプティタグ」と呼ばれる記述が許されており、理論上はHTML4でも使用することができました (対応しているブラウザが存在するかどうかはともかく)。文字通り空のタグ、タグ名部分を省略したタグで、以下のようなものです。

```html
<p>テキスト</>
```

要するに、対応する開始タグが明確ならタグ名の記載を省略できるというルールだったのですが、これはHTML5では使用できません。エラー (missing-end-tag-name error)となり、終了タグが丸ごと無視されます。

## 開始タグを省略すると属性は書けない

開始タグを省略できる場合がありますが、開始タグを省略した際に属性だけを書く方法は存在しません。つまり、属性を指定したければ必ず開始タグを書かなければなりません。

たとえば、`body`要素の開始タグは省略可能ですが、`class`属性を指定したい場合は開始タグを書く必要があります。

```html
<body class="type1">
```

## 複数の属性

同一の属性名を持つ属性を複数指定することはできません。

```html
<body class="type1" class="type2">
```

上記は duplicate-attribute parse error となり、後の方の属性が無視されます。つまり以下のように解釈されます。

```html
<body class="type1">
```

なお、属性の種類によっては、ひとつの属性に複数の値を指定できる場合があります。class属性の場合、以下のようにスペースで区切って複数の値を指定することができます。

```html
<body class="type1 type2">
```

## 属性値の省略

ブール型属性の項で触れましたが、属性値の記述は省略することもできます。属性のパース時、属性値の初期値は空文字列 (`""`) になっています。属性名だけを指定し、属性値の記述を省略した場合、属性値が空文字列のまま属性のパースが終わるため、空文字列の属性値が指定されたものとして扱われます。そのため、以下の3つのimg要素の書き方は同じ意味になります。

```html
<img alt>
<img alt="">
<img alt=''>
```

`<img alt="">` と書いた際、ブラウザの開発者ツールで調査してDOMツリーを見ると `<img alt>` と表示される場合があります。これは、最も短い書き方で正規化されているためです。

なお、`alt`属性を丸ごと省略した場合とは意味が異なることに注意してください。

## 引用符のない属性

属性を書く際には属性値を引用符でくくるのが基本ですが、引用符を省略できる場合もあります。引用符を省略した場合、以下のようになります。

- タブ、改行、空白文字、`>`が出現すると属性値の終了とみなされる。
- `"`、`'`、`<`、`=`、` が出現すると unexpected-character-in-unquoted-attribute-value parse error となりますが、該当の文字は属性値の一部とみなされて処理される。

属性値を引用符でくくった場合、対応する引用符 (`"`もしくは`'`) で終了するのに対し、くくらない場合はさまざまな文字で属性値が終了します。これはクロスサイトスクリプティング脆弱性の原因となりやすいため、セキュリティ上の観点からは、属性値を引用符で括ることが強く推奨されています。

## plaintext

HTML4までは`plaintext`要素が定義されていましたが、HTML5では廃止されています (obsolete featureとして記載されています)。

要素としては廃止されているのですが、パーサー仕様には`<plaintext>`というマークアップの処理が定義されています。`plaintext`というタグ名の開始タグに遭遇すると、以降を全てプレーンテキストとして処理し、タグも文字参照も解釈しなくなります。`</plaintext>`という文字列があってもそのまま表示します。

もともと、`plaintext`要素はHTMLの要素として扱われることを意図したものではありませんでした。HTMLとして扱われては困るプレーンテキスト文書の先頭に`<plaintext>`という文字列を書いておくことで、仮にHTMLとして解釈されてもプレーンテキストのように表示される、という挙動が期待できます。

今日では`<plaintext>`を使用することはほとんどないと思いますが、これを書くことでContent-Typeの誤判定によるXSSを回避できるケースもあるので、セキュリティの視点では意味があるかもしれません。

## 終了タグを書き漏らした際のエラー

終了タグを書き漏らした場合、特殊な方法で補われるケースがあります。以下のようなマークアップがあったとしましょう。

```html
<p><b>b要素</b></p>
<p>bのないp</p>
```

最初の`p`要素の中には、`b`要素の開始タグと終了タグがあります。次の`p`要素の中身はテキストノードだけで、特にマークアップされていません。このマークアップは何の問題もなく、最初の`p`要素の中に`b`要素があるものとみなされます。

ところで、以下のように`</b>`という終了タグを書き忘れることがあります。

```html
<p><b>b開始タグ</p>
<p>bのないp</p>
```

`b`要素の終了タグは省略できないため、これはエラーになります。エラー処理の結果、これは以下のように解釈されます。

```html
<p><b>b開始タグ</b></p>
<b><p>bのないp</p></b>
```

終了タグが補われただけでなく、次の`p`要素の外側も`b`要素とみなされます。エラー修正のされ方は要素によって異なり、少々複雑です。基本的には、エラーが起こらないようにマークアップするべきです。

### ノアの箱舟ルール

このエラー処理には、ひとつ面白いルールがあります。先の例では`<b>`がひとつでしたが、それを4つに増やすとどうなるでしょうか。

```html
<p><b><b><b><b>4つのb開始タグ</p>
<p>bのないp</p>
```

これは以下のように補われます。

```html
<p><b><b><b><b>4つのb開始タグ</b></b></b></b></p>
<b><b><b><p>bのないp</p></b></b></b>
```

一見、`b`要素ひとつのときと同じルールで補正されているように見えますが、よく見ると2つめの`p`の外側に補われている`<b>` `</b>`の数は3つしかありません。4つあったはずの`b`がひとつ減っているのです。

これは、要素をまたがって補われる際、同一要素名・同一クラス名の要素は3つまでしか復元されないというルールがあるからです。

正直なところ意味不明なルールですが、仕様の注釈では、これは「ノアの箱舟」(noah's arc) であるとされています。おそらく、過去にそのように処理していたブラウザの挙動を引き継いだ (そして、その挙動の理由を誰も説明できなかった) のでしょう。

## foster parenting

`table`要素には"foster parenting"と呼ばれる特殊なエラー処理があります。以下は`table`要素のマークアップの例です。

```html
<table>
<tr>
    <th>見出しセル</th>
    <td>データセル</td>
</tr>
</table>
```

`table`要素直下には、`caption`,`col`,`colgroup`,`thead`,`tbody`,`tfoot`といった要素が入れられます。また、`tbody`要素は開始タグ終了タグ共に省略可能なため、`tr`がいきなり出現してもかまいません (この場合は`tbody`要素が自動的に補われます)。

`tr`もなく、`th`や`td`がいきなり出現した場合はどうなるでしょうか。

```html
<table>
    <th>見出しセル</th>
    <td>データセル</td>
</table>
```

この場合はパースエラーとなりますが、エラー処理の結果として`tr`が補われます。結果として、最初のマークアップと同じように解釈されます。ただし、`tbody`が補われるケースと異なり、エラーであることには注意してください。

さて、`table`要素直下に`table`とは関係のない要素が現れたらどうなるでしょうか。以下は、`table`要素の末尾に`p`要素を挿入しようとした例です。

```html
<table>
<tr>
    <th>見出しセル</th>
    <td>データセル</td>
</tr>
<p>何かテキスト</p>
</table>
```

これはエラーとなり、以下のように解釈されます。

```html
<p>何かテキスト</p>
<table>
<tr>
    <th>見出しセル</th>
    <td>データセル</td>
</tr>
</table>
```

下の方にあったはずの`p`要素は、`table`要素の前に移動されています。`table`内のどこにあっても、`table`要素の前に追い出されるような形になります。奇妙な挙動に見えますが、これは仕様にのっとった挙動です。

この処理は "foster parenting" と呼ばれています。foster parentは「里親」というような意味です。`table`の子だった要素を、外側の要素が引き取って子にするように見えるのでこう呼ぶのでしょう。

テキストノードでも同様の処理が行われるため注意が必要です。このようなところに意図してテキストを書くことはないと思いますが、`table`の内部を誤って全角スペースでインデントしていると、その全角スペースは全て`table`の前に追い出され、その結果として謎の余白が生まれることがあります。
