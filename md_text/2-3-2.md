# リソースの種類とMIMEタイプ

前節ではURLについて説明しました。URLは、HTMLの他にも画像、CSS、JavaScriptなど、さまざまな種類のリソースを差し示すことができますが、URLにはリソースの種類を示す情報は含まれていません。ここでは、さまざまなリソースの種類と、その判別方法について説明します。

## リソースの種類とその区別

Webで扱われるリソースには、HTMLの他にも画像、CSS、JavaScriptなどさまざまな種類のものがあります。

リソースの種類によって、ブラウザーによる処理は異なります。たとえば、HTMLなら文法解析をしてからレンダリングする必要がありますし、PNG画像なら画像として表示し、SVG画像ならSVGをパースしてから表示することになります。リソースの種類が正しく判別できないと、適切な処理ができません。PNG画像をHTMLとして表示しようとしても文法エラーになるでしょうし、その逆も然りです。

<!-- security consideration -->
リソースの判別は、セキュリティ上も重要な意味を持ちます。ファイルアップロード機能を持つWebサービスでは、HTMLファイルをアップロードできないようにしているケースが多く見られます。スクリプトを含むHTMLファイルがアップロードされると、クロスサイトスクリプティングの攻撃が可能になるためです。<!-- 牧歌的な時代もあったが私がトドメを刺した http://jvn.jp/jp/JVN465742E4/index.html -->しかし、リソースの種類判別が正しく行われないと、たとえば、HTMLとして解釈可能な文字列を画像の中に含めてアップロードし、それをブラウザーにHTMLと誤認識させることで、攻撃が可能になる場合があります。
<!-- /security consideration -->

このため、リソースの種類を正しく判定して処理することが重要になります。

### 拡張子による判別

手元のパソコンなど、ローカルでファイルを扱う場合には、ファイル名の末尾についた「拡張子」(extension)によって種別を判別するのが一般的です。拡張子が`.html`ならばHTMLファイル、`.png`ならPNG画像、`.svg`ならSVG画像というふうに解釈します。ブラウザーも、ローカルファイルを開く際には拡張子からファイル種別を判定することがあります。

しかし、Web上のリソースは必ずしも拡張子を持ちません。URLの末尾には、拡張子らしき文字列がつくこともありますが、つかないこともあります。

```text
https://example.com/foo/
https://example.com/foo.html
```

また、拡張子らしい文字列があっても、リソースのタイプとは関係ない場合もあります。さらに、末尾にクエリ文字列やパス文字列が追加されることもあります。

```text
https://example.com/foo.php
https://example.com/foo.aspx
https://example.com/foo.php?file=sample.txt
https://example.com/foo.php/bar/baz
```

このようにURLには様々なパターンがあります。Webにおいては、単純に拡張子からファイルの種類を判別することはできないのです。

古いブラウザーの中には、URLに含まれる拡張子らしき文字列を判別に利用するものもありましたが、その挙動は、先に述べたようなセキュリティの問題を多く引き起こしました。現在のブラウザーは、原則として、URLに含まれる拡張子にる判別は行わないようになっています。
<!-- 参考: https://atmarkit.itmedia.co.jp/ait/articles/0903/30/news118.html -->

### HTTP応答へッダと`Content-Type`フィールド

では、Webではどのようにしてリソースの種類を判別しているのでしょうか。Webでリソースを取得する際には、HTTPによる通信が行われます。そして、サーバー側からの応答には、「HTTP応答ヘッダ」(HTTP response header)が含まれています。以下はHTTP応答ヘッダの例です。

```http
Status: 200 OK
Content-Type: text/html; charset=utf-8
Content-Length: 7887
Date: Thu, 19 Aug 2021 10:00:02 GMT
Last-Modified: Tue, 17 Aug 2021 14:00:11 GMT
```

ヘッダにはさまざまな情報が含まれます。先頭を「ステータス行」(status line)、それ以降の行を「ヘッダフィールド」(header field)と呼びます。ヘッダフィールドにはフィールド名とフィールド値が含まれ、`:`で区切られます。

上記の例には、`Content-Type`という名前のフィールドが含まれています。これが、リソースの種類を示すフィールドです。Webでは原則として、HTTP応答ヘッダの`Content-Type`フィールドによってリソースの種類を判別します。上記の例では、このコンテンツがHTMLであること、文字符号化方式がUTF-8であることを示しています。文字符号化方式については「HTMLで扱える文字」の節を参照してください。

### MIMEタイプ

`Content-Type`フィールドに指定する値は、「インターネットメディアタイプ」（internet media type）もしくは「MIMEタイプ」(MIME Types)と呼ばれます。MIMEはMultipurpose Internet Mail Extensionsの略称で、RFC 2046[^1]で定義されています。単に「メディアタイプ」(media type)と呼ばれることもあります。

[^1]: <https://datatracker.ietf.org/doc/html/rfc2046>

MIMEは元々、電子メールの本文や添付ファイルのメディアの種類を示すのに利用されていましたが、これがそのままWebでも利用されるようになっています。MIMEタイプはIANAによって管理されており、登録されているMIMEタイプの一覧をIANAのWebサイトのMedia Typesのページ[^2]で見ることができます。

[^2]: <https://www.iana.org/assignments/media-types/media-types.xhtml>

上記でわかるように、本家であるIANAのサイトでは「メディアタイプ」という呼び名を採用しています。ただし、この呼び方はCSSのメディアクエリーで記述するメディアタイプと紛らわしいため[^3]、本書ではMIMEタイプと呼ぶことにします。

[^3]: この紛らわしさはMIME sniffing Standardでも指摘されています。 <https://mimesniff.spec.whatwg.org/#mime-type-representation>

## MIMEタイプの書式

よく使われるMIMEタイプには、たとえば以下のようなものがあります。

```txt
image/png
text/plain
text/html
text/xml
application/javascript
application/json
```

MIMEタイプには必ず`/`が含まれます。`/`の前を「タイプ」（type）、後ろを「サブタイプ」（subtype）と呼びます。

タイプはおおまかなデータの分類を示します。`image`は画像を、`text`はテキストを意味します。ほかにも`application`や`audio`、`font`、`video`といったものがあります。コンテンツ内に複数の内容を含む場合、`multipart`というタイプが使われます。

サブタイプはタイプの細かな分類を示し、多くの場合は実際のデータ形式と結びつきます。`image/png`であれば、PNG形式の画像であることを示します。ただし、MIMEタイプとデータ形式は1対1の対応関係にはなく、複数のMIMEタイプが同じ形式を示すこともあります。たとえば、`text/xml`と`application/xml`は、いずれもXML形式のデータを表します。

中には、データ形式を特定しない曖昧なものもあります。たとえば、`application/octet-stream`は何らかのバイナリデータであることを示しますが、具体的に何のデータであるのかまでは示しません。

### サブタイプのバリエーション

サブタイプにはいくつかのバリエーションがあります。以下にいくつかのMIMEタイプの例を挙げます。

```txt
image/png
image/vnd.microsoft.icon
application/x.original-mime-type
application/x-www-form-urlencoded
image/svg+xml
application/ld+json
```

#### ツリー

サブタイプは、`.`（ピリオド）を区切り文字とする階層構造を持つことができます。これはRFC6838[^4]で定義されているもので、「ツリー」（tree）と呼ばれます。ピリオドを持たないサブタイプもツリーの一種とされ、「標準ツリー」（standard tree）と呼ばれます。先に挙げた`image/png`の`png`が標準ツリーの例です。

[^4]: RFC6838 3. Registration Trees and Subtype Names <https://datatracker.ietf.org/doc/html/rfc6838#section-3>

`vnd.`という接頭辞で始まるサブタイプは「ベンダーツリー」（vender tree）と呼ばれます。これは、ベンダー固有のファイルを登録するものです。上記の例では、`image/vnd.microsoft.icon`がベンダーツリーとなっています。

`x.`という接頭辞は、私的利用のために予約されているものです。`x.`で始まるサブタイプはIANAには登録されておらず、ベンダーや開発者が狭い範囲で利用するために独自に定義しているものです。以前は`x.`ではなく`x-`が私的利用のための接頭辞として利用されていましたが、今は`x.`を利用することになっています。
<!--
>   Subtype names with "x." as the first facet may be used for types
   intended exclusively for use in private, local environments.  Types
   in this tree cannot be registered and are intended for use only with
   the active agreement of the parties exchanging them.
-->

私的利用されていたMIMEタイプが広く利用されるようになり、IANAに登録されると、接頭辞は取り除かれます。たとえば、`text/x-javascript`や`application/x-pdf`は、それぞれ`text/javascript`や`application/pdf`として登録されています。

ただし、ブラウザーは互換性のために`x-`つきのMIMEタイプを処理することがあります。たとえば、`text/x-javascript`は、WHATWGのMIME Sniffing仕様にJavaScript MIME type[^5]として記載されているため、`script`要素の`type`属性に指定すると、JavaScriptのMIMEタイプとして扱われます。このように、IANA以外のところで仕様化されているケースもありますので注意してください。

[^5]: <https://mimesniff.spec.whatwg.org/#javascript-mime-type>

なお、稀な例として、例外的に`x-`が残ったままIANAに登録されているものもあります。具体的には、`application/x-www-form-urlencoded`がその例です。逆に`x-`なしの`application/www-form-urlencoded`というMIMEタイプは登録されていません。<!--  https://datatracker.ietf.org/doc/html/draft-hoehrmann-urlencoded-01 を見ると、もともとは x- なしで登録するつもりだったようだ -->

#### Structured Syntax Suffix

接頭辞ではなく、接尾辞がつくパターンもあります。`image/svg+xml`の`+xml`ように、サブタイプの末尾に`+`で始まる接尾辞をつけます。これは、Structured Syntax Suffixと呼ばれるもので、サブタイプにデータフォーマットの情報を追加するものです。現在ではRFC 6839[^6]で定義されています。

[^6]: RFC 6839 Additional Media Type Structured Syntax Suffixes <https://datatracker.ietf.org/doc/html/rfc6839>

たとえば、カレンダーに登録するスケジュール情報を表現するiCalendarという形式のデータがあります。iCalendarは簡単な改行区切りのテキストデータで表現でき、`text/calendar`というMIMEタイプを使用しますが、XML形式のxCal[^7]、JSON形式のjCal[^8]というフォーマットも存在し、それぞれ`application/calendar+xml`、`application/calendar+json`というMIMEタイプを使用します。このように、同じ意味を持つデータでもフォーマットが異なる場合に、接尾辞によってデータフォーマットを表現できるようになっています。

[^7]: RFC 6321 xCal: The XML Format for iCalendar <https://datatracker.ietf.org/doc/html/rfc6321>
[^8]: RFC 7265 jCal: The JSON Format for iCalendar <https://datatracker.ietf.org/doc/html/rfc7265>

### パラメーター

MIMEタイプは「パラメーター」（parameter）を持つこともあります。パラメーターは「名前」と「値」を"="（等号）で結合したものです。サブタイプとパラメーターの間は`;`（セミコロン）で区切ります。セミコロンの前後には空白を入れることも許されています。たとえば以下のような形式になります。

```text
application/javascript; charset=utf-8
```

あるタイプがパラメーターを持つかどうかは、IANAのMedia Typesの登録情報に記載されています。必須のパラメーターがある場合はRequired parametersの項に、オプションのパラメーターがある場合はOptional parametersの項に記載されす。

たとえば、JavaScriptのスクリプトファイルに利用される`application/javascript`[^8]の場合、以下のようになっています。

[^8]: <https://www.iana.org/assignments/media-types/application/javascript>

>Required parameters: 
>Optional parameters:     charset, see section 4.1.

これは`charset`パラメータを指定可能であり、しかし必須ではないという意味です。タイプが似ていても、パラメータの指定可否は異なる場合があります。たとえば、JSONデータを示す`application/json`[^9]は以下のようになっています。

[^9]: <https://www.iana.org/assignments/media-types/application/json>

>Required parameters:  n/a
>Optional parameters:  n/a

JSONの場合、パラメータは何も指定できません。JavaScriptと異なり、`charset`パラメーターも指定できないのです。これは、現在のJSONの仕様では文字符号化方式がUTF-8で固定になっているためです。

必須パラメータを持つ例には`multipart/form-data`[^10]があります。以下のようになっています。

[^10]: <https://www.iana.org/assignments/media-types/multipart/form-data>

>Required parameters:  boundary
>Optional parameters:  none

`multipart/form-data`を使用する場合、必ず`boundary`パラメーターを指定する必要があり、省略できません。<!-- ちなみに form要素のenctype属性に指定する"multipart/form-data"という文字列は「multipart/form-data encoding algorithmで送信する」という意味のトークンであり、MIMEタイプそのものではない。送信時にはboundaryつきのMIMEタイプが生成される。https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#form-submission-algorithm:attr-fs-enctype-formdata -->

#### `charset`パラメーター

`text/html`や`application/javascript`などのMIMEタイプは、オプションとして`charset`パラメーターを持ちます。これは文字符号化方式を指定するものです。文字集合、文字符号化方式については、「HTMLで扱える文字」の節で後述します。

`charset`パラメーターを指定すると、たとえば以下のようになります。

```text
text/html; charset=UTF-16
text/html; charset=Shift_JIS
text/html; charset=ISO-2022-JP
```

"charcter set"という言葉は文字集合、"character encoding"は文字符号化方式を表す言葉ですが、両者はよく混同されます。`charset`パラメーターにもこの混同があり、実際に指定する値は文字符号化方式の名称となっています。

<!-- security consideration -->
`charset`パラメーターはセキュリティ上、重要な意味を持ちます。コンテンツの文字符号化方式を誤認させることで攻撃が可能になる場合があるからです。たとえば、UTF-8で符号化されたHTMLに以下の文字列が出力されているとします。

```html
+ADw-script+AD4-alert(+ACI-test+ACI-)+ADsAPA-/script+AD4-
```

これは単に意味不明な文字列にすぎず、攻撃には至りませんが、これをUTF-7として解釈すると以下のようになります。

```html
<script>alert('test');</script>
```

こうなるとスクリプトが実行されることになります。HTMLに`charset`パラメータが指定されていない場合、攻撃者が何らかの方法で文字符号化方式を誤認させることで、攻撃が成立する場合があります。このような理由から、IPAの「安全なウェブサイトの作り方」[^11]では、`Content-Type`フィールドに必ず`charset`パラメーターを指定するように求めています。

[^11]: <https://www.ipa.go.jp/security/vuln/websecurity-HTML-1_5.html>
<!-- /security consideration -->

## Webでよく利用されるMIMEタイプ

実際にWebでよく利用されるMIMEタイプをいくつか紹介します。より網羅的な情報が知りたい場合は、HTML仕様の索引にあるMIMEタイプの一覧[^12]を参照してください。

[^12]: <https://html.spec.whatwg.org/multipage/indices.html#mime-types-2>

それぞれのMIMEタイプの扱いはブラウザーやOSによって異なりますが、ここでは一般的な処理をご紹介します。

### `text/html`

`text/html`はHTML文書を表します。WebコンテンツのほとんどはHTMLで提供されており、ユーザーが見ているWebページの大半はこのMIMEタイプで配信されています。ブラウザーはHTMLを解析し、レンダリングして表示します。

### `application/xhtml+xml`

`application/xhtml+xml`は、XML形式で配信されるHTML文書、XHTMLを表します。このMIMEタイプで配信されたHTMLはXML構文で記述されているものとみなされ、XMLパーサーによって構文解析が行われます。レンダリングと表示についてはHTMLと同様ですが、XMLの文法に誤りがある場合は補正されず、エラーとなって表示に失敗することがあります。

### `application/pdf`

`application/pdf`はPDF文書を表します。多くのブラウザーはPDFをレンダリングして表示することができ、ブラウザーウィンドウ内で文書として表示します。以前のブラウザーはPDFの表示に専用のプラグインを必要とすることがありましたが、近年ではプラグインを不要とするブラウザがほとんどです。いまだにPDFのプラグインのダウンロードを促すサイトを見かけますが、もはや必要ないことが多いでしょう。

PDFファイルをブラウザーで直接開かせるのではなく、ダウンロードさせたいような場合、あえて`application/octet-stream`で配信することもあります。

### `image/png` `image/jpeg` `image/gif`

`image/png`、`image/jpeg`、`image/gif`は、それぞれPNG画像、JPEG画像、GIF画像を表します。いずれも、ブラウザーは画像を表示しようとします。

`img`要素の`src`属性で参照すると、HTMLのコンテンツに画像を埋め込むことができます。`a`要素の`href`属性で参照したり、画像のURLを直接ブラウザーのアドレスバーに入れた場合、ブラウザーウィンドウで画像を直接表示します (俗に「画像直リンク」と呼ばれます)。この場合、代替テキストの情報が提供されず、アクセシビリティ上の問題につながる場合があることに注意してください。

### `image/svg+xml`

`image/svg+xml`は、XML形式で配信されるSVG画像を表します。PNG画像などと異なり、SVGデータ自体に`title`要素によるタイトルや、`desc`要素による説明文のテキストを含んでいることがあります。また、`script`要素によるJavaScriptのデータを含むこともあります。

`img`要素の`src`属性で参照すると、HTMLのコンテンツに画像を埋め込むことができます。この場合、タイトルや説明文などの情報は利用されず、スクリプトも実行されません。

`a`要素の`href`属性で参照したり、画像のURLを直接ブラウザーのアドレスバーに入れた場合、ブラウザーウィンドウで画像を直接表示します。この場合、支援技術によってタイトルや説明文が読まれる場合があります。また、`script`要素の内容がスクリプトとして実行される場合があります。

### `application/javascript`

`application/javascript`は、JavaScriptのスクリプトデータを表します。以前は`text/javascript`が利用されることもあり、さらに以前には`text/x-javascript`などが利用されていたこともありました。

<!-- security consideration -->
JavaScriptを意図しないコンテンツをこのMIMEタイプで配信すると、セキュリティの問題が生じることがありますので注意してください。このMIMEタイプで配信されるJavaScriptは、`script`要素の`src`属性に指定してクロスドメインで実行することが可能になります。特に、JSONをこのMIMEタイプで配信した場合、一定の条件が揃うと、「JSONハイジャック」と呼ばれる攻撃で情報を読み出されてしまう場合があります。
<!-- /security consideration -->

### `application/json`

`application/json`は、任意のJSON(JavaScript Object Notation)形式のデータを表します。近年のWeb APIではよく利用される形式です。以前は`text/json`が利用されることもありました。

JavaScriptとデータ形式が似ていますが、MIMEタイプは異なります。JSONはもともとJavaScriptのオブジェクトリテラル表記を元していますが、現在の仕様では微妙な差異や独自の制限があります (UTF-8以外の文字符号化方式が許されないなど)。また、前述のように、`application/javascript`で配信するとセキュリティ上の問題が生じることがありますので注意してください。

用途の決まったデータをJSON形式で配信する場合、それ専用のMIMEタイプが利用できる場合があります。たとえば、JSON-LDによるメタデータをJSON形式で配信する場合は、`application/ld+json`を利用します。<!-- `application/microdata+json` というのもあるが利用されているのだろうか? -->

### `text/css`

`text/css`は、CSS(Cascading Style Sheets)によるスタイルシートデータを表します。HTMLの`link`要素を利用して外部スタイルシートを参照する場合に、この形式のデータを利用します。

### `application/octet-stream`

`application/octet-stream`は、任意のバイナリデータを表します。データが具体的に何なのかは不明です。ブラウザーは、これをMIMEタイプが不明なものとして扱います。後述の「MIMEタイプが不明な場合」を参照してください。多くの場合はダウンロードを促しますが、レンダリングしようとすることもあります。
<!--
パラメータなしのapplication/octet-streamは、"a type that the user agent knows it cannot render" ではなはなく、未知のMIMEタイプとして扱う。MIME Sniffでレンダリングする場合があるということ。
https://html.spec.whatwg.org/multipage/media.html#a-type-that-the-user-agent-knows-it-cannot-render
The MIME type "application/octet-stream" with no parameters is never a type that the user agent knows it cannot render. User agents must treat that type as equivalent to the lack of any explicit Content-Type metadata when it is used to label a potential media resource.
-->

明示的にファイルをダウンロードさせたい場合、HTTP応答ヘッダで`Content-Type: pplication/octet-stream`を指定したうえで、さらに`Content-Disposition: attachment`を指定してください。

### MIMEタイプが不明な場合

MIMEタイプが指定されていなかったり、ブラウザーにとって未知なものであった場合、ブラウザーはこのデータの扱い方を判断できません。この場合、ブラウザーは、後述するMIME sniffingの処理を行ってデータの種類を判別しようとすることがあります。

それでも種類が不明な場合は、ユーザーにデータのダウンロードを促し、保存するかどうかを尋ねることが一般的です。ただし、モバイル端末など、ローカルにファイルを保存することができない環境もあります。その場合は、クラウドへの保存を促すこともあれば、何も起きないこともあります。

## MIME sniffing

状況によっては、アクセスしようとしているコンテンツの`Content-Type`が指定されていなかったり、ブラウザーにとって未知の値が指定されていることがあります。また、明らかに誤った値の`Content-Type`が指定されていることもありえます。このような場合、ブラウザーはレンダリングを諦めるのではなく、コンテンツの内容を実際に読んでみてMIMEを推測しようとします。この処理をMIME sniffingと呼びます。

MIME sniffingのルールやアルゴリズムは、MIME sniffing仕様[^13]で規定されています。

[^13]: <https://mimesniff.spec.whatwg.org/>

歴史的に、古い一部のブラウザーは、サーバーが適切な`Content-Type`を送信していてもそれを無視し、URLに含まれる拡張子やコンテンツのsniffingによる推測結果の方を優先することがありました。これはセキュリティ上の問題を引き起こすことがあります。たとえば、JVN#91706484 Trac におけるクロスサイトスクリプティングの脆弱性[^14]は、Internet Explorerが`Content-Type`を無視して推測結果を優先するために、Internet Explorerのみで攻撃が成立するという例です。

[^14]: <https://jvn.jp/jp/JVN91706484/>

このような問題が多発したため、Internet Explorer 8では、MIME sniffingを抑制できるようになりました[^15]。単にsniffingを止めるのでは互換性の問題が生じるため、HTTP応答ヘッダで`X-Content-Type-Options: nosniff`フィールドが送信されている場合のみsniffingを抑制する仕様を採用しました。その後、各ブラウザーも`X-Content-Type-Options`を解釈してsniffingを抑制するようになっています。

[^15]: <https://docs.microsoft.com/ja-jp/archive/blogs/ie/ie8-security-part-vi-beta-2-update#mime-handling-sniffing-opt-out>

各ウェブブラウザーが独自に異なるMIME sniffingを行い、標準仕様が存在しない状況では、サーバー側でセキュリティの問題を回避するための十分な対策を施すのが困難でした。そのような背景もあり、MIME sniffingの挙動を仕様化して統一したものがMIME sniffing仕様であると言えます。
