# リソースの種類とMIMEタイプ

前節ではURLについて説明しました。URLは、HTMLの他にも画像、CSS、JavaScriptなど、さまざまな種類のリソースを差し示すことができますが、URLにはリソースの種類を示す情報は含まれていません。ここでは、さまざまなリソースの種類と、その判別方法について説明します。

## リソースの種類とその区別

Webで扱われるリソースには、HTMLの他にも画像、CSS、JavaScriptなどさまざまな種類のものがあります。

リソースの種類によって、ブラウザーによる処理は異なります。たとえば、HTMLなら文法解析をしてからレンダリングする必要がありますし、PNG画像なら画像として表示し、SVG画像ならSVGをパースしてから表示することになります。リソースの種類が正しく判別できないと、適切な処理ができません。PNG画像をHTMLとして表示しようとしても文法エラーになるでしょうし、その逆も然りです。

リソースの判別は、セキュリティ上も重要な意味を持ちます。ファイルアップロード機能を持つWebサービスでは、HTMLファイルをアップロードできないようにしているケースが多く見られます。スクリプトを含むHTMLファイルがアップロードされると、クロスサイトスクリプティングの攻撃が可能になるためです。<!-- 牧歌的な時代もあったが私がトドメを刺した http://jvn.jp/jp/JVN465742E4/index.html -->しかし、リソースの種類判別が正しく行われないと、たとえば、HTMLとして解釈可能な文字列を画像の中に含めてアップロードし、それをブラウザーにHTMLと誤認識させることで、攻撃が可能になる場合があります。

このため、リソースの種類を正しく判定して処理することが重要になります。

### 拡張子による判別

手元のパソコンなど、ローカルでファイルを扱う場合には、ファイル名の末尾についた「拡張子」(extension)によって種別を判別するのが一般的です。拡張子が`.html`ならばHTMLファイル、`.png`ならPNG画像、`.svg`ならSVG画像というふうに解釈します。ブラウザーも、ローカルファイルを開く際には拡張子からファイル種別を判定することがあります。

しかし、Web上のリソースは必ずしも拡張子を持ちません。URLの末尾には、拡張子らしき文字列がつくこともありますが、つかないこともあります。

```text
https://example.com/foo/
https://example.com/foo.html
```

また、拡張子らしい文字列があっても、リソースのタイプとは関係ない場合もあります。さらに、末尾にクエリ文字列やパス文字列が追加されることもあります。

```text
https://example.com/foo.php
https://example.com/foo.aspx
https://example.com/foo.php?file=sample.txt
https://example.com/foo.php/bar/baz
```

このようにURLには様々なパターンがあります。Webにおいては、単純に拡張子からファイルの種類を判別することはできないのです。

古いブラウザーの中には、URLに含まれる拡張子らしき文字列を判別に利用するものもありましたが、その挙動は、先に述べたようなセキュリティの問題を多く引き起こしました。現在のブラウザーは、原則として、URLに含まれる拡張子にる判別は行わないようになっています。
<!-- 参考: https://atmarkit.itmedia.co.jp/ait/articles/0903/30/news118.html -->

### HTTP応答へッダと`Content-Type`フィールド

では、Webではどのようにしてリソースの種類を判別しているのでしょうか。Webでリソースを取得する際には、HTTPによる通信が行われます。そして、サーバー側からの応答には、「HTTP応答ヘッダ」(HTTP response header)が含まれています。以下はHTTP応答ヘッダの例です。

```http
Status: 200 OK
Content-Type: text/html; charset=utf-8
Content-Length: 7887
Date: Thu, 19 Aug 2021 10:00:02 GMT
Last-Modified: Tue, 17 Aug 2021 14:00:11 GMT
```

ヘッダにはさまざまな情報が含まれます。先頭を「ステータス行」(status line)、それ以降の行を「ヘッダフィールド」(header field)と呼びます。ヘッダフィールドにはフィールド名とフィールド値が含まれ、`:`で区切られます。

上記の例には、`Content-Type`という名前のフィールドが含まれています。これが、リソースの種類を示すフィールドです。Webでは原則として、HTTP応答ヘッダの`Content-Type`フィールドによってリソースの種類を判別します。上記の例では、このコンテンツがHTMLであること、文字符号化方式がUTF-8であることを示しています。文字符号化方式については「HTMLで扱える文字」の節を参照してください。

### MIMEタイプ

`Content-Type`フィールドに指定する値は、「インターネットメディアタイプ」（internet media type）もしくは「MIMEタイプ」(MIME Types)と呼ばれます。MIMEはMultipurpose Internet Mail Extensionsの略称で、RFC 2046[^1]で定義されています。単に「メディアタイプ」(media type)と呼ばれることもあります。

[^1]: <https://datatracker.ietf.org/doc/html/rfc2046>

MIMEは元々、電子メールの本文や添付ファイルのメディアの種類を示すのに利用されていましたが、これがそのままWebでも利用されるようになっています。MIMEタイプはIANAによって管理されており、登録されているMIMEタイプの一覧をIANAのWebサイトのMedia Typesのページ[^2]で見ることができます。

[^2]: <https://www.iana.org/assignments/media-types/media-types.xhtml>

上記でわかるように、本家であるIANAのサイトでは「メディアタイプ」という呼び名を採用しています。ただし、この呼び方はCSSのメディアクエリーで記述するメディアタイプと紛らわしいため[^3]、本書ではMIMEタイプと呼ぶことにします。

[^3]: この紛らわしさはMIME sniffing Standardでも指摘されています。 <https://mimesniff.spec.whatwg.org/#mime-type-representation>

## MIMEタイプの書式

よく使われるMIMEタイプには、たとえば以下のようなものがあります。

```txt
image/png
text/plain
text/html
text/xml
application/javascript
application/json
```

MIMEタイプには必ず`/`が含まれます。`/`の前を「タイプ」（type）、後ろを「サブタイプ」（subtype）と呼びます。

タイプはおおまかなデータの分類を示します。`image`は画像を、`text`はテキストを意味します。ほかにも`application`や`audio`、`font`、`video`といったものがあります。コンテンツ内に複数の内容を含む場合、`multipart`というタイプが使われます。

サブタイプはタイプの細かな分類を示し、多くの場合は実際のデータ形式と結びつきます。`image/png`であれば、PNG形式の画像であることを示します。ただし、MIMEタイプとデータ形式は1対1の対応関係にはなく、複数のMIMEタイプが同じ形式を示すこともあります。たとえば、`text/xml`と`application/xml`は、いずれもXML形式のデータを表します。

中には、データ形式を特定しない曖昧なものもあります。たとえば、`application/octet-stream`は何らかのバイナリデータであることを示しますが、具体的に何のデータであるのかまでは示しません。

### サブタイプのバリエーション

サブタイプにはいくつかのバリエーションがあります。以下にいくつかのMIMEタイプの例を挙げます。

```txt
image/png
image/vnd.microsoft.icon
application/x.original-mime-type
application/x-www-form-urlencoded
image/svg+xml
application/ld+json
```

#### ツリー

サブタイプは、`.`（ピリオド）を区切り文字とする階層構造を持つことができます。これはRFC6838[^4]で定義されているもので、「ツリー」（tree）と呼ばれます。ピリオドを持たないサブタイプもツリーの一種とされ、「標準ツリー」（standard tree）と呼ばれます。先に挙げた`image/png`の`png`が標準ツリーの例です。

[^4]: RFC6838 3. Registration Trees and Subtype Names <https://datatracker.ietf.org/doc/html/rfc6838#section-3>

`vnd.`という接頭辞で始まるサブタイプは「ベンダーツリー」（vender tree）と呼ばれます。これは、ベンダー固有のファイルを登録するものです。上記の例では、`image/vnd.microsoft.icon`がベンダーツリーとなっています。

`x.`という接頭辞は、私的利用のために予約されているものです。`x.`で始まるサブタイプはIANAには登録されておらず、ベンダーや開発者が狭い範囲で利用するために独自に定義しているものです。以前は`x.`ではなく`x-`が私的利用のための接頭辞として利用されていましたが、今は`x.`を利用することになっています。
<!--
>   Subtype names with "x." as the first facet may be used for types
   intended exclusively for use in private, local environments.  Types
   in this tree cannot be registered and are intended for use only with
   the active agreement of the parties exchanging them.
-->

私的利用されていたMIMEタイプが広く利用されるようになり、IANAに登録されると、接頭辞は取り除かれます。たとえば、`text/x-javascript`や`application/x-pdf`は、それぞれ`text/javascript`や`application/pdf`として登録されています。ただし稀な例として、互換性のために例外的に`x-`が残ったままIANAに登録されているものもあります。`application/x-www-form-urlencoded`はその例です。<!--  なお、text/x-javascript はIANAに登録されていないので例を変更した -->逆に`x-`なしの`application/www-form-urlencoded`というMIMEタイプは登録されていないので注意してください。<!--  https://datatracker.ietf.org/doc/html/draft-hoehrmann-urlencoded-01 を見ると、もともとは x- なしで登録するつもりだったようだ -->

#### Structured Syntax Suffix

接頭辞ではなく、接尾辞がつくパターンもあります。`image/svg+xml`の`+xml`ように、サブタイプの末尾に`+`で始まる接尾辞をつけます。これは、Structured Syntax Suffixと呼ばれるもので、サブタイプにデータフォーマットの情報を追加するものです。現在ではRFC 6839[^5]で定義されています。

[^5]: RFC 6839 Additional Media Type Structured Syntax Suffixes <https://datatracker.ietf.org/doc/html/rfc6839>

たとえば、カレンダーに登録するスケジュール情報を表現するiCalendarという形式のデータがあります。iCalendarは簡単な改行区切りのテキストデータで表現でき、`text/calendar`というMIMEタイプを使用しますが、XML形式のxCal[^6]、JSON形式のjCal[^7]というフォーマットも存在し、それぞれ`application/calendar+xml`、`application/calendar+json`というMIMEタイプを使用します。このように、同じ意味を持つデータでもフォーマットが異なる場合に、接尾辞によってデータフォーマットを表現できるようになっています。

[^6]: RFC 6321 xCal: The XML Format for iCalendar <https://datatracker.ietf.org/doc/html/rfc6321>
[^7]: RFC 7265 jCal: The JSON Format for iCalendar <https://datatracker.ietf.org/doc/html/rfc7265>

### パラメーター

MIMEタイプは「パラメーター」（parameter）を持つこともあります。パラメーターは「名前」と「値」を"="（等号）で結合したものです。サブタイプとパラメーターの間は`;`（セミコロン）で区切ります。セミコロンの前後には空白を入れることも許されています。たとえば以下のような形式になります。

```text
application/javascript; charset=utf-8
```

あるタイプがパラメーターを持つかどうかは、IANAのMedia Typesの登録情報に記載されています。必須のパラメーターがある場合はRequired parametersの項に、オプションのパラメーターがある場合はOptional parametersの項に記載されす。

たとえば、JavaScriptのスクリプトファイルに利用される`application/javascript`[^8]の場合、以下のようになっています。

[^8]: <https://www.iana.org/assignments/media-types/application/javascript>

>Required parameters: 
>Optional parameters:     charset, see section 4.1.

これは`charset`パラメータを指定可能であり、しかし必須ではないという意味です。タイプが似ていても、パラメータの指定可否は異なる場合があります。たとえば、JSONデータを示す`application/json`[^9]は以下のようになっています。

[^9]: <https://www.iana.org/assignments/media-types/application/json>

>Required parameters:  n/a
>Optional parameters:  n/a

JSONの場合、パラメータは何も指定できません。JavaScriptと異なり、`charset`パラメーターも指定できないのです。これは、現在のJSONの仕様では文字符号化方式がUTF-8で固定になっているためです。

必須パラメータを持つ例には`multipart/form-data`[^10]があります。以下のようになっています。

[^10]: <https://www.iana.org/assignments/media-types/multipart/form-data>

>Required parameters:  boundary
>Optional parameters:  none

`multipart/form-data`を使用する場合、必ず`boundary`パラメーターを指定する必要があり、省略できません。<!-- ちなみに form要素のenctype属性に指定する"multipart/form-data"という文字列は「multipart/form-data encoding algorithmで送信する」という意味のトークンであり、MIMEタイプそのものではない。送信時にはboundaryつきのMIMEタイプが生成される。https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#form-submission-algorithm:attr-fs-enctype-formdata -->

#### `charset`パラメーター

`text/html`や`application/javascript`などのMIMEタイプは、オプションとして`charset`パラメーターを持ちます。これは文字符号化方式を指定するものです。文字集合、文字符号化方式については、「HTMLで扱える文字」の節で後述します。

`charset`パラメーターを指定すると、たとえば以下のようになります。

```text
text/html; charset=UTF-16
text/html; charset=Shift_JIS
text/html; charset=ISO-2022-JP
```

"charcter set"という言葉は文字集合、"character encoding"は文字符号化方式を表す言葉ですが、両者はよく混同されます。`charset`パラメーターにもこの混同があり、実際に指定する値は文字符号化方式の名称となっています。

<!-- security consideration -->
`charset`パラメーターはセキュリティ上、重要な意味を持ちます。コンテンツの文字符号化方式を誤認させることで攻撃が可能になる場合があるからです。たとえば、UTF-8で符号化されたHTMLに以下の文字列が出力されているとします。

```html
+ADw-script+AD4-alert(+ACI-test+ACI-)+ADsAPA-/script+AD4-
```

これは単に意味不明な文字列であり攻撃には至りませんが、これをUTF-7として解釈すると以下のようになります。

```html
<script>alert('test');</script>
```

こうなるとスクリプトが実行されることになります。HTMLに`charset`パラメータが指定されていない場合、攻撃者が何らかの方法で文字符号化方式を誤認させることで攻撃が成立する場合があります。このような理由から、IPAの「安全なウェブサイトの作り方」[^8]では、`Content-Type`フィールドに必ず`charset`パラメーターを指定するように求めています。

[^8]: <https://www.ipa.go.jp/security/vuln/websecurity-HTML-1_5.html>
<!-- /security consideration -->

## MIME sniffing

MIME sniffing（MIMEスニッフィング）は、MIMEタイプが欠落している、またはMIMEタイプが誤って設定されているとブラウザーが判断した場合に、ブラウザーがファイルの内容を見て、MIMEタイプを決定するものです。

歴史的に、古い一部のブラウザーは、サーバーが送信する`Content-Type`ヘッダーを一部無視してsniffingをし、他のブラウザーを異なる解釈をすることがありました。これにより、セキュリティ上の問題を引き起こすことがありました。その一方で誤った`Content-Type`ヘッダーを送信するサーバーも広く存在しています。

各ウェブブラウザーが独自に異なるMIME sniffingを行い、標準仕様が存在しない状況では、サーバー側でセキュリティの問題を回避するための十分な対策を施すのが困難な状態でした。そこで紆余曲折を経てブラウザー側でのMIME sniffingの挙動を整理したものがMIME sniffing Standardとなります。

なお、サーバーは`X-Content-Type-Options`ヘッダーを送信することによりで、MIME sniffingを抑制できます。

<!-- コラム: IEの拡張子判別判別 -->