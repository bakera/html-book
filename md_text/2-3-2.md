# リソースの種類とMIMEタイプ

前節ではURLについて説明しました。URLは、HTMLの他にも画像、CSS、JavaScriptなど、さまざまな種類のリソースを差し示すことができますが、URLにはリソースの種類を示す情報は含まれていません。ここでは、さまざまなリソースの種類と、その判別方法について説明します。

## リソースの種類とその区別

Webで扱われるリソースには、HTMLの他にも画像、CSS、JavaScriptなどさまざまな種類のものがあります。

リソースの種類によって、ブラウザーによる処理は異なります。たとえば、HTMLなら文法解析をしてからレンダリングする必要がありますし、PNG画像なら画像として表示し、SVG画像ならSVGをパースしてから表示することになります。リソースの種類が正しく判別できないと、適切な処理ができません。PNG画像をHTMLとして表示しようとしても文法エラーになるでしょうし、その逆も然りです。

リソースの判別は、セキュリティ上も重要な意味を持ちます。ファイルアップロード機能を持つWebサービスでは、HTMLファイルをアップロードできないようにしているケースが多く見られます。スクリプトを含むHTMLファイルがアップロードされると、クロスサイトスクリプティングの攻撃が可能になるためです。<!-- 牧歌的な時代もあったが私がトドメを刺した http://jvn.jp/jp/JVN465742E4/index.html -->しかし、リソースの種類判別が正しく行われないと、たとえば、HTMLとして解釈可能な文字列を画像の中に含めてアップロードし、それをブラウザーにHTMLと誤認識させることで、攻撃が可能になる場合があります。

このため、リソースの種類を正しく判定して処理することが重要になります。

### 拡張子による判別

手元のパソコンなど、ローカルでファイルを扱う場合には、ファイル名の末尾についた「拡張子」(extension)によって種別を判別するのが一般的です。拡張子が`.html`ならばHTMLファイル、`.png`ならPNG画像、`.svg`ならSVG画像というふうに解釈します。ブラウザーも、ローカルファイルを開く際には拡張子からファイル種別を判定することがあります。

しかし、Web上のリソースは必ずしも拡張子を持ちません。URLの末尾には、拡張子らしき文字列がつくこともありますが、つかないこともあります。

```text
https://example.com/foo/
https://example.com/foo.html
```

また、拡張子らしい文字列があっても、リソースのタイプとは関係ない場合もあります。さらに、末尾にクエリ文字列やパス文字列が追加されることもあります。

```text
https://example.com/foo.php
https://example.com/foo.aspx
https://example.com/foo.php?file=sample.txt
https://example.com/foo.php/bar/baz
```

このようにURLには様々なパターンがあります。Webにおいては、単純に拡張子からファイルの種類を判別することはできないのです。

古いブラウザーの中には、URLに含まれる拡張子らしき文字列を判別に利用するものもありましたが、その挙動は、先に述べたようなセキュリティの問題を多く引き起こしました。現在のブラウザーは、原則として、URLに含まれる拡張子にる判別は行わないようになっています。
<!-- 参考: https://atmarkit.itmedia.co.jp/ait/articles/0903/30/news118.html -->

### HTTP応答へッダと`Content-Type`フィールド

では、Webではどのようにしてリソースの種類を判別しているのでしょうか。Webでリソースを取得する際には、HTTPによる通信が行われます。そして、サーバー側からの応答には、「HTTP応答ヘッダ」(HTTP response header)が含まれています。以下はHTTP応答ヘッダの例です。

```http
Status: 200 OK
Content-Type: text/html; charset=utf-8
Content-Length: 7887
Date: Thu, 19 Aug 2021 10:00:02 GMT
Last-Modified: Tue, 17 Aug 2021 14:00:11 GMT
```

ヘッダにはさまざまな情報が含まれます。先頭を「ステータス行」(status line)、それ以降の行を「ヘッダフィールド」(header field)と呼びます。ヘッダフィールドにはフィールド名とフィールド値が含まれ、`:`で区切られます。

上記の例には、`Content-Type`という名前のフィールドが含まれています。これが、リソースの種類を示すフィールドです。Webでは原則として、HTTP応答ヘッダの`Content-Type`フィールドによってリソースの種類を判別します。上記の例では、このコンテンツがHTMLであること、文字符号化方式がUTF-8であることを示しています。文字符号化方式については「HTMLで扱える文字」の節を参照してください。

### MIMEタイプ

`Content-Type`フィールドに指定する値は、「インターネットメディアタイプ」（internet media type）もしくは「MIMEタイプ」(MIME Types)と呼ばれます。MIMEはMultipurpose Internet Mail Extensionsの略称で、RFC 2046[^2]で定義されています。単に「メディアタイプ」(media type)と呼ばれることもあります。

[^2]: <https://datatracker.ietf.org/doc/html/rfc2046>

MIMEは元々、電子メールの本文や添付ファイルのメディアの種類を示すのに利用されていましたが、これがそのままWebでも利用されるようになっています。MIMEタイプはIANAによって管理されており、登録されているMIMEタイプの一覧をIANAのWebサイトのMedia Typesのページ[^3]で見ることができます。

[^3]: <https://www.iana.org/assignments/media-types/media-types.xhtml>

上記でわかるように、本家であるIANAのサイトでは「メディアタイプ」という呼び名を採用しています。ただし、この呼び方はCSSのメディアクエリーで記述するメディアタイプと紛らわしいため[^4]、本書ではMIMEタイプと呼ぶことにします。

[^4]: この紛らわしさはMIME sniffing Standardでも指摘されています。 <https://mimesniff.spec.whatwg.org/#mime-type-representation>

### MIMEタイプの書式

MIMEタイプは、「タイプ」（type）と「サブタイプ」（subtype）で構成されます。タイプとサブタイプの間は`/`（スラッシュ）で結合します。

```txt
image/png
text/plain
text/html
application/javascript
```

タイプはおおまかなデータの分類を示します。`image`は画像を、`text`はテキストを意味します。ほかにも`application`や`audio`、`font`、`video`といったものがあります。コンテンツ内に複数の内容を含む場合、`multipart`というタイプが使われます。

サブタイプはタイプの細かな分類を示し、多くの場合は実際のデータ形式と結びつきます。`image/png`であれば、PNG形式の画像であることを示します。ただし、MIMEタイプとデータ形式は1対1の対応関係にはなく、複数のMIMEタイプが同じ形式を示すこともあります。たとえば、`text/xml`と`application/xml`は、いずれもXML形式のデータを表します。

中には、データ形式を特定しない曖昧なものもあります。たとえば、`application/octet-stream`は何らかのバイナリデータであることを示しますが、具体的に何のデータであるのかまでは示しません。

#### パラメーター

MIMEタイプは、「パラメーター」（parameter）を持つこともあります。あるタイプがパラメーターを持つかどうかは、IANAのMedia Typesを見るとわかります。必須のパラメーターがある場合はRequired parametersの項に、オプションのパラメーターがある場合はOptional parametersの項に記載されています。

たとえば、JavaScriptのスクリプトファイルに利用される`application/javascript`[^5]の場合、以下のようになっています。

[^5]: <https://www.iana.org/assignments/media-types/application/javascript>

>Required parameters: 
>Optional parameters:     charset, see section 4.1.

これは`charset`パラメータを指定可能であり、しかし必須ではないという意味です。

タイプが似ていても、パラメータの指定可否は異なる場合があります。たとえば、JSONデータを示す`application/json`[^5]は以下のようになっています。

[^6]: <https://www.iana.org/assignments/media-types/application/json>

>Required parameters:  n/a
>Optional parameters:  n/a

パラメータは何も指定できません。JSONはJavaScriptと異なり、`charset`パラメーターも指定することができないのです。これは、JSONの現在の仕様ではUTF-8以外の文字符号化方式が許されていないことによります。

必須パラメータを持つ例には`multipart/form-data`[^7]があり、以下のようになっています。

[^7]: <https://www.iana.org/assignments/media-types/multipart/form-data>

>Required parameters:  boundary
>Optional parameters:  none

`multipart/form-data`を使用する場合、必ず`boundary`パラメーターを指定する必要があり、省略できません。<!-- こうして並べてみるとIANAの登録の記述バラバラで草 -->

パラメーターは「名前」と「値」を"="（等号）で結合したものです。サブタイプとパラメーターの間は`;`（セミコロン）で区切ります。セミコロンの前後には空白を入れることも許されています。たとえば以下のような形式になります。

```text
application/javascript; charset=utf-8
```

### charsetパラメーター



charは、characterの略としてIT業界でよく用いられてきたジャーゴンです。charsetをそのまま解釈すれば文字集合を表しますが、charsetの値は文字エンコーディングです。歴史的にUnicodeが普及する前にはさまざまな文字集合が存在したこと、そして文字集合と文字エンコーディングが混同されてきた名残とも解釈できます。

## サブタイプのパターン

サブタイプにはいくつかの形式が定められており、現在はRFC 6838[^7]で整理されています。

サブタイプは、サブタイプは"`.`"（ピリオド）を区切り文字とする階層構造を持つことができ、これを「ツリー」（tree）と呼びます。以下にいくつかのサブタイプの例を挙げてみます。

```txt
image/png
image/vnd.microsoft.icon
text/x-javascript
image/svg+xml
```

ピリオドを持たないサブタイプは「標準ツリー」（standard tree）と呼ばれます。先に挙げた`image/png`であれば、`png`が該当します。

`image/vnd.microsoft.icon`のように、サブタイプの先頭に`vnd.`という接頭辞がついていることがあります。接頭辞として`vnd.`を持つものは「ベンダーツリー」（vender tree）と呼ばれ、これはベンダー固有のファイルを登録するものです。

`text/x-javascript`のように、サブタイプが`x-`で始まるものは、以前は私的利用のために予約されていたものです。現在では特別な扱いをするものでなく、`x-`で始まるものもIANAに登録されています。RFC 6838では`x-`に代わって`x.`が予約されています。

`image/svg+xml`の`+xml`ように、サブタイプの末尾に`+`で始まる接尾辞がついていることがあります。これは、Structured Syntax Suffixと呼ばれるもので、サブタイプの一般的なファイルの種類を形式的に表すものです。現在ではRFC 6839[^8]で用法が明確化・定義されています。

[^7]: 3. Registration Trees and Subtype Names <https://datatracker.ietf.org/doc/html/rfc6838#section-3>

[^8]: <https://datatracker.ietf.org/doc/html/rfc6839>

## MIME sniffing

MIME sniffing（MIMEスニッフィング）は、MIMEタイプが欠落している、またはMIMEタイプが誤って設定されているとブラウザーが判断した場合に、ブラウザーがファイルの内容を見て、MIMEタイプを決定するものです。

歴史的に、古い一部のブラウザーは、サーバーが送信する`Content-Type`ヘッダーを一部無視してsniffingをし、他のブラウザーを異なる解釈をすることがありました。これにより、セキュリティ上の問題を引き起こすことがありました。その一方で誤った`Content-Type`ヘッダーを送信するサーバーも広く存在しています。

各ウェブブラウザーが独自に異なるMIME sniffingを行い、標準仕様が存在しない状況では、サーバー側でセキュリティの問題を回避するための十分な対策を施すのが困難な状態でした。そこで紆余曲折を経てブラウザー側でのMIME sniffingの挙動を整理したものがMIME sniffing Standardとなります。

なお、サーバーは`X-Content-Type-Options`ヘッダーを送信することによりで、MIME sniffingを抑制できます。




<!-- コラム: IEの拡張子判別判別 -->