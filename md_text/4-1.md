# グローバル属性

HTMLの多くの要素は、個々の要素ごとに異なる独自の属性を持ちますが、属性の中には、複数のHTML要素に共通して利用できるものもあります。
中には、ほとんどすべての要素で共通して利用できる属性もあり、「グローバル属性」(Global attributes) と呼んでいます。ここでは、グローバル属性について説明します。

## グローバル属性とは

グローバル属性とは、ほとんどすべてのHTML要素に共通して利用できる属性です。HTML仕様では、きわめて多数のグローバル属性に言及されています。

グローバル属性の中には、HTML仕様では規定されていないものもあります。WAI-ARIAの仕様で規定されている`role`属性や`aria-*`属性、XMLの仕様で規定されている`xml:lang`や`xml:space`などが典型例です。

本書では、グローバル属性の中でも、HTML仕様で規定されているもの、かつ代表的と考えられるものに絞って紹介します。ここで紹介していないグローバル属性については、仕様を参照してください。

## `title`属性

`title`グローバル属性は、要素に対するヒント、助言の情報を表します。全ての要素に指定できますが、`link`や`abbr`など一部の要素では特別な意味を持つことがあります。詳細は`link`要素、`abbr`要素の項を参照してください。

属性値は任意のテキストで、要素に対するヒントや助言となり得る単語や文章を指定します。

<!-- a11y note -->
ウェブアクセシビリティの観点では、`title`属性の値はユーザーに伝わらない可能性があることに注意してください。

ほとんどのブラウザーでは、要素にマウスポインターを載せた時に`title`属性の値がツールチップとして表示されますが、マウスポインターの利用が必須となる場合がほとんどです。タッチスクリーンやキーボードの操作では、ツールチップを表示させることが不可能な場合があります。

スクリーンリーダーでは、状況によって、`title`属性の値を「アクセシブルな名前」 (accessible name) として利用することがあります。たとえば`img`要素の場合、`alt`属性があれば`alt`属性の値が読まれますが、`alt`属性がなく`title`属性がある場合、`title`属性の値が読まれる場合があります。`input`要素に`label`が結び付けられていない場合にも、同様に`title`属性の値が利用されることがあります。

ただし、`title`属性がどのように利用されるかは要素によっても、スクリーンリーダーの種類によっても異なります。スクリーンリーダーで読ませたいという意図であれば、`title`属性ではなく`aria-label`などのARIA属性の利用を検討した方がよいでしょう。
<!-- /a11y note -->


## `lang`属性

`lang`属性は、指定された要素の言語 (自然言語) を指定します。子孫要素がある場合には、子孫要素にも言語指定が継承されます。

属性値には、BCP47の「言語タグ」(language tag) を指定します。言語タグの詳細は、W3C文書「HTMLとXMLにおける言語タグ」[^1]を参照してください。

[^1]: <https://www.w3.org/International/articles/language-tags/>

日本語を表す言語タグとしては、`ja`もしくは`ja-JP`が利用されます。言語タグは「サブタグ」(subtag) を組み合わせて構成されており、`ja-JP`の場合には`ja`の部分が「言語」（language）サブタグ、`JP`の部分が「地域」（region）サブタグです。ほかによく見るものとして「用字」（script）サブタグがあり、中国語簡体字を表す`zh-Hans`の`Hans`の部分が該当します。<!--他にも、拡張言語、変種、拡張、私用などのサブタグが存在します。-->2つ以上のサブタグを使う場合、ハイフン`-`でつなぎます。

言語タグの例としては、以下のようなものがあります。

- `en` （英語）
- `zh` （中国語）
- `ryu` （沖縄方言）
- `zh-Hant` (繁体字)
- `ja-Hira` （ひらがな）
- `en-GB` （イギリス英語）
- `en-US` （アメリカ英語）
- `zh-Hant-HK` （香港で使われる、繁体字中国語）

用字サブタグや地域サブタグは必須ではありません。言語タグ`ja-JP`は「日本で話される日本語」を意味しますが、通常、これは単に「日本語」と言って指すものと変わらないはずです。必要のないサブタグは指定せず、単に`ja`とするほうが望ましいでしょう。

言語タグは慣習的に言語サブタグを小文字、地域サブタグを大文字で記述することがありますが、`lang`属性の値は大文字・小文字を区別しません。

要素に`lang`属性が指定されていない場合、親要素の言語指定を継承します。このため、`lang`属性を持たない要素であっても、祖先要素に`lang`属性があれば言語の指定が行われていることになります。CSSで特定要素の言語指定を取得したい場合は、`lang`属性の値を見るのではなく、`:lang`擬似クラスを利用してください。

祖先要素にも`lang`属性がない場合、WebページのHTTP応答ヘッダの`Content-Language`の値、`meta`要素で指定された値が参照されます。それらもない場合、言語指定は不明(unknown)となります。基本的には、`html`要素に`lang`属性を設定し、ページ全体の言語を適切に指定するべきです。

<!-- a11y note -->
`lang`属性の値には、主に以下のような用途があります。

- 言語によって適切なフォントやグリフを選択する (漢字を中国語のもの、日本語のものどちらにするかなど)
- 言語によって引用符を選択する (`q`要素の項目も参照してください)
- スクリーンリーダーの音声合成エンジンを選択する
- 翻訳機能を利用する際、翻訳元の言語を特定する

アクセシビリティ上は、特にスクリーンリーダーの音声合成エンジンに影響することが重要です。iOSのVoiceOverは`lang`属性を参照して音声合成エンジンを切り替えます。適切な言語設定が行われていないと、コンテンツを全く読まないこともあるため、言語設定が確実に行われるようにしてください。`html`要素に`lang`属性を設定し、ページ全体の言語を適切に指定しておくべきです。
<!-- /a11y note -->

### XML構文の場合

XML構文の場合、XMLの属性である`xml:lang`属性を使用することもできます。属性値の規則は`lang`属性と同じです。古いHTMLの慣習として、`xml:lang`と`lang`の両方を記述することもありますが、両方を記述する場合は、両者に異なる値を指定してはなりません (大文字・小文字のみの違いは許されます)。

## `style`属性

要素に`style`属性を指定すると、その要素に対してCSSスタイルを設定することができます。属性値にはCSSの「宣言」(declaration)を記述します。セミコロンで区切って複数の宣言を記述することもできます。指定できる値の詳細はW3C仕様の"CSS Style Attributes"[^2]を参照してください。

[^2]: <hhttps://drafts.csswg.org/css-style-attr/>

`style`属性で指定したスタイルは、原則としてその要素のみに適用されます (継承が行われるスタイルは、子孫要素に継承されます)。複数の要素に対してまとめてスタイルを指定したい場合には、`style`要素を使用するか、`link`要素で外部スタイルシートを参照する方がよいでしょう。

JavaScriptによる処理で特定要素の見た目を変更したい場合に、`style`属性の書き換えが行われることがあります。要素の表示・非表示を行うために`style`属性を書き換えるケースもありますが、現在のHTMLでは`hidden`属性を利用することもできます。単に非表示にしたいだけであれば、`hidden`属性を利用するほうが良いでしょう。

なお、`style`属性で指定した宣言の「詳細度」(specificity)は最高となり、他のあらゆるセレクタよりも優先されます。古いCSS仕様ではIDセレクタと同一の詳細度とされていたこともありましたが、現在では`style`属性が優先です。詳細はCSSの仕様[^3]を参照してください。

[^3]: CSS 2.2 の 6.4.3 Calculating a selector's specificity <https://www.w3.org/TR/CSS22/cascade.html#specificity>、および CSS Cascading and Inheritance Level 4 の 6.1. Cascade Sorting Order <https://www.w3.org/TR/css-cascade-4/#cascade-specificity> を参照。

<!-- a11y note -->
`style`属性を利用すると要素の見た目を変更することができますが、見た目の変更はスクリーンリーダーの利用者には伝わらないことがありますので注意が必要です。

`style`属性では原則として見た目が変化するだけですが、`display`プロパティの値を変更した場合、セマンティクスに影響を及ぼすことがあります。`display:none`を指定した場合、視覚だけでなく、スクリーンリーダーでも読まれなくなります。また、`table`関連の要素について`display`を`table`以外のものに変更すると、スクリーンリーダーによっては`table`として扱われなくなることがあります。
<!-- a11y note -->

## `class`属性

`class`属性を利用すると、要素が所属するクラス名を指定することができます。値はスペース区切りのトークンであり、複数の値をスペースで区切って指定することができます。また、空の値(`class=""`)を指定することも可能です (クラス名が指定されていないものとみなされます。意味はありませんが文法エラーにもなりません)。

クラス名はセマンティクス上の特定の意味を持つものではなく、製作者が自由に命名して指定することができます。

### クラス名の用途
クラス名は主に以下のような用途に用いられます。

- CSSのスタイルを適用する
- JavaScriptで使用する
- メタデータとして利用する

#### CSSのスタイルを適用する
最も多い利用法は、CSSのスタイルを適用するためのものでしょう。CSSでは、クラスセレクターを利用して特定のクラス名を持つ要素にスタイルを適用することができます。

```CSS
.global-footer__top {
    margin-top: 3em;
}
```

この用途では、クラス名の命名は開発者の自由です。ただし、無秩序に命名すると運用や管理が困難になる場合があります。スタイルを適用するためのクラス名の命名にはいくつもの流儀があり、さまざまな議論がありますので、参考にしてルールを整えるとよいでしょう。

#### JavaScriptで使用する
JavaScriptから利用することも行われます。DOMの`getElementsByClassName()`メソッドで特定のクラス名を持つ要素を選択することができます。`querySelector()`や`querySelectorAll()`にクラスセレクターを含めて参照することもできます。

後述の`id`属性と異なり、複数の要素に同一のクラス名を指定できます。そのため、複数の要素に一括処理を行いたい場合に便利です。

```html
<button class="js-menu-button">menu</button>
<a class="js-menu-button">menu</a>
<script>
    const menuButtonsCollection = document.getElementsByClassName(`js-menu-button`);
    const menuButtonsArray = Array.from(menuButtonsCollection);
    menuButtonsArray.forEach(element => {
        // いい感じにメニューボタンの処理をする
    });
</script>
```

※上記の例が少し冗長になっているのは、`getElementsByClassName()`の戻り値が`Array`ではなく`HtmlCollection`型のオブジェクトであるためです。直接`foreach()`を呼ぶことはできないので注意してください。

JavaScriptからクラス名を操作する場合、クラス名に`js-`というプレフィクスをつけるケースが見られます。これは仕様で規定されているものではなく、単なる慣習です。こうすることで、CSSで利用しているものとJavaScriptで操作するものとを明確に見分けられるようになります。

なお、`class`という単語が多くのプログラム言語で予約語となっている関係上、DOMでこの属性を参照する場合は`className`プロパティを利用します。一部のブラウザーでは、`setAttribute("class")`で`class`属性の値が変更できないこともあるので注意しましょう<!-- といってもIEだけか? -->。

#### メタデータとして利用する
クラス名をメタデータとして利用する方法もあります。「マイクロフォーマット」(Microformats)と呼ばれる仕様では、HTMLの`class`属性や`rel`属性などを利用して、その要素の意味を表すことができます。以下の例は、マイクロフォーマットの仕様の一つであるh-card[^4]の例です。

[^4]: <http://microformats.org/wiki/h-card>

```html
<div class="h-card">
  <a class="p-name u-url"
     href="https://blog.lizardwrangler.com/" 
    >Mitchell Baker</a> 
  (<a class="p-org h-card" 
      href="https://mozilla.org/"
     >Mozilla Foundation</a>)
</div>
```

`h-`や`p-`の接頭辞のつけられたものがマイクロフォーマットのクラス名です。この例では、ふたつの`a`要素とその内容が、それぞれ人名と織名を表すことがわかるようになっています。

なお、現在のHTMLでは、メタデータを表現するためにマイクロデータを利用することもできます。マイクロデータでは`class`属性は利用せず、`itemprop`などの専用の属性を利用します。詳しくは`meta`要素の項を参照してください。

### クラス名の命名
クラス名に使える文字に制限はありません。日本語の文字や絵文字なども使うことができます。<!--Netscape4では使用できなかったが、今更書くことでもあるまい。-->ただし、`class`属性に空白類文字を含めた場合、複数のクラス名を指定したものとみなされるため、クラス名自体に空白類文字を含めることはできません。

<!-- a11y note -->
仕様では、コンテンツの見た目ではなく性質を表す名前を使うことが推奨されています。ただし、性質によって名付けたからと言って、その性質がユーザーに伝わるわけではないことに注意してください。たとえば、`class=heading`と名付けても、その要素は見出しとして扱われるわけではありません。

要素の振る舞いを記述したい場合には、`class`ではなく`role`などのARIA属性を利用すると良いでしょう。ARIA属性に対してスタイル指定をすると、`class`の指定を省略できることもあります。以下は、特定のクラスに対して非表示のスタイルを適用している例です。

<!--お勧めしない例-->
```html
<style>
    .js-hidden{display: none;}
</style>
<div class="js-hidden">このコンテンツは非表示</div>
```

ARIA属性を利用すると以下のようにすることもできます。`aria-hidden=true`を指定した場合、スタイル指定がなくてもスクリーンリーダーに対して読み上げされないことに注意してください。

<!--ややお勧めの例-->
```html
<style>
    [aria-hidden="true"]{display: none;}
</style>
<div aria-hidden="true">このコンテンツは非表示</div>
```

この例の場合、単純にHTMLの`hidden`属性を使うこともできます。

```html
<div hidden>このコンテンツは非表示</div>
```
<!-- /a11y note -->

## `id`属性

`id`属性を利用すると、要素に対して「ユニークID」(unique identifier)を付与することができます。ユニークIDは単に「ID」と略して呼ぶこともあります[^5]。IDは文書内において唯一でなければならず、1つの文書内に同一のIDを持つ要素が存在してはなりません。

[^5]: 俗称ではなく、仕様で使われている略称です。<https://dom.spec.whatwg.org/#concept-id>

### IDの用途

IDは主に以下のような用途で用いられます。

- URLのフラグメントID
- 他の要素からの参照
- JavaScriptで使用する
- CSSのスタイルを適用する
<!--使用頻度順のためclassとは順番が異なる。CSSのIDセレクタは近年では避けられる傾向にあるため下にした-->

#### URLのフラグメントID
IDの最も代表的な用途は、URLのフラグメントIDでしょう。ページ内の目次から見出しへのリンク、脚注へのリンクなど、ページ内のリンクに利用することができます。

```html
<ul class="toc">
<li><a href="#section1-1">1-1. HTMLについて</a></li>
</ul>
...
<h2 id="section1-1">1-1. HTMLについて</h2>
```

<!-- 互換性メモ -->
古いHTMLではこの用途に`a`要素の`name`属性を利用することがありました。ページ内リンクのことを「アンカーリンク」と呼ぶことがあるのはこの名残ですが、現在では`a`要素の`name`属性は廃止されています。
<!-- /互換性メモ -->

#### 他の要素からの参照
HTMLの要素には、他の要素と連携して機能するものがあり、属性値として他の要素のIDを指定するものがあります。代表例は`label`要素の`for`属性です。

```html
<label for="username01">ユーザー名</label>
...
<input type="text" name="username" id="username01">
```

他にも、`input`要素の`form`属性や`list`属性など、他要素のIDを参照する属性がいくつかあります。また、属性によっては、複数のIDを列挙して参照できるものもあります。`output`要素の`for`属性や、WAI-ARIAの属性である`aria-labelledby`、`aria-describedby`などがその例です。複数のIDを列挙する場合はスペースで区切ります。

```html
<h2 id="form-name">ユーザー情報の登録</h2>
<label for="username01">ユーザー名</label>
<input type="text" name="username" id="username01" aria-describedby="form-name username-desc">
<p id="username-desc">英数8文字以内で入力してください</p>
</form>
```

この例では、入力蘭に対して「ユーザー情報の登録」「英数8文字以内で入力してください」というふたつの説明文がこの順で結び付けられます。
<!-- usemap属性についてふれようかと思ったが使用頻度も低いのでスルーで -->

このとき、複数の要素に同一のIDを指定できないことに注意してください。特に、HTMLを機械的に生成しているケースで、`label`要素などを繰り返し出力しているケースでは、IDの重複が起こりがちです。末尾に連番をつけるなど、IDが重複しないような工夫が必要です。

#### JavaScriptで使用する

JavaScriptで使用する場合、`getElementById()`で要素のIDを指定すると、該当のIDを持つ要素を取得できます。また、`querySelector()`や`querySelectorAll()`にIDセレクターを含めて参照することもできます。

前述の`class`属性と異なり、複数の要素に同一のIDを指定することはできません。そのため、複数の要素に一括処理を行いたい場合には向きません。ページ内に1つしかない要素を処理対象とする際に利用することが多いでしょう。

#### CSSのスタイルを適用する

IDは、CSSのスタイルを適用するために利用することもできます。IDセレクターを利用して、該当するIDを持つ要素にスタイルを適用することができます。

```CSS
#global-footer {
    margin-top: 3em;
}
```

近年のCSS設計では、IDセレクターを使わず、クラスセレクターのみで統一することを好む傾向も見られます。とはいえ、IDセレクターを活用できる局面も多いでしょう。ポリシーと照らし合わせて、必要に応じて利用する・しないを検討するとよいでしょう。

### IDの命名
IDにはほとんど全ての文字が利用できますが、空白類文字を含めることはできません。空白類文字が含まれている場合、文法エラーとなります。`class`属性と異なり、複数のIDを列挙して指定することはできないので注意してください。また、空のID(`id=""`)を指定することもできず、文法エラーとなります。

古いHTMLではIDに使用できる文字列に制限があり、ASCII英字と数字、`-`、`_`、`.`、`:`のみが利用でき、かつ、先頭がASCII英字でなければなりませんでした。また、大文字小文字を区別しませんでした[^6]。

[^6]: HTML4の`id`属性はSGMLのID型の値として定義されており、同時にSGML宣言でNAMECASE GENERAL YESと定義されているためです。正確には、SGMLの処理ルール上は小文字を大文字に変換して解釈することになっています。ただし、実際のブラウザの実装はそうはなっていませんでした。

しかし現在のHTML仕様にはそのような制限はありません。また、大文字小文字は区別されることに注意してください。たとえば、"Test"と"test"というIDは異なるものとみなされます。

```html
<h1 id="test">h1</h1>
<p id="Test">p</p>
<script>
    const test1 = document.getElementById("test");
    console.log(test1); //h1
    const test2 = document.getElementById("Test");
    console.log(test2); //p
    const test3 = document.getElementById("TEST");
    console.log(test3); //null
</script>
```

IDはフラグメントIDとしてURLの一部に含まれることもあり、URLは慣習的に小文字で書かれることから、IDにも小文字が使われやすい傾向があります。英小文字と数字、`-`、`_`のみで命名する場合が多いでしょう。

## `tabindex` 属性

`tabindex`属性を利用すると、その要素がフォーカスを受け取るかどうかを制御することができます。

HTMLの要素の中には、「フォーカス可能」(focusable)とされているものがあります。そのほとんどはユーザーの操作を受け付けるもので、代表例は`a`要素(`href`属性がある場合)によるリンクです。他にも、`input`要素、`button`要素などのフォームコントロールが該当します。具体的には以下の要素がフォーカス可能です。

`a`、`area`、`button`、`iframe`、`input`、`object`、`select`、`summary`、`textarea`
<!--frameもそうなのだけどここでは除外-->

ユーザーがマウスポインタで操作している場合、これらの要素をクリックすると、該当の要素がフォーカスを受け取ります。キーボード操作時には、<kbd>Tab</kbd>キーを押すことで、一定の順序でフォーカスを移動させることができます。この際のフォーカス移動を「シーケンシャルフォーカスナビゲーション」(sequential focus navigation)といい、通常はDOMツリー内の順序 (HTMLソースコード中の出現順) に沿ってフォーカスが移ります。必要な回数だけ<kbd>Tab</kbd>キーを押して目的の要素にフォーカスを移します。多くのブラウザーでは、キーボード操作時にフォーカスリングを表示して、どの要素がフォーカスされているのかをユーザーに伝えます。

多くの要素は、通常はユーザー操作を受け付けず、フォーカス可能でもありません。たとえば、`h1`や`p`、`div`、`span`などは通常、フォーカスを受け取りません。ユーザーがクリックしてもフォーカスを受け取りませんし、<kbd>Tab</kbd>でフォーカスを映すこともできず、JavaScriptから`focus()`メソッドを呼んでも効果がありません。

しかし、`tabindex`属性を使用すると、これらの要素もフォーカス可能にすることができます。`tabindex`属性の属性値には整数を指定し、属性の有無と値の範囲によって挙動が変化します。

### 属性が指定されていない場合
`tabindex`属性自体が指定されていない場合は、フォーカス可能とされている要素だけがフォーカスを受け取ります。その他の要素はフォーカスを受け取りません。

### 0を指定した場合
`tabindex=0`を指定した要素はフォーカス可能になります。利用者がクリックしたり、キーボード操作でフォーカスを移すことができます。

ただし、フォームコントロールに`disabled`属性が指定されて無効になっている場合、`tabindex`を指定してもフォーカス可能にはなりませんので注意してください。`disabled`属性の項も参照してください。

### 負の数を指定した場合
`tabindex=-1`など、負の値を指定した場合、要素はフォーカス可能になりますが、シーケンシャルフォーカスナビゲーションの対象になりません。つまり、キーボード操作でフォーカスを移すことができないということです。クリック操作やJavaScriptの`focus()`メソッドは受け付けます。主にJavaScriptでフォーカスを制御する場合に使用します。

負の数であればどの値でも扱いは同じですが、慣習的に`tabindex=-1`が使用されます。

### 正の数を指定した場合

正の数を指定した場合、`tabindex=0`の場合と同様にフォーカス可能になります。<!--これは仕様上MUST-->

それに加えて、シーケンシャルフォーカスナビゲーションの順序に影響を与える場合があります。<!--こちらはSHOULD-->フォーカス順は通常、DOMツリー内の順序 (HTMLソースコード中の出現順) となりますが、正の値の`tabindex`が指定されている場合、その要素には優先的にフォーカスが移るようになります。複数の要素に正の値の`tabindex`が指定されていると、数値の小さいものが優先され、小さいものから大きいものへと順にフォーカスが移ります (同値の場合は出現順になります)。

フォーカスに関する挙動の厳密な定義は、仕様の"6.5 Focus"[^6]の項を参照してください。

[^6]: <https://html.spec.whatwg.org/multipage/interaction.html#focus>

不用意に指定するとキーボード操作時に混乱を招くことがあるため、正の値を指定することは推奨されません。

<!-- a11y note -->
`tabindex`属性は、特にキーボード操作を行うユーザーに対して大きな影響を与えます。

アクセシビリティ上、フォーカス移動順は重要とされており、WCAG 2.0の達成基準2.4.3「フォーカス順序」[^7]では、「意味及び操作性を損なわない順序でフォーカスを受け取る」ことが要求されています。

[^7]: 参考日本語訳: <https://waic.jp/docs/UNDERSTANDING-WCAG20/navigation-mechanisms-focus-order.html>

`tabindex`属性を指定しない場合、フォーカス移動順はDOMツリー内の順序の通りとなります。通常は、これでユーザーの予想どおりの移動順となるため、そのままで構いません。ただし、CSSなどで要素の見た目上の位置を入れ替えている場合、フォーカス移動順がユーザーの予想に反するものになる場合があります。

このような場合、まずはDOMツリー内の順序を入れ替えることを検討してください。`tabindex`属性に正の値を指定することでフォーカス順を入れ替えることもできますが、`tabindex`属性のない他の要素との関係で混乱を招きやすく、メンテナンス性も悪くなるため、`tabindex`属性によるフォーカス移動順の制御はお勧めしません。

`tabindex=0`を利用すると、キーボードによる操作を支援できる場合があります。`span`や`div`など、通常フォーカスを受け取らない要素に`click`イベントをつけた場合、そのままではキーボード操作ができません。以下はマウスポインタでは操作でき、しかしキーホードでは操作ができない例です。

```html
<div
 onclick="alert('押されました')"
 onkeypress="alert('押されました')">
このあたりを押してしてください
</div>
```

`onkeypress`属性を指定していますが、キーボード操作の場合、そもそもこの要素にフォーカスを移すことが困難です (スクリーンリーダーの機能を駆使するとフォーカスを移せる場合もありますが、簡単ではありません)。`tabindex`属性を指定することで、キーボード操作でもフォーカスを移せるようになります。

```html
<div
 onclick="alert('押されました')"
 onkeypress="alert('押されました')"
 tabindex="0">
このあたりを押してしてください
</div>
```

もっとも、可能であれば`button`要素などのクリック可能な要素を用いる方が良いでしょう。`button`要素であれば、`tabindex`も`onkeypress`も不要になります。

```html
<button
 type="button"
 onclick="alert('クリックされました')">
このあたりを押してしてください
</div>
```
<!-- /a11y note -->

## イベントハンドラーコンテンツ属性

「イベントハンドラーコンテンツ属性」(event handler content attributes)を利用すると、要素のイベントが発生した際にJavaScriptを実行することができます。単にイベントハンドラー属性と呼ぶこともあります。

### イベントハンドラーとは
JavaScriptの処理の中には、逐次実行すれば良いものだけでなく、ユーザーがクリック操作を行う、画像の読み込みが完了するなど、何らかのきっかけをトリガーにして実行したい場合があります。そのようなきっかけとなるものを「イベント」(event)と呼びます。仕様では60以上のイベントが定義されており、キーボード操作やマウス操作、フォーカスの受け取りやフォーカス移動、ページの読み込み、エラー発生などさまざまなものをトリガーにすることができます。MDNのイベントリファレンスも参考になります[^6]。

[^6]: イベントリファレンス | MDN https://developer.mozilla.org/ja/docs/Web/Events

こういったイベントの発生を監視する仕組みを「イベントリスナー」(event listner)と呼びます。イベントリスナーはイベントを監視し、イベントが発生した際に必要な処理を行います。イベントリスナーと、イベント時に実際に実行するコードを組み合わせたものを「イベントハンドラー」(event handler)と呼びます。

### イベントハンドラー属性
イベントハンドラー属性を利用すると、HTMLの要素に対してイベントハンドラーを定義することができます。属性名は`on`で始まり、その直後にイベントの名前が続きます。属性値はJavaScriptのコードとして解釈され、対応するイベントが発生した際に実行されます。

たとえば、`onclick`属性は、要素の`click`イベントに対応するイベントハンドラーを定義します。イベントリスナーは要素の`click`イベントを監視し、要素がクリックされると属性値で指定したスクリプトを実行します。このスクリプト内では、`event`という名前でイベントオブジェクトを参照できます。

```html
<button type="button" onclick="alert(event.offsetX)">click</button>
```

この例では、`MouseEvent`オブジェクトの`offsetX`プロパティの値が表示されます。

### イベントハンドラーの戻り値

イベントハンドラー属性値に指定したJavaScriptを実行後、最終的な戻り値が`false`であった場合、要素の本来の動作がキャンセルされます。これは、イベントの`preventDefault()`メソッドを実行した場合と同じ効果です。以下の例には`a`要素が2つありますが、どちらもクリックしても何も起こりません。

```html
<script>
const example = (event) => {
    event.preventDefault();
}
</script>
<p>
<a href="https://example.com/" onclick="return false">example1</a>
<a href="https://example.com/" onclick="example(event)">example2</a>
</p>
```

なお、`false`を返してもイベントバブルを止める効果はなく、祖先要素のイベントも発生します。イベントバブルを止めるためには、イベントの`stopPropagation()`メソッドを実行する必要があります。

```html
<script>
const example = (event) => {
    event.preventDefault();
    event.stopPropagation();
}
</script>
<p onclick="alert('p clicked')">
<a href="https://example.com/" onclick="return false">example1</a>
<a href="https://example.com/" onclick="example(event)">example2</a>
</p>
```

この例では、1番目のリンクをクリックすると、親要素のイベントが実行されて`p clicked`と表示されます。2番目のリンクでは`stopPropagation()`を呼んでいるため、親要素のイベントは実行されず、何も起こりません。

余談ですが、`button`要素の誤用が原因で`return false`が必要になっているケースを見ることがあります。以下は、ボタンを押すと住所検索ダイアログが表示されるフォームのイメージです。

```html
<form action="https://example.com">
<!-- さまざまなフォームコントロール -->
<button onclick="searchAddress(); return false;">住所検索</button>
<button>送信</button>
</form>
```

「住所検索」ボタンに`return false`を指定しています。これがないと、ボタンのデフォルトの動作であるフォーム送信が行われてしまうためです。実はこれは、`button`要素の`type`属性のデフォルト値が`submit`であることが原因です。ですから`type=button`を指定するだけで防ぐことができます。

```html
<form action="https://example.com">
<!-- さまざまなフォームコントロール -->
<button type="button" onclick="searchAddress()">住所検索</button>
<button>送信</button>
</form>
```

### イベントハンドラー属性を使用しないイベント定義

HTMLのイベントハンドラー属性を利用すると、HTML中にJavaScriptのコードを直接書くことになります。これは便利であるかもしれませんが、JavaScriptのコードが分散し、管理が難しくなる原因にもなります。
また、CSP(Content-Security-Policy)においてはインラインのJavaScriptコードとみなされるため、インラインのコードを禁止する設定ではブロックされてしまいます。

イベントを定義する際、必ずしもHTMLの属性を利用する必要はありません。JavaScriptからイベントを定義することも可能です。以下の例では、`button`要素にイベントリスナーを設定している例です。

```html
<button id="button1">Click Me!</button>
<script>
const hello = (event) => {
    alert("Hello World!");
}
const button = document.getElementById('button1');
button.addEventListener('click', hello, false);
</script>
```

このようにJavaScriptからイベントリスナーを設定するほうがスマートであるため、近年ではHTMLのイベントハンドラー属性を利用することは少なくなっています。

### コラム: イベントハンドラーとイベントリスナー

JavaScriptのイベントを定義する際、「イベントハンドラー」という言葉が使われる場合と、「イベントリスナー」という言葉が使われる場合があります。これらの用語の使い分けは難しく、日常生活では両者をほとんど同じものとして使用することが多いでしょう。

HTML仕様にはイベントハンドラーの用語定義があり、以下のようになっています。

https://html.spec.whatwg.org/multipage/webappapis.html#event-handlers
>An event handler is a struct with two items:
>a value, which is either null, a callback object, or an internal raw uncompiled handler. The EventHandler callback function type describes how this is exposed to scripts. Initially, an event handler's value must be set to null.
>a listener, which is either null or an event listener responsible for running the event handler processing algorithm. Initially, an event handler's listener must be set to null.

ハンドラーは、値とリスナーという2つの項目から構成されるとあります。つまり、イベントに対するリスナーと、その際に実行されるコードをセットにしたものをイベントハンドラーと呼んでいるわけです。


## `accesskey`属性
<!-- a11y/ARIA関連でいろいろ書きたいのでトピックをたてることにした -->

`accesskey`属性を指定すると、要素のショートカットキーのヒントを示することができます。属性値にはキーの文字を指定します。以下は`a`キーをショートカットキーとする例です。

```html
<button type="button" accesskey="1" onclick="alert(1)">click</button>
```

多くのブラウザーでは、ショートカットを利用する際に修飾キーとの同時押しが必要です。たとえば、<kbd>alt</kbd>+<kbd>1</kbd>や<kbd>Control</kbd>+<kbd>Option</kbd>+<kbd>1</kbd>といった操作でこのボタンが反応します。モバイル端末、特にフィーチャーフォンには、修飾キーとの同時押しを必要としないものもあります。古いフィーチャーフォン端末向けのサイトでは、`accesskey`属性を積極的に利用するものが多く見られました。

デバイスによっては、使用できるキーの数が少ない場合もあります。HTML仕様はフォールバックの仕組みも用意しており、複数のキーを空白類文字で区切って指定できることになっています。

```html
<button type="button" accesskey="a 1" onclick="alert(1)">click</button>
```

この場合、`a`キーが利用できる環境では`a`キーで、テンキーのみしか使えないような環境では`1`キーで操作できることが期待されます。ただし、現状のブラウザーのほとんどは、このような複数指定をうまく解釈しません。<!-- JavaScriptで属性値を読み取って使えるようにする方法はある -->

<!-- a11y note -->
不用意にこの属性を利用すると、キーボードによる操作を阻害する場合があります。特に、スクリーンリーダーなどの支援技術は、キーボード操作で多数の機能を利用できるようにしていることがあり、<kbd>alt</kbd>キーや<kbd>Control</kbd>キーなども操作に利用することがあるため、`accesskey`属性によるショートカットと衝突することがあります。

WCAG 2.1の達成基準 2.1.4「文字キーのショートカット」[^8]では、このようなショートカットキーを利用する場合、機能の解除やキー割り当ての変更ができようにすることを求めています。

[^8]: 参考日本語訳:<https://waic.jp/docs/WCAG21/#character-key-shortcuts>

支援技術によっては、ブラウザーに直接キー操作が伝わるモードを持つものもあります。また、`role=application`が指定された要素の中では自動的にモードを切り替え、ブラウザーにキー操作が伝わるようにする場合もあります。ショートカットキーを利用する場合には、このような支援技術のモードについても意識するとよいでしょう。
<!-- /a11y note -->


## その他のグローバル属性

詳細な説明はしないものの、HTMLコードを見ていると出くわす可能性があるものの一部を簡単に紹介します。

- `hidden`属性。要素が現在のページの状態に直接関係がないことを示します。この属性が指定されると、ブラウザーは要素をレンダリングしません。
- `itemid` / `itemprop` / `itemref` / `itemscope` / `itemtype` 属性。HTMLコンテンツにメタデータを記述できるmicrodata（マイクロデータ）のための属性です。
- `translate`属性。翻訳対象とするかどうかを示します。機械翻訳サービスがこの属性を尊重することがあります。
- ARIA `role`および`aria-*`属性。WAI-ARIA仕様に基づいて、追加のセマンティックスを指定するために使用します。WAI-ARIAについては4-2節を参照ください。
- `xmlns`属性。XML名前空間を記述するための属性です。古いHTMLの仕様の中には、記述を求められることがありました。`text/html`では何の効力もありません。





## `data-*`属性
カスタムデータ属性と呼ばれるこの属性は、ウェブ制作者が自由に属性の名前を設定できるものです。`*`は、命名規則に従った自由な文字列を意味します。命名規則に沿ったものであれば、どのような名前であっても構いませんが、概ね次の規則になっています（正確な規則は仕様を参照ください）。

- 文字は、記号類でない文字のほぼすべてです。数字、アルファベット、ひらがなや漢字を含むマルチバイト文字を含めることができます。ただし、アルファベットの大文字`A`から`Z`を使用することはできません。使いやすさのため、アルファベットの小文字のみを使うことがほとんどです。
- 記号類は、ハイフン`-`、アンダースコア`_`を使うことができます。
- 開始してよい文字に制約があります。文字列`xml-`で始めてなりません。また、数字やハイフンで始めてもいけません。

たとえば、次のようなコードでカスタムデータ属性の属性値を取得することができます。JavaScriptのプロパティで属性値を取得するとき、先頭の`data-`を除去したプロパティ名となります。`*`にハイフンを含む場合、名前はキャメルケースで取得します（つまり、ハイフンの次の文字を大文字にしてハイフンを除去します）。

```
<span id="cdtest" 
data-htmlbook-test="これはテストコードです。" 
data-htmkbook_test="もしもし">深い意味はありません</a>
<script>
var e = document.getElementById('cdtest');
window.alert(e.dataset.htmlbookTest);
</script>
```















## コラム: 仕様で言及されているグローバル属性の一覧

2021年7月時点にて、仕様の"3.2.6 Global attributes"で言及されている属性は以下の89種類です。うち64種類がイベントハンドラ属性で、これを除くと25種類ということになります。

accesskey
autocapitalize
autofocus
contenteditable
dir
draggable
enterkeyhint
hidden
inputmode
is
itemid
itemprop
itemref
itemscope
itemtype
lang
nonce
spellcheck
style
tabindex
title
translate
class
id
slot
onauxclick
onblur
oncancel
oncanplay
oncanplaythrough
onchange
onclick
onclose
oncontextmenu
oncopy
oncuechange
oncut
ondblclick
ondrag
ondragend
ondragenter
ondragleave
ondragover
ondragstart
ondrop
ondurationchange
onemptied
onended
onerror
onfocus
onformdata
oninput
oninvalid
onkeydown
onkeypress
onkeyup
onload
onloadeddata
onloadedmetadata
onloadstart
onmousedown
onmouseenter
onmouseleave
onmousemove
onmouseout
onmouseover
onmouseup
onpaste
onpause
onplay
onplaying
onprogress
onratechange
onreset
onresize
onscroll
onsecuritypolicyviolation
onseeked
onseeking
onselect
onslotchange
onstalled
onsubmit
onsuspend
ontimeupdate
ontoggle
onvolumechange
onwaiting
onwheel

これらに加えて、HTML仕様で規定されていないものとしてWAI-ARIAの`role`属性や`aria-*`属性が存在します。XML構文の場合には`xml:lang`や`xml:spce`などXMLの仕様で規定されている属性も利用できます。