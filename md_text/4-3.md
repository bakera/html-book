# ARIA利用時の注意点

WAI-ARIAではさまざまな属性が定義されていますが、誤用や使い過ぎには注意してください。むやみに使っても効果がなかったり、かえって混乱を招いたりすることがあります。WAI-ARIA Authoring Practicesでは、"No ARIA is better than Bad ARIA."という警句がとりあげられています[^99]。

[^99]: <https://www.w3.org/TR/wai-aria-practices/#no_aria_better_bad_aria>

ここでは3つのルールを挙げ、順を追って説明します。

### ARIAルール1：HTML自身に備わっている機能を利用する

HTMLにもともと備わっているネイティブな機能でARIAと同等の表現ができる場合、HTMLの機能を使用します。これは以下のような言い方で表現されることもあります。

「ARIAを使う際に最も注意すべきことは、ARIAを使わないようにすることです。」

以下の2つのHTMLコードは同じ意味です。

<!-- 望ましくない例 -->
```html
<div role="main">
  <div role="heading" aria-level="1">メインコンテンツ</div>
  ...
</div>
```

<!-- 望ましい例 -->
```html
<main>
  <h1>メインコンテンツ</h1>
  ...
</main>
```

この場合、後者の例のように、HTMLのネイティブセマンティクスを利用してください。

### ARIAルール2：冗長なロールやARIA属性を使用しない

ネイティブセマンティクスとWAI-ARIAのセマンティクスを同時に使用する状況もありえます。

<!-- 望ましくない例 -->
```html
<main role="main">
  <h1 role="heading" aria-level="1">メインコンテンツ</h1>
  ...
</main>
```

冗長なロールを追加することは、一般に副作用はありませんが、これもやはり望ましくありません。ARIAの機能とまったく同一の機能がネイティブで利用できる場合は、ネイティブの機能だけを使用し、ARIAを使わないようにすることがARIA in HTML仕様で推奨されています。

かつてのHTML 5.0仕様では、`main`要素に`role="main"`をあわせて指定するようにアドバイスされていました。しかし、これは要素のネイティブロールを解釈できないレガシーユーザーエージェント向けのもので、モダンブラウザーに対してこのように指定する必要はありません。
<!-- see also https://www.w3.org/TR/2018/SPSD-html5-20180327/grouping-content.html#the-main-element -->

プロパティやステートも同様です。たとえば、チェックボックスに対して「チェックされている」という状態を表現したい場合、ARIAの`aria-checked`属性を使うべきではありません。以下は望ましくない例です。

<!-- 望ましくない例 -->
```html
<input type="checkbox" checked aria-checked="true">
```

これは単に冗長なだけでなく、JavaScriptなどから値を制御しなければならないという問題もあります。上記の例でユーザーがチェックボックスのチェックを外しても、`aria-checked`属性の値が自動で`false`に変わることはありません。支援技術にはチェックされていない状態として通知されてしまいます。

以下のように、単にHTMLの`checked`属性を使い、冗長な`aria-checked`属性は使わないようにしましょう。

<!-- 望ましい例 -->
```html
<input type="checkbox" checked>
```

### ARIAルール3：ネイティブセマンティクスをむやみに変更しない

「ロールの上書き」の説明したとおり、ネイティブセマンティクスを変更できる範囲には制限があります。また、変更が許されている範囲であっても、不用意な変更をすると元のセマンティクスが失われ、望ましくない結果を招くことがあります。以下は望ましくない例です。

<!-- 望ましくない例 -->
```html
<div role="tablist">
  <h2 role="tab">見出しタブ</h2>
</div>
```

この例では`h2`要素のロールを`tab`に変更しています。親要素に適切なロールを指定しており矛盾はありませんが、`h2`要素の`heading`ロールが失われるため、見出しであることが伝わらなくなります。この場合は以下のようにするほうが望ましいでしょう。

<!-- 望ましい例 -->
```html
<div role="tablist">
  <div role="tab"><h2>見出しタブ</h2></div>
</div>
```

## 動作検証とアクセシビリティサポーテッド

最後に、筆者が重要だと考えている動作検証についてお伝えします。

アクセシビリティに関する技術や機能が、ブラウザーや支援技術によって十分に対応されて、意図どおりに動作するとき、その状態のことを「アクセシビリティサポーテッド」(Accessibility supported)であるといいます。逆に、ブラウザーや支援技術によるサポートが十分でない場合、アクセシビリティサポーテッドでないということになります。

とくに、WAI-ARIAは比較的新しい技術でもあり、古い支援技術<!-- や日本でよく利用されているPC-Talker+NetReaderなど -->はARIA属性を十分にサポートしていないことがあります。仕様で規定されたARIA属性を適切に利用していても、アクセシビリティサポーテッドでないことがあり、意図どおりに機能しないことがあるということです。

また、ARIAのルールにはかなり複雑な部分があります。ここでも説明してきたように、特定の要素に適用できないロールがある、ロールとARIA属性との組み合わせを許可しない場合がある、他のARIA属性が効果を上書きする場合があるなど、さまざまな注意点があります。正直なところ、これらすべてを正確に把握するのはかなり難しく、正しい効果が予想しにくい場合もあるでしょう。

そこで重要になるのが、動作検証です。検証といっても、大掛かりなものである必要はありません。最近では多くのOSにスクリーンリーダーの機能が組み込まれており、追加のスクリーンリーダーを導入することなく検証できます。ARIA属性を利用するときには、実際にスクリーンリーダーを利用してアクセスし、動作検証を行うようにしましょう。

さらに、可能であれば、普段から支援技術を利用しているユーザーにアクセスしてもらって、その意見を聞くとよいでしょう。ARIAの使いすぎや、説明が冗長であるという意見は、コンテンツの実装者からはなかなか出てこないものです。

アクセシビリティに唯一の正解はありませんが、WAI-ARIAを利用するのは、支援技術でもコンテンツにアクセスしやすくしたいという動機によるものです。支援技術のユーザーに実際にコンテンツにアクセスしてもらい、フィードバックを得ることで、品質を向上できるでしょう。



## ARIA実装時の注意点

具体的な事例に入る前に、ARIAを使った実装を行う際の注意点を3つ説明します。Chapter4-2も参照してください。

### 1. マウスやタップ操作可能なものは、キーボードでも操作可能にする

`div`要素や`span`要素などの要素にJavaScriptで機能を追加し、独自のウィジェットを作ることがあります。Chapter4-2で説明したように、`role`属性を利用すると、それが操作可能なコントロールであることを伝えられます。

注意しなければならないのは、WAI-ARIAは機能を追加しないことです。ロールを指定しても、自動的に操作可能になるわけではありません。たとえば、以下の例では`div`要素に`role=button`を指定ています。

```html
<div role="button" onclick="pushedButton()">素敵なボタン</div>
<script>
const pushed = () =>{
  alert('押されました'); // ボタンを押されたときの処理
}
</script>
```

この要素はボタンとしてのセマンティクスを持ち、支援技術にはボタンであると伝えられます。また、ボタンを押した際の動作は`onclick`属性に記述したJavaScriptで実現しています。マウスでクリックするとボタンのように動作し、問題ないように見えますが、以下のような機能はありません。

- キーボードの<kbd>Tab</kbd>キーでフォーカスを当てる
- キーボードの<kbd>Enter</kbd>キー、<kbd>Return</kbd>キー、<kbd>space</kbd>キーでボタンを押す

つまり、このボタンはキーボード操作ができません。

ユーザーがクリック、タップ、ドラッグ、ドロップ、スライド、スクロールといった各種の操作を行えるとき、キーボードのみの環境でも同等の操作を実現できるようにする必要があります。これは、WCAG 2.1達成基準2.1.1キーボード[^2]の要請であり、アクセシビリティ上の重要事項でもあります。

[^2]: <https://www.w3.org/TR/WCAG21/#keyboard>

スマートフォンなど、典型的にはタップ操作を行う環境でも、キーボード操作への対応は必要です。Bluetoothキーボードを接続することも可能ですし、スクリーンリーダーを利用する場合はキーボード操作に準じた操作が必要になります。

ARIAを併用したキーボード操作の考え方については、WAI-ARIA Authoring PracticesのDeveloping a Keyboard Interfaceが参考になります。[^aria-keyboard]

[^aria-keyboard]: <https://www.w3.org/TR/wai-aria-practices-1.2/#keyboard>

### 2. 操作可能な要素を隠さない

要素に`aria-hidden="true"`を指定しても、フォーカス移動には影響しません。フォーカス可能な要素に`aria-hidden="true"`を指定すると、フォーカスはあたり、しかし支援技術からはその要素が見えなくなります。このため、支援技術のユーザーはフォーカスを見失ってしまいます。

<!-- 望ましくない例 -->
```html
<button aria-hidden="true">支援技術に「見えない」がフォーカスは当たるボタン</button>
```

フォーカスが当たらなければ問題は起きないため、視覚環境も含めたすべての環境から要素を隠したり、フォーカスを無効にすれば問題を回避できます。以下はこの問題が起きない例です。

<!-- 問題のない例 -->
```html
<button hidden>すべての環境から隠されたボタン</button>
<button aria-hidden="true" disabled>無効のボタン</button>
<button aria-hidden="true" tabindex="-1">フォーカスの当たらないボタン</button>
```

逆に、フォーカス可能な要素を視覚的に隠し、支援技術からはアクセス可能にした場合にも問題が起きます。この場合、視覚環境でキーボード操作したユーザーは、見えない要素にフォーカスが当たってフォーカスを見失ったり、操作できることを想定していない要素が操作できてしまうことがあります。

意図的に隠す場合だけでなく、ある要素が別の要素に重なって視覚的に見えない場合や、ある領域が操作不能であることを示すために視覚的にグレーアウトした場合にも同様の問題が起こることがあります。

### 3. 操作可能な要素にアクセシブルな名前を持たせる

操作可能な要素、すなわちインタラクティブな要素には、アクセシブルな名前を付けなければなりません。以下は不適切な例です。

<!-- 不適切な例 -->
```html
<button><span class="menu-icon"></span></button>
```

このような空の要素を用意し、CSSでアイコンを表示して、アイコンボタンとして利用するケースがあります。この要素はアクセシブルな名前を持ちません。スクリーンリーダーの利用者がこのボタンにフォーカスした場合、単に「ボタン」と読み上げられるだけで、何をするボタンなのかわかりません。

操作可能な要素には、アクセシブルな名前を与える必要があります。ARIA 1.2のRoles Supporting Name from Author[^99]では名前を与えられるロールを定めていますが、この一覧で「(name required)」とされているロールには、必ず名前を与えなけばなりません。

[^99]: <https://www.w3.org/TR/wai-aria-1.2/#namefromauthor>

名前を与える方法はいくつかあります[^99]。以下の属性が利用できます。

[^99]: 複数の方法でアクセシブルな名前を与えた場合、どれか1つが採用されます。算出方法については Accessible Name and Description Computation を参照してください。 <https://www.w3.org/TR/accname/>

- `aria-labelledby`属性 (Chapter4-2)
- `aria-label`属性 (Chapter4-2)
- `title`属性 (Chapter4-1)

また、ラベル付け可能要素を利用している場合は、`label`要素で名前を与えることができます。Chapter3-9の`label`要素を参照してください。

要素のロールによっては、内容のテキストがアクセシブルな名前となる場合があります[^99]。前述の例で利用していた`button`要素もその例に含まれます。`button`要素の内容にテキストを入れれば、アクセシブルな名前を与えることができます。以下の例は「メニュー ボタン」と読まれることが期待できます。


[^99]: 内容がアクセシブルな名前となる要素の一覧は、WAI-ARIA仕様の 5.2.7.5 Roles Supporting Name from Content で確認できます。 <https://www.w3.org/TR/wai-aria/#namefromcontent>

<!-- 適切な例 -->
```html
<button><span class="menu-icon">メニュー</span></button>
```

画像の代替テキストもアクセシブルな名前となります。

<!-- 適切な例 -->
```html
<button><img src="menu-icon.png" alt="メニュー"></button>
```

CSSの`::before`擬似要素や`::after`擬似要素で追加したテキストもアクセシブルな名前に含まれます。以下は擬似要素を利用した例です。

<!-- 適切な例 -->
```html
<style>
  .menu-icon::before{
    content: "メニュー";
  }
</style>
...
<button><span class="menu-icon"></span></button>
```

この例も「メニュー ボタン」と読まれることが期待できます。擬似要素はスクリーンリーダーで読まれないという誤解も見られますが、近年のスクリーンリーダーのほとんどは、擬似要素に含まれるテキストも問題なく読み上げます。

実際にアクセシブルな名前として認識されるかどうかは、ブラウザーの開発者ツールで確認できる場合があります。たとえばChromeでは、要素を「検証」して開発者ツールを開き、"Accessibility"パネル[^99]を開くと確認できます。

![Chrome開発者ツールのAccessibilityパネル](../img/4-2-02.png)

[^99]: 環境によっては「ユーザー補助」と訳されている場合もあります。


#### 操作可能でない要素とアクセシブルな名前

インタラクティブでない要素にも、アクセシブルな名前をつけられる場合があります。先にも紹介したARIA 1.2のRoles Supporting Name from Author[^99]では、どのロールが名前付け可能かを定義しています。

[^99]: <https://www.w3.org/TR/wai-aria-1.2/#namefromauthor>

よくあるのは、ランドマークにアクセシブルな名前を与えるケースです。たとえば、1つのページに複数の`nav`要素がある場合、スクリーンリーダーのユーザーがランドマークにジャンプすると、どれも「ナビゲーション ランドマーク」としか読まれず、区別できません。そこで、たとえば`aria-label`属性で名前を与えることがあります。

<!-- 問題はないがユーザーが理解できるか怪しい例 -->
```html
<nav aria-label="パンくずナビゲーション">
  <!-- ヘッダーナビゲーション -->
</nav>
...
<nav aria-label="グローバルナビゲーション">
  <!-- グローバルナビゲーション -->
</nav>
...
<nav aria-label="フッターナビゲーション">
  <!-- フッターナビゲーション -->
</nav>
```

ただし、この名前が有用かどうかはまた別の話です。「パンくずナビゲーション」「グローバルナビゲーション」と言われたとき、ユーザーは内容を想像できるでしょうか。名前で説明することを考える前に、多数の`nav`要素を区別させなければならない状況自体を改善するべきです。

名前がなくてもコンテキストで理解できるケースもあります。

<!-- 不自然な望ましくない例 -->
```html
<header>
  <nav aria-label="ヘッダーナビゲーション">
    <!-- ヘッダーナビゲーション -->
  </nav>
</header>
...
<footer>
  <nav aria-label="フッターナビゲーション">
    <!-- フッターナビゲーション -->
  </nav>
</footer>
```

この例では`nav`要素に「ヘッダーナビゲーション」「フッターナビゲーション」と名付けていますが、それぞれの`nav`要素がヘッダー内・フッター内にあることは要素のセマンティクスからも明らかです。この名前によって得られる情報は、さほど有用なものではありません。

インタラクティブでない領域に`aria-label`属性や`aria-labelledby`属性を用いてアクセシブルな名前を与える場合は、本当に必要かどうかを考えた上で提供するようにしましょう。

## 基本テクニック

ARIA実装のテクニックには、様々な局面で利用でき、応用が効くものもあります。ここでは、その基本テクニックをいくつか紹介します。

### アクセシブルな名前を提供する方法

前述したように、要素にアクセシブルな名前を提供する方法は複数あります。
実装時には、どの方法を採用すれば良いか迷うかもしれません。WAI-ARIA Authoring Practices 1.2のCardinal Rules of Naming[^aria-accnameing]では、名前を与える際に考えるべきこととして、5つのルールが紹介されています。

[^aria-accnameing]: <https://www.w3.org/TR/wai-aria-practices-1.2/#naming_cardinal_rules>

- (仕様に反しない実装をしないように) テストを行い、警告に注意する
- 可視のテキストを使う
- HTMLのネイティブ機能を使う
- (`title`属性や`placeholder`属性などによる) ブラウザのフォールバックに頼ることは避ける
- 簡潔で有用な名前をつける

筆者が特に重要だと考えるのは、可視のテキストを使うこと、HTMLのネイティブ機能を使うことです。コントロールに`label`要素で名前をつけることは、その両方を満たす方法であり、ベストな方法と言えます。

ビジュアルデザインの制約などでラベルを設けるスペースがない場合でも、たとえばフローティングラベル（floating label）[^floating-label]と呼ばれる手法を用いると、可視のラベルテキストを確保することができます。

[^floating-label]: Bootstrapの例が参考になります。 <https://getbootstrap.com/docs/5.1/forms/floating-labels/>

インタラクティブでない要素に名前を与える場合も、考え方の基本は同じです。この場合、`label`要素は利用できませんが、`aria-labelledby`属性を用いて可視のテキストと関連付けることができます。こうすることで、支援技術を利用するユーザー、利用しないユーザーの双方に情報が伝わります。

<!-- 可視テキストを関連付けた例 -->
```html
<nav aria-labelledby="product">
  <div id="product">製品</div>
  <!-- 製品ページへのリンクのナビゲーションリスト -->
</nav>
```

もっとも、`nav`要素はセクショニングコンテンツでもあるため、内容の先頭に見出しがあれば、セクションの見出しとして扱われます。上記の例では、`div`要素を見出しに変更し、`aria-labelledby`属性を削除してもよいでしょう。
<!--
以下にaria-labelに関する記述があるが、筆者としてはネガティブな立場。（わざわざ見出しと関連付けしなくてもよい）
https://www.w3.org/TR/wai-aria-practices-1.2/#aria_landmark
https://www.w3.org/TR/wai-aria-practices-1.2/#naming_with_aria-label
-->

### スクリーンリーダー向けテキストを提供する

要素の内容がアクセシブルな名前として扱われる場合、スクリーンリーダーに読み上げさせる専用のテキストを入れる方法もあります。

```html
<button>
  <span class="visually-hidden">メニュー</span>
  <span class="menu-icon"></span>
</button>
```

`visually-hidden`は、視覚環境で表示されず、かつスクリーンリーダーでは読み上げられるようなスタイルを定義したクラスです。CSSフレームワークは、このようなクラスをあらかじめ用意していることがあります[^99]。たとえば、Bootstrap 5.0の`visually-hidden`[^4]には、以下のようなスタイルが定義されています。

[^99]: 実際のクラス名はフレームワークによって異なります。ほかには`sr-only`などが使われることもあります

[^4]: <https://github.com/twbs/bootstrap/blob/main/scss/mixins/_visually-hidden.scss>

```css
.visually-hidden {
  position: absolute !important;
  width: 1px !important;
  height: 1px !important;
  padding: 0 !important;
  margin: -1px !important;
  overflow: hidden !important;
  clip: rect(0, 0, 0, 0) !important;
  white-space: nowrap !important;
  border: 0 !important;
}
```

こうしておくと、テキストはスクリーンリーダーで読み上げられ、かつ視覚環境には影響を与えません。

このテクニックは、ボタンの外でも使えます。任意の`span`要素や`div`要素などにこのクラスを指定することで、テキストをスクリーンリーダーだけに読み上げさせることができます。

このテクニックを利用する際は、先に紹介した「操作可能な要素を隠さない」という原則に注意してください。原則として、操作可能な要素に適用すべきではありません。以下は、Chapter3-5で紹介した「スキップリンク」に`visually-hidden`を適用し、視覚的に隠した例です。

<!-- 問題のある例 -->
```html
<body>
  <div class="visually-hidden">
    <a href="#content">メインコンテンツへ</a>
  </div>
...
  <main id="content">
```

この場合、スキップリンクは視覚的に隠されていますが、キーボードフォーカスは受け取ります。視覚環境を利用するキーボードユーザーは、フォーカスを見失ってしまうことになります。

### キーボードフォーカスを制御する

フォーカス可能でない要素は通常はキーボードフォーカスを受け取れませんが、Chapter4-1で紹介した`tabindex`属性を利用すると、フォーカスを受け取れるようになります。

`tabindex="0"`を指定すると、ユーザーがフォーカスを移動してフォーカスを当てられるようになります。以下は`div`をフォーカス可能にする例です。

```html
<div class="button" tabindex="0">
ボタン?
</div>
```

ただし、これだけでは単にフォーカスが当たるだけで、他の機能は持ちません。フォーカスを当てた後に何か操作をさせたい場合、それは自力で実装する必要があります。前述の「マウスやタップ操作可能なものは、キーボードでも操作可能にする」も参照してください。

`tabindex="-1"`を指定した場合、ユーザーがフォーカスを当てることはできませんが、JavaScriptの`focus()`メソッドでフォーカスを移せるようになります。たとえば、ユーザーがボタンを押した際に別の場所にフォーカスを移動したい場合などに利用します。

ただし、予想外のフォーカス移動が行われるとユーザーは混乱します。基本的には、ユーザーの何らかの操作をトリガーにするようにしてください。
