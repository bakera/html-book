# スクリプティング

この節では、スクリプトを扱う`script`要素と、スクリプトに関連するいくつかの要素を紹介します。

ここで紹介する要素のほとんどは、スクリプト（通常はJavaScript）による処理を前提としています。本書ではスクリプトの内容については扱いませんので、ここでは簡単な紹介に留めます。詳細を知りたい場合は仕様を参照してください。

## `script`要素

`script`要素を利用すると、HTML内にスクリプトを埋め込んだり、外部のスクリプトを参照することができます。スクリプトを利用すると、ユーザーの操作に応じてWebページの内容を動的に変化させる、コンテンツを動的に読み込んで表示するなど、さまざまな処理が可能になります。

`script`要素はテキストをマークアップするものではなく、特定のセマンティクスを持ちません。他のHTML要素とは異なり、ユーザーに何かを提示するものではありません。
<!--
 spec: 4.12.1
 https://html.spec.whatwg.org/multipage/scripting.html#the-script-element
-->

`script`要素は、ほとんどの要素の子要素になることができます。この要素は、"Metadata"であり"Flow"であり"Phrasing"でもあり、さらに
"Script-supporting element"にも分類されます。

"Script-supporting element"は、通常他の要素が配置できない場所にも使用できます。たとえば、`ul`要素の子要素は通常は`li`のみで、`div`要素などを置くことはできませんが、`script`要素は`ul`要素の直下に出現することができます。以下は文法的に問題のないマークアップです。

```html
<ul>
<script>
    document.write('<li>');
    document.write(new Date);
    document.write('</li>');
</script>
</ul>
```

このように、`script`要素はたいていの要素の子要素となることができますが、本書では各要素の内容モデルの説明から"Script-supporting element"を省いていますのでご注意ください。
<!--
fieldset > script + legend がエラーになるような話はあるが説明必要か? legendなしの fieldset > script は許されているのがまたややこしい
-->


### `type`属性による判別

`type`属性を指定すると、この要素のタイプを規定することができます。

`script`要素には大きく分けて3種類の用途があり、それぞれ「クラシックスクリプト」(classic scripts)、「モジュールスクリプト」(module scripts)、「データブロック」(data blocks)と呼ばれます。

#### クラシックスクリプト
`type`属性にJavaScriptを意味するMIME typeの値[^1]、たとえば"application/javascript"や"text/javascript"などを指定すると、クラシックスクリプトとして扱われます。`script`要素の内容、もしくは`src`属性で指定したリソースはJavaScriptのスクリプトとして解釈され、実行されます。
<!--
 the JavaScript Script top-level production. 
-->

[^1]: クラシックスクリプトとみなされる値の正確な一覧は、MIME Sniffing Living Standard で確認することができます。<https://mimesniff.spec.whatwg.org/#javascript-mime-type>

`type`属性を省略した場合や、空の値を指定した場合もクラシックスクリプトとみなされます。HTML4では`script`要素の`type`属性は必須でしたが、現在では省略可能です。クラシックスクリプトを意図する場合は省略することが推奨されています。
<!--
仕様で結構強めに省略すべきと書かれている (should) 
Authors should omit the type attribute instead of redundantly setting it.
-->

<!-- 互換性メモ -->
<!-- マニアックな話なのでコラム扱いでも良い -->
古くに書かれたHTMLでは、`type`属性の代わりに`language`属性が指定されていたこともありました。現在のHTMLでは`language`属性は廃止されており、指定すると文法違反になります。

ただし、過去との互換性のために、ブラウザーは`language`属性によるタイプ判定を行うことがあります。`type`属性が指定されておらず、かつ`language`属性に空でない値が指定されている場合、"text/" に続けて`language`属性の値を連結した値が`type`属性に指定されているものとみなします。

たとえば、`type`属性がなく、`language=vbscript`が指定されている場合は、`type=text/vbscript`が指定されているものとみなします。これは結果としてデータブロックになります (仮にVBScriptが書かれていても、現在のHTML仕様上は、それが実行されることはありません)。`language=javascript`が指定されている場合は、`type=text/javascript`とみなされてクラシックスクリプトとして扱われます。

なお、`type`属性が指定されている場合は、`language`属性がタイプ判定に利用されることはありません。`language`属性が指定された古いHTMLを修正する機会があれば、`language`属性は削除し、クラシックスクリプト以外のものにだけ`type`属性を指定すると良いでしょう。
<!-- /互換性メモ -->

#### モジュールスクリプト

`type`属性の値として"module"を指定すると、モジュールスクリプトとして扱われます。`script`要素の内容、もしくは`src`属性で指定したリソースはJavaScriptのモジュールとして読み込まれます。
<!--
モジュールについてはこちら参照
https://developer.mozilla.org/ja/docs/Web/JavaScript/Guide/Modules
-->
モジュールはECMAScript 2015で新たに導入されたもので、スクリプトをモジュール分割して扱えるようにしたものです。モジュールでは`export`で必要な機能を公開し、それを`import`で読み込んで利用できます。利用法の詳細は本書では説明しませんので、JavaScriptのチュートリアル等をご参照ください。

モジュールは比較的新しい機能であるため、モジュールを扱えない古いブラウザーにフォールバックを提供するための`nomodule`属性が用意されています。詳しくは後述の`nomodule`属性の項を参照してください。

モジュールスクリプトは即時実行はされず、常に遅延読み込みれされます。そのため、`defer`属性を指定しても無視されます (常に`defer`属性が指定されているかのように動作します)。詳しくは`defer`属性、`async`属性の項を参照してください。

#### データブロック

`type`属性が妥当なMIME typeであり、かつJavaScriptを意味するものでない場合、`script`要素はデータブロックとして扱われます[^2]。

[^2] 正確には、クラシックスクリプトにもモジュールスクリプトにも当てはまらない値は全てデータブロックとみなされます。しかし仕様では、`type`属性はMIME typeでなければならないとされています。これは、将来の仕様で`type`属性に"module"以外のキーワードが使えるようになった際に、誤動作しないようにするためです。

ブラウザーは、データブロックに対して何の処理も行いません。内容がスクリプトとして実行されることもありませんし、Webページに表示されることもありません。`script`要素の属性のうち、`type`以外の属性は指定できず、すべて無視されます (`id`などのグローバル属性は有効です)。[^3]

[^3]: データブロックに指定できない属性は次の7つです: "src", "async", "nomodule", "defer", "crossorigin", "integrity", "referrerpolicy"


スクリプトからは内容を参照できるため、Webページに表示したくないデータを埋め込んでおくのに利用できます。また、クローラーによって処理される場合もあります。
<!--
スペックから例を持ってくるべきか、
https://ginpen.com/2011/12/22/built-any-data/
こんな感じのそれっぽいスクリプトもどきも書くべきか。
-->
次のコードは、データブロックを利用してテキストデータを埋め込んでいる例です。

<!-- いちおう動く例にしてみた -->
```html
<script type="text/x-message-data" id="data1">
Welcome!
You are lucky!
</script>
<script>
  const data = document.getElementById("data1").text;
  alert(data);
</script>
```

データブロックの内容はwebページには表示されません。続くスクリプトで、DOM操作によってデータの内容を取得しています。

JSONデータを埋め込むこともできます。以下は、JSON-LDによるメタデータを埋め込んでいる例です。
<!--
JSON-LDについてはx.x節を参照してください。
どこで説明？
1-3で名前だけ出ている
-->

```html
<script type="application/ld+json">
{
  "@context":"https:\/\/schema.org",
  "@type":"BreadcrumbList",
  "itemListElement": [
    {
      "@type":"ListItem",
      "position":1,
      "item":{
        "@id":"https:\/\/www.example.com",
        "name":"example"
      }
    } 
  ]
}
</script>
```

このようにJSON-LDによるメタデータを埋め込むと、検索エンジンのクローラーがこれを認識してメタデータを取得することがあります。

### `src` 属性とインラインスクリプト

`src`属性を利用すると、外部スクリプトのURLを指定して読み込むことができます。`src`属性が指定されていない場合、`script`要素の内容がスクリプトとして解釈されます。

`src`属性を指定している場合、`script`要素の内容に意味のあるスクリプトを書くことはできません[^4]。内容があるとエラーとなりますが、その場合は内容は無視され、`src`属性の指定が優先されます。

[^4]: JavaScriptのコメントと改行、空白類文字のみが許されます。詳細は仕様を参照してください。<https://html.spec.whatwg.org/multipage/scripting.html#inline-documentation-for-external-scripts>

ただし、`script`要素がデータブロックである場合には`src`属性を指定できず、`src`属性の方が無視されることになります。データブロックの項目も参照してください。

`src`属性を用いた外部スクリプトの指定例は、たとえば次のようになります。

```html
<script src="sample.js"></script>
<script type="module" src="libs.mjs"></script>
```

内容が空であっても、`script`要素の終了タグが省略できないことに注意してください。

#### セキュリティ上の注意点: スクリプトのクロスオリジン参照

`src`属性には任意のURLを指定できます。Webページと異なるドメインのURL、すなわち、オリジンが異なるURLを指定することも可能です。

クラシックスクリプトでは、外部スクリプトの読み込みにはオリジンの制限がなく、クロスオリジンでスクリプトを読み込むことが可能です。実際に、アクセス解析や広告埋め込みのスクリプトを他サイトから読み込むことは広く行われています。また、かつて利用されていたJSONP (JSON with Padding) は、この性質を利用してオリジン間の通信を可能にしたものです。

秘密情報をスクリプトとして出力した場合、そのデータは悪意あるサイトからクロスオリジンで参照されてしまう可能性があるため注意が必要です。

なお、モジュールスクリプトはクラシックスクリプトと異なり、クロスオリジンでの読み込みにはCORSと同様の制約があります。別ドメインに置いてあるモジュールを読み込もうとしたり、ローカル環境で`file:`スキームのURLを使用したりするとCORSエラーとなりますので注意してください。

### `defer`属性および`async`属性

`src`属性で外部スクリプトを指定して読み込む場合、`defer`属性や`async`属性を使用すると、スクリプトの読み込みや実行のタイミングを制御することができます。`defer`属性と`async`属性はいずれも真偽値属性です。

通常、ブラウザーはHTMLを先頭から順に解析していきますが、`script`要素に遭遇すると、それ以降のHTMLの解析を中断し、スクリプトの取得 (フェッチ/fetch) と実行を行います。そして、スクリプトの実行が完了してから後続のHTMLの解析を再開します。スクリプトの読み込みや実行に時間がかかると、HTMLの解析処理が長時間ブロックされ、Webページの表示に時間がかかることがあります。

`defer`属性を指定すると、HTMLの解析と並行してスクリプトを読み込みます。そして、スクリプトの読み込みが終わり、かつ、HTMLの解析が終わったときに実行されます。言い換えると、JavaScriptの`DOMContentLoaded`イベントが発生するタイミングで初めて実行されます。

`async`属性を指定すると、`defer`属性と同様、HTMLの解析と並行してスクリプトを読み込みますが、`async`ではHTMLの解析完了を待たず、スクリプトの読み込みが終わって実行できるようになったタイミングで実行します。このため、実行開始のタイミングは不定であり、実行開始時点でHTMLの解析が終わっていないことがあります。`async`属性が指定された`script`要素が複数ある場合、HTMLソースに記載された順番通りに実行されないこともあります。

`defer`属性と`async`属性を同時に指定した場合は、HTMLの解析完了を待たない挙動、つまり`async`属性の挙動になります。古いブラウザーには、`defer`属性を理解するものの`async`属性を理解しないものがあり、そのようなブラウザーの互換性のために両方を指定することがあります。

なお、モジュールスクリプトの場合には、デフォルトで並行読込が行われ、HTMLの解析完了を待って実行されます。これは`defer`属性が指定されている場合の振る舞いと同様です。言い換えると、モジュールスクリプトでは`defer`属性の有無は影響なく、同じ動作になります。`async`属性を指定した場合には動作が変わり、HTMLの解析完了を待たずに実行されるようになります。

![async属性とdefer属性の違いを示した図](https://html.spec.whatwg.org/images/asyncdefer.svg)
<!--要日本語化？-->
<!-- 超速本P.102あたりも参照 -->

スクリプトの処理内容によっては、単純に`defer`や`async`を指定するとうまく動作しないことがあります。たとえば、`document.write()`を実行しているスクリプトを`defer`や`async`で実行するとエラーになります。Chromeではコンソールに以下のようなエラーメッセージが出力されます。

>Failed to execute 'write' on 'Document': It isn't possible to write into a document from an asynchronously-loaded external script unless it is explicitly opened.

`document.write()`以外にも、HTMLのDOMツリーを参照するような処理が動作しなくなることがあります。DOMContentLoadedイベントをトリガーにして動作させるなど、スクリプト側で遅延実行を想定した実装をしておく必要があります。

なお、`defer`属性や`async`属性を指定できるのは、`src`属性で外部スクリプトを読み込んでいる場合だけです。`src`属性がない`script`要素にこれらの属性を指定することはできず、文法エラーとなります。

### `nomodule`属性

`nomodule`属性を利用すると、モジュールを扱えない古いブラウザーにフォールバックを提供することができます。以下は、モジュール"app.mjs"と、フォールバック用のクラシックスクリプト"classic-app.js"を扱う例です。

```html
<script type="module" src="app.mjs"></script>
<script nomodule src="classic-app.js"></script>
```

モジュールスクリプトをサポートするブラウザーは、`nomodule`属性が指定されたクラシックスクリプトを無視します。そのため、"app.mjs"のみを実行します。

一方、モジュールをサポートしないブラウザーは`type=module`を理解できないため、モジュールスクリプトは無視されます。そして`nomodule`属性を理解しないため、"classic-app.js"を実行します。

### crossorigin属性

`crossorigin`属性を指定すると、`src`属性で指定されたリソースをクロスオリジンで参照する際の挙動を制御することができます。

`crossorigin`属性が指定されていない場合は、単純なGETリクエストでリソースを取得しようとします。CORS (Cross origin Resource Sharing) のリクエストは行われません。

`crossorigin`属性が指定されていると、CORSによるリクエストを行います。この場合、リクエストに`Origin:`などのCORS関連のヘッダが追加されて送信されるようになり、エラー時には`window.onerror`で詳細なエラー情報が取得できることがあります。
<!--
https://developer.mozilla.org/ja/docs/Web/HTML/Element/script
>crossorigin
>通常の script 要素は標準の CORS チェックに通らないスクリプトに対して、 window.onerror (en-US) に最小限の情報しか渡しません。別のドメインを使用するサイトに静的メディアへのエラーログ出力ができるようにするためには、この属性を使用してください。有効な値について、詳しくは CORS 設定属性をご覧ください。
-->

`crossorigin`属性が空か、あるいは"anonymous"が指定されている場合は、匿名のCORSリクエストでリソースを取得しようとします。この場合、HTTP認証やCookieなどのクレデンシャル情報は、同一オリジンに対してのみ送信されるようになります。クロスオリジンの場合には送信されません。

`crossorigin`属性に"use-credentials"を指定すると、Cookieなどのクレデンシャル情報が常に送信されるようになります。

なお、この属性はあくまで`script`要素の`src`属性で指定したリソースの取得を制御するもので、スクリプト内部からのリクエストには影響しません。スクリプト内部からのCORSリクエストについては、スクリプト側で`XmlHttpRequest`の`withCredentials`を設定するなどの対応が必要です。

<!--
`src`属性が指定されていなくても指定できますが、
-->

"integrity", "referrerpolicy"

<!--

script要素の動的挿入

When inserted using the document.write() method, script elements usually execute (typically blocking further script execution or HTML parsing). When inserted using the innerHTML and outerHTML attributes, they do not execute at all.
-->

<!-- 内容モデル -->
とても古いブラウザーでは`script`要素が解釈できず、中身がそのまま表示されるために、コメントアウトするという次のコード例のような手法が存在しました。

```
<mark>古いHTMLの悪い例</mark>
<script language="javascript">
<!--
    window.alert("test")
// -->
</script>
```

ところで、ECMAScript 2015[^1]では、互換性のためにHTML-likeコメントが仕様に追加されました。HTML-likeコメントは、HTMLのコメント区切り子をECMAScriptの1行コメントして解釈するよう定めています（つまり、`//`と同じ効力を持つことになります）。なお、モダンブラウザーでは当然ながら`script`要素を解釈できるため、このように書く必要はありません。

[^1]: ECMAScriptは、Ecma Internationalという標準化団体によって標準化されているJavaScriptの仕様です。ECMAScriptには版（edition）があり、現在は発行年で区別されています。発行年で区別するようになったECMAScript 2015から、毎年6月に新しい版に更新されています。

<!--mark class="comment">何かセキュリティ関連で言うべきことがあれば、追加する</mark-->
<!-- /内容モデル -->


## `noscript`要素

`noscript`要素は、スクリプトが無効である場合に、その子要素を表示します。言い換えると、なんらかの場合にブラウザーでJavaScriptが無効になっている場合に、この要素を用いることでフォールバックコンテンツを提供できるということです。

例えば、スクロールしてから画像が表示されるような場所に配置される`img`要素に対して、JavaScriptを用いて遅延読み込み（Lazy load）を行う場合、次のような`noscript`要素のコードを記述することで、JavaScriptが無効な環境でも画像を表示させることができます。

```
<img src="blank.jpg" data-src="target.jpg" alt="">
<noscript><img src="target.jpg" alt=""></noscript>
```

## `template`要素

`template`要素は、主にJavaScriptによって文書に挿入できるHTMLの断片を宣言するために使用します。レンダリングでは、`template`要素自身は何も表しません。

この`template`要素は、テンプレートという名前が示すとおり、ウェブページ上で同じ構造を繰り返し使用する場合に効果を発揮します。コード例を示します。

```
<table>
  <thead>
    <tr>
      <th>名前</th>
      <th>学名</th>
      <th>開花期</th>
    </tr>
  </thead>
  <tbody id="importtable">
  </tbody>
</table>

<template id="productrow">
  <tr>
    <td></td><td></td><td></td><td></td>
  </tr>
</template>

<script>
  let data = [
    { name: 'アガパンサス', latin: 'Agapanthus', season: '5月下旬～8月上旬' },
    { name: 'クレマチス', latin: 'Clematis', season: '4月中旬～10月' },
    { name: 'コスモス', latin: 'Cosmos', season: '6月～11月' },
    { name: 'ミスミソウ', latin: 'Hepatica nobilis', season: '2月下旬～5月上旬' }
  ];
  // templete要素のcontent属性の有無を確認して、
  // ブラウザーがHTML template要素に対応しているかをテスト
  if ("content" in document.createElement("template")) {
    // 既存のHTML tbodyとtemplateの行を用いてインスタンス生成
    let template = document.querySelector("#productrow");
    // 新しい行を複製して表に挿入
    for (var i = 0; i < data.length; i++) {
      let cat = data[i];
      let tbody = document.querySelector("#importtable");
      let clone = document.importNode(template.content, true);
      let cells = clone.querySelectorAll("td");
      cells[0].textContent = cat.name;
      cells[1].textContent = cat.latin;
      cells[2].textContent = cat.season;
      tbody.appendChild(clone);
    }
  } else {
  // HTML template要素に対応していない場合の処理
  }
</script>
```
<!--
https://developer.mozilla.org/ja/docs/Web/HTML/Element/template
https://dekiru.net/article/12865/
をもとに作成。-->

コード例では、`tbody`要素の子孫のテンプレートを`template`要素に記述し、`template`要素に流し込むデータについては、JavaScriptの配列に記載しています。スクリプトでは、`document.importNode()`メソッドを用いてノード（ここではテーブルの行）のクローンを作成し、`appendChild()`メソッドでノードの追加を行っています。

`template`要素とともに用いることのある`slot`要素が存在しますが、本書では取り上げません。

## カスタム要素

カスタム要素（Custom Elements）は、ウェブコンポーネント（Web Components）と呼ばれる技術を構成するものの1つです。歴史的にHTMLでは、非標準の要素を使用することはできましたが、文法の観点から不適合となるものでした。カスタム要素は、定められた名前の制約のもとで自由にHTMLの要素を定義することができます。これにより、HTMLに適合させることができます。

### 要素名の制約

カスタム要素の要素名の制約は、大雑把に言えば

- アルファベットの小文字で始まること
- 1つのハイフンを含むこと

の2点が必須です。追加の制約として、MathMLやSVGで既に定義されている要素名と同一であってはならないというものがありますが、`-`が要素名に含まれる場合、カスタム要素の可能性が高いと言えます。

なお、要素名についての正確な制約は、HTML仕様に示される`PotentialCustomElementName`で定義されています。

ここでカスタム要素の例を示します。例えば、Googleの検索結果で5つ星の評価については、次のようにカスタム要素を用いてマークアップされています。

```
<g-review-stars><span class="fTKmHE99XE4__star-default" role="img" aria-label="5 点中 3.5 点の評価、"><span style="width:46px"></span></span></g-review-stars>
```

### カスタム要素の種類

カスタム要素には、大きくわけて次の2種類があります。

- 自律カスタム要素（autonomous custom element）は、任意の要素を表す`HTMLElement`インターフェイスを拡張します。

- カスタマイズされた組み込み要素（customized built-in element）は、HTML標準で定義された要素を拡張します。例えば、`HTMLButtonElement`インターフェイスであれば`button`要素をもとに拡張することができます。

JavaScriptを用いて、カスタム要素自身とその動作を定義していくことになりますが、本書の範囲を超えますので、詳細についてはMDN[^1]やGoogle Developers[^2]の記事などを参照ください。

[^1]: Using custom elements - Web Components | MDN https://developer.mozilla.org/docs/Web/Web_Components/Using_custom_elements

[^2]: カスタム要素 v1: 再利用可能なウェブ コンポーネント  |  Web  |  Google Developers https://developers.google.com/web/fundamentals/web-components/customelements?hl=ja