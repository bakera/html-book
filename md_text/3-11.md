# スクリプティング

この節では、スクリプトを扱う`script`要素と、スクリプトに関連するいくつかの要素を紹介します。

ここで紹介する要素のほとんどは、スクリプト（通常はJavaScript）による処理を前提としています。本書ではスクリプトの内容については扱いませんので、ここでは簡単な紹介に留めます。詳細を知りたい場合は仕様を参照してください。

## `script`要素

`script`要素を利用すると、HTML内にスクリプトを埋め込んだり、外部のスクリプトを参照することができます。スクリプトを利用すると、ユーザーの操作に応じてWebページの内容を動的に変化させる、コンテンツを動的に読み込んで表示するなど、さまざまな処理が可能になります。

`script`要素はテキストをマークアップするものではなく、特定のセマンティクスを持ちません。他のHTML要素とは異なり、ユーザーに何かを提示するものではありません。
<!--
 spec: 4.12.1
 https://html.spec.whatwg.org/multipage/scripting.html#the-script-element
-->

`script`要素は、ほとんどの要素の子要素になることができます。この要素は、"Metadata"であり"Flow"であり"Phrasing"でもあり、さらに
"Script-supporting element"にも分類されます。

"Script-supporting element"は、通常他の要素が配置できない場所にも使用できます。たとえば、`ul`要素の子要素は通常は`li`のみで、`div`要素などを置くことはできませんが、`script`要素は`ul`要素の直下に出現することができます。以下は文法的に問題のないマークアップです。

```html
<ul>
<script>
    document.write('<li>');
    document.write(new Date);
    document.write('</li>');
</script>
</ul>
```

このように、`script`要素はたいていの要素の子要素となることができますが、本書では各要素の内容モデルの説明から"Script-supporting element"を省いていますのでご注意ください。
<!--
fieldset > script + legend がエラーになるような話はあるが説明必要か? legendなしの fieldset > script は許されているのがまたややこしい
-->


### `type`属性による判別

`type`属性を指定すると、この要素のタイプを規定することができます。

`script`要素には大きく分けて3種類の用途があり、それぞれ「クラシックスクリプト」(classic scripts)、「モジュールスクリプト」(module scripts)、「データブロック」(data blocks)と呼ばれます。

#### クラシックスクリプト
`type`属性にJavaScriptを意味するMIME typeの値[^1]、たとえば"application/javascript"や"text/javascript"などを指定すると、クラシックスクリプトとして扱われます。`script`要素の内容、もしくは`src`属性で指定したリソースはJavaScriptのスクリプトとして解釈され、実行されます。
<!--
 the JavaScript Script top-level production. 
-->

[^1]: クラシックスクリプトとみなされる値の正確な一覧は、MIME Sniffing Living Standard で確認することができます。<https://mimesniff.spec.whatwg.org/#javascript-mime-type>

`type`属性を省略した場合や、空の値を指定した場合もクラシックスクリプトとみなされます。HTML4では`script`要素の`type`属性は必須でしたが、現在では省略可能です。クラシックスクリプトを意図する場合は省略することが推奨されています。
<!--
仕様で結構強めに省略すべきと書かれている (should) 
Authors should omit the type attribute instead of redundantly setting it.
-->

<!-- 互換性メモ -->
古くに書かれたHTMLでは、`type`属性の代わりに`language`属性が指定されていたこともありました。現在のHTMLでは`language`属性は廃止されています。古いHTMLをメンテナンスする際に見かけたときは、削除してしまいましょう。
<!-- language属性が推奨される正式なHTML仕様が存在したことはないので、書き振りをすこし調整した -->
<!-- /互換性メモ -->

#### モジュールスクリプト

`type`属性の値として"module"を指定すると、モジュールスクリプトとして扱われます。`script`要素の内容、もしくは`src`属性で指定したリソースはJavaScriptのモジュールとして読み込まれます。
<!--
モジュールについてはこちら参照
https://developer.mozilla.org/ja/docs/Web/JavaScript/Guide/Modules
-->
モジュールはECMAScript 2015で新たに導入されたもので、スクリプトをモジュール分割して扱えるようにしたものです。モジュールからは`export`で必要な機能を公開し、それを`import`で読み込んで利用します。利用法の詳細は本書では説明しませんので、JavaScriptのチュートリアル等をご参照ください。

古いブラウザーはモジュールを扱えないことがあります。そのフォールバック手段を提供するために、`nomodule`属性が用意されています。以下は、モジュール"app.mjs"と、フォールバック用のクラシックスクリプト"classic-app.js"を扱う例です。

```html
<script type="module" src="app.mjs"></script>
<script nomodule src="classic-app.js"></script>
```

モジュールスクリプトをサポートするブラウザーは、`nomodule`属性が指定されたクラシックスクリプトを無視します。そのため、"app.mjs"のみを実行します。一方、モジュールをサポートしないブラウザーは`type=module`を理解できないため、モジュールスクリプトは無視されます。そして`nomodule`属性を理解しないため、"classic-app.js"を実行します。

モジュールスクリプトは即時実行はされず、常に遅延読み込みれされます。そのため、`defer`属性を指定しても無視されます (常に`defer`属性が指定されているかのように動作します)。詳しくは`defer`属性、`async`属性の項を参照してください。

#### データブロック

`type`属性が妥当なMIME typeであり、かつJavaScriptを意味するものでない場合、`script`要素はデータブロックとして扱われます[^2]。

[^2] 正確には、クラシックスクリプトにもモジュールスクリプトにも当てはまらない値は全てデータブロックとみなされます。しかし仕様では、`type`属性はMIME typeでなければならないとされています。これは、将来の仕様で`type`属性に"module"以外のキーワードが使えるようになった際に、誤動作しないようにするためです。

ブラウザーは、データブロックに対して何の処理も行いません。内容がスクリプトとして実行されることもありませんし、Webページに表示されることもありません。スクリプトからは内容を参照できるため、Webページに表示したくないデータを埋め込んでおくのに利用できます。また、クローラーによって処理される場合もあります。
<!--
スペックから例を持ってくるべきか、
https://ginpen.com/2011/12/22/built-any-data/
こんな感じのそれっぽいスクリプトもどきも書くべきか。
-->
次のコードは、データブロックを利用してテキストデータを埋め込んでいる例です。

<!-- いちおう動く例にしてみた -->
```html
<script type="text/x-message-data" id="data1">
Welcome!
You are lucky!
</script>
<script>
  const data = document.getElementById("data1").text;
  alert(data);
</script>
```

データブロックの内容はwebページには表示されません。続くスクリプトで、DOM操作によってデータの内容を取得しています。

JSONデータを埋め込むこともできます。以下は、JSON-LDによるメタデータを埋め込んでいる例です。
<!--
JSON-LDについてはx.x節を参照してください。
どこで説明？
1-3で名前だけ出ている
-->

```html
<script type="application/ld+json">
{
  "@context":"https:\/\/schema.org",
  "@type":"BreadcrumbList",
  "itemListElement": [
    {
      "@type":"ListItem",
      "position":1,
      "item":{
        "@id":"https:\/\/www.example.com",
        "name":"example"
      }
    } 
  ]
}
</script>
```

このようにJSON-LDによるメタデータを埋め込むと、検索エンジンのクローラーがこれを認識してメタデータを取得することがあります。

### `src` 属性とインラインスクリプト

`src`属性は外部スクリプトのURLを指定します。文書にスクリプトを直接埋め込む代わりに使用できます。`src`属性を指定しなければ、インラインに埋め込まれたスクリプトが解釈されます。なお、インラインのスクリプトを埋め込み、かつ`src`属性を指定した場合は、外部スクリプトが読み込まれ、インラインスクリプトは無視されます。

`src`属性を用いた、外部スクリプトの指定例は次のようになります。

```
<script src="sample.js">
```

とても古いブラウザーでは`script`要素が解釈できず、中身がそのまま表示されるために、コメントアウトするという次のコード例のような手法が存在しました。

```
<mark>古いHTMLの悪い例</mark>
<script language="javascript">
<!--
    window.alert("test")
// -->
</script>
```

ところで、ECMAScript 2015[^1]では、互換性のためにHTML-likeコメントが仕様に追加されました。HTML-likeコメントは、HTMLのコメント区切り子をECMAScriptの1行コメントして解釈するよう定めています（つまり、`//`と同じ効力を持つことになります）。なお、モダンブラウザーでは当然ながら`script`要素を解釈できるため、このように書く必要はありません。

[^1]: ECMAScriptは、Ecma Internationalという標準化団体によって標準化されているJavaScriptの仕様です。ECMAScriptには版（edition）があり、現在は発行年で区別されています。発行年で区別するようになったECMAScript 2015から、毎年6月に新しい版に更新されています。

<!--mark class="comment">何かセキュリティ関連で言うべきことがあれば、追加する</mark-->


### `async` 属性および `defer` 属性

`async`属性および`defer`属性はスクリプトをどのように評価すべきかを示す真偽属性です。

通常、ブラウザーはスクリプトに出くわすと、HTMLの解析を中断し、スクリプトを取得（フェッチ）して実行します（同期的に処理されます）。しかし、これらの属性を指定することで、HTMLの解析を中断することなく、並行して（非同期的に）スクリプトを読み込むことができるようになります。これにより、ウェブページを読み込む速度の向上が期待できます。

スクリプトが実行されるタイミングは、スクリプトの種類によって異なりますが、ここではクラシックスクリプトに絞った説明を行います。

![async属性とdefer属性の違いを示した図](https://html.spec.whatwg.org/images/asyncdefer.svg)

<!--要日本語化？-->

クラシックスクリプトでは、`src`属性が存在する場合に、`async`属性か`defer`属性のいずれかを指定できます。

`async`属性を指定する場合、HTMLの解析と並行してスクリプトをフェッチし終わるとすぐに実行します。これは言い換えると、複数の`script`要素に`async`属性がそれぞれ指定されたウェブページの場合に、スクリプトの実行される順番がHTMLソースに記載された順番にならないことを意味します。

`defer`属性を指定する場合、`async`属性と同様にHTMLの解析と並行してスクリプトをフェッチしますが、スクリプトを実行するタイミングは、HTMLの解析が終わったときです。<!-- `DOMContentLoaded`に触れる？ -->

<!-- 超速本P.102あたりも参照 -->

<!--

script要素の動的挿入

When inserted using the document.write() method, script elements usually execute (typically blocking further script execution or HTML parsing). When inserted using the innerHTML and outerHTML attributes, they do not execute at all.
-->

## `noscript`要素

`noscript`要素は、スクリプトが無効である場合に、その子要素を表示します。言い換えると、なんらかの場合にブラウザーでJavaScriptが無効になっている場合に、この要素を用いることでフォールバックコンテンツを提供できるということです。

例えば、スクロールしてから画像が表示されるような場所に配置される`img`要素に対して、JavaScriptを用いて遅延読み込み（Lazy load）を行う場合、次のような`noscript`要素のコードを記述することで、JavaScriptが無効な環境でも画像を表示させることができます。

```
<img src="blank.jpg" data-src="target.jpg" alt="">
<noscript><img src="target.jpg" alt=""></noscript>
```

## `template`要素

`template`要素は、主にJavaScriptによって文書に挿入できるHTMLの断片を宣言するために使用します。レンダリングでは、`template`要素自身は何も表しません。

この`template`要素は、テンプレートという名前が示すとおり、ウェブページ上で同じ構造を繰り返し使用する場合に効果を発揮します。コード例を示します。

```
<table>
  <thead>
    <tr>
      <th>名前</th>
      <th>学名</th>
      <th>開花期</th>
    </tr>
  </thead>
  <tbody id="importtable">
  </tbody>
</table>

<template id="productrow">
  <tr>
    <td></td><td></td><td></td><td></td>
  </tr>
</template>

<script>
  let data = [
    { name: 'アガパンサス', latin: 'Agapanthus', season: '5月下旬～8月上旬' },
    { name: 'クレマチス', latin: 'Clematis', season: '4月中旬～10月' },
    { name: 'コスモス', latin: 'Cosmos', season: '6月～11月' },
    { name: 'ミスミソウ', latin: 'Hepatica nobilis', season: '2月下旬～5月上旬' }
  ];
  // templete要素のcontent属性の有無を確認して、
  // ブラウザーがHTML template要素に対応しているかをテスト
  if ("content" in document.createElement("template")) {
    // 既存のHTML tbodyとtemplateの行を用いてインスタンス生成
    let template = document.querySelector("#productrow");
    // 新しい行を複製して表に挿入
    for (var i = 0; i < data.length; i++) {
      let cat = data[i];
      let tbody = document.querySelector("#importtable");
      let clone = document.importNode(template.content, true);
      let cells = clone.querySelectorAll("td");
      cells[0].textContent = cat.name;
      cells[1].textContent = cat.latin;
      cells[2].textContent = cat.season;
      tbody.appendChild(clone);
    }
  } else {
  // HTML template要素に対応していない場合の処理
  }
</script>
```
<!--
https://developer.mozilla.org/ja/docs/Web/HTML/Element/template
https://dekiru.net/article/12865/
をもとに作成。-->

コード例では、`tbody`要素の子孫のテンプレートを`template`要素に記述し、`template`要素に流し込むデータについては、JavaScriptの配列に記載しています。スクリプトでは、`document.importNode()`メソッドを用いてノード（ここではテーブルの行）のクローンを作成し、`appendChild()`メソッドでノードの追加を行っています。

`template`要素とともに用いることのある`slot`要素が存在しますが、本書では取り上げません。

## カスタム要素

カスタム要素（Custom Elements）は、ウェブコンポーネント（Web Components）と呼ばれる技術を構成するものの1つです。歴史的にHTMLでは、非標準の要素を使用することはできましたが、文法の観点から不適合となるものでした。カスタム要素は、定められた名前の制約のもとで自由にHTMLの要素を定義することができます。これにより、HTMLに適合させることができます。

### 要素名の制約

カスタム要素の要素名の制約は、大雑把に言えば

- アルファベットの小文字で始まること
- 1つのハイフンを含むこと

の2点が必須です。追加の制約として、MathMLやSVGで既に定義されている要素名と同一であってはならないというものがありますが、`-`が要素名に含まれる場合、カスタム要素の可能性が高いと言えます。

なお、要素名についての正確な制約は、HTML仕様に示される`PotentialCustomElementName`で定義されています。

ここでカスタム要素の例を示します。例えば、Googleの検索結果で5つ星の評価については、次のようにカスタム要素を用いてマークアップされています。

```
<g-review-stars><span class="fTKmHE99XE4__star-default" role="img" aria-label="5 点中 3.5 点の評価、"><span style="width:46px"></span></span></g-review-stars>
```

### カスタム要素の種類

カスタム要素には、大きくわけて次の2種類があります。

- 自律カスタム要素（autonomous custom element）は、任意の要素を表す`HTMLElement`インターフェイスを拡張します。

- カスタマイズされた組み込み要素（customized built-in element）は、HTML標準で定義された要素を拡張します。例えば、`HTMLButtonElement`インターフェイスであれば`button`要素をもとに拡張することができます。

JavaScriptを用いて、カスタム要素自身とその動作を定義していくことになりますが、本書の範囲を超えますので、詳細についてはMDN[^1]やGoogle Developers[^2]の記事などを参照ください。

[^1]: Using custom elements - Web Components | MDN https://developer.mozilla.org/docs/Web/Web_Components/Using_custom_elements

[^2]: カスタム要素 v1: 再利用可能なウェブ コンポーネント  |  Web  |  Google Developers https://developers.google.com/web/fundamentals/web-components/customelements?hl=ja