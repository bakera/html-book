# HTTP

このChpaterでは、ウェブを支える3つの技術の1つであるHTTPの概要を紹介します。本書では主にHTTP/1.1を取り上げ、やりとりされるメッセージの内容やその意味について簡単に紹介します。

## HTTPの概要

HTTP(Hypertext Transfer Protocol)は、ハイパーテキストを転送するためにつくられた通信プロトコルです。ユーザーエージェントがサーバーに接続し、「メッセージ」(message)のやりとりをします。HTTPにはいくつかのバージョンがあり、`HTTP/1.1`のように`/`に続けてバージョン番号を表記します。

### HTTPの黎明期とHTTP/1.1の円熟

初期のHTTPはHTTP/0.9[^1]と呼ばれますが、リクエストでURLを指定し、レスポンスでHTMLが返るだけのものでした。ヘッダもなく、ステータスもないためエラー応答もできません (つまり、404 Not Foundもありません)。

[^1]: <https://www.w3.org/Protocols/HTTP/AsImplemented.html
>

その後、1996に発行されたRFC 1945[^2]でHTTP/1.0が正式に標準化され、ステータス、HTTPヘッダといった基本的な機能が揃います。

1997年にはRFC 2068[^3]が、1999年にその更新版であるのRFC 2616[^4]が発行され、HTTP/1.1が標準化されました。これは広く普及し、HTTPはいったん円熟期を迎えます。

[^2]: <https://tools.ietf.org/html/rfc1945>
[^3]: <https://tools.ietf.org/html/rfc2068>
[^4]: <https://tools.ietf.org/html/rfc2616>

その後、2014年になってHTTP/1.1の仕様書は更新、再編され、RFC 7230〜7235の6つの文書に分割されました。

- RFC 7230: Message Syntax and Routing
- RFC 7231: Semantics and Content
- RFC 7232: Conditional Requests
- RFC 7233: Range Requests
- RFC 7234: Caching
- RFC 7235: Authentication

### HTTPの進化

HTTP/1.1は長期にわたって利用されてきましたが、近年ではウェブコンテンツが利用するサブリソースの数も増える傾向にあり、通信効率の悪さによるパフォーマンスの問題が指摘されるようになりました。

そこで、パフォーマンスを改善する目的でHTTP/2の仕様が検討されました。通信の方式が大きく変わり、バイナリ形式の採用、ヘッダの圧縮、複数ストリームの利用などを行ってパフォーマンスを向上しています。HTTP/2は2015年にRFC 7540[^5]で標準化されています。

[^5]: <https://tools.ietf.org/html/rfc7540>

現在では、さらにバフォーマンスを向上したHTTP/3も開発されており、既にGoogle Chromeなどで実装されています。

このようにHTTPは進化していますが、HTTP/2以降の進化は主にパフォーマンスの向上であり、やりとりするメッセージの形式に大きな変化はありません。2021年10月現在、HTTP/1.1もまだ現役であり、広く利用されています。

## HTTPメッセージ

HTTPの通信では、ユーザーエージェントとサーバーがメッセージのやりとりを行います。メッセージの書式はRFC 7230で定義されています。

ユーザーエージェントがサーバーに送るメッセージを「HTTPリクエスト」(HTTP request)、サーバーからユーザーエージェントに返ってくるメッセージを「HTTPレスポンス」(HTTP response)と呼びます。

### HTTPリクエスト

以下はHTTPリクエストの例です。

```http
GET /index.html HTTP/1.1
Host: www.example.com
User-Agent: curl/7.16.3 
```

#### リクエスト行

メッセージの先頭の行を「開始行」(start line)と呼びます。メッセージがリクエストの場合、開始行は「リクエスト行」(Request Line)と呼ばれます。リクエスト行には「メソッド」(method)、「リクエストターゲット」(request target)、「HTTPバージョン」(HTTP version)の情報が含まれ、末尾の改行1つ(CR+LF)で終了します。

#### メソッド

メソッドはRFC 7231で定義されています。ウェブでよく利用されるのは以下のメソッドです。

- GET: リクエストターゲットで指定したリソースを取得します。最もよく利用されるメソッドです。
- POST: サーバーに対してデータを送信します。GETメソッドでもURLにデータを含めることはできますが、大量のデータを送るにはPOSTのほうが適しています。主にフォームからのデータ送信に利用します。
- HEAD: GETとほぼ同じですが、サーバーからはヘッダ情報だけが送られ、リソース本体は送られません。リソースの更新日だけを確認したいような場合に利用できます。
- OPTIONS: リクエストターゲットに対してどのようなリクエストが可能かを問い合わせます。従来は利用頻度の少ないメソッドでしたが、現在ではCORSのプリフライトリクエストとして用いられます。詳細はMDN[^6]などを参照してください。

[^6]: <https://developer.mozilla.org/ja/docs/Glossary/Preflight_request>

#### リクエストヘッダ

開始行のあとには「ヘッダフィールド」(header field)が続きます。HTTPリクエストのヘッダフィールドは「リクエストヘッダ」と呼ばれることもあります。ヘッダフィールドは、`フィールド名: フィールド値` の形式で、末尾には改行1つ(CR+LF)を置きます[^7]。

[^7]: 改行の次の行の先頭がスペースで始まった場合、前行のフィールドの
続きとみなされる継続行という仕組みもあります。ただし、現在の仕様では継続業は非推奨とされ、一部の用法を除いて利用することができません。

HTTPリクエストでよく利用されるヘッダフィールドには、以下のようなものがあります。

- Host: 接続先のホスト名を指定します。名前ベースのバーチャルホストを実現するために必要で、HTTP/1.1では必須になりました。
- Content-Length: メッセージボディが存在する場合、そのデータの長さを指定します。
- User-Agent: ユーザーエージェントの名前を指定します。サーバーはこのフィールドを見てユーザーエージェントの種類を推測し、コンテンツの出しわけをすることもあります。
- Accept: 受入可能なMIMEタイプを指定します。MIMEタイプについては後述します。

フィールドは複数置くことができ、それぞれの末尾に改行1つ(CR+LF)をおきます。ヘッダフィールド全体の終端にも改行1つ(CR+LF)をおきます。つまり、最後のフィールドの末尾には改行が2つ連続することになります。

#### リクエストボディ

メソッドがPOSTの場合[^8]、ヘッダフィールドの後に「メッセージボディ」(message body)が続きます。リクエストのメッセージボディは「リクエストボディ」と呼ぶこともあります。以下はPOSTリクエストの例です。

[^8]: GETメソッドなどでも形式上はリクエストボディを持つことができます。ただし、その意味は定義されていませんし、実装によっては不正なリクエストとして拒絶されることもあります。
<!--ボディを持ち冪等なQUERYメソッドというのも検討されているようだ-->

```http
POST /form.php HTTP/1.1
Host: www.example.com
User-Agent: curl/7.16.3

name=john&age=12
```

末尾の行がメッセージボディです。メッセージボディは改行文字を含むこともあり、改行が出現しても終端とはみなしません。メッセージボディは、ヘッダフィールドの`Content-Length`で指定された長さデータを読むか、通信が終わるかすると終端と判断されます。

### HTTPレスポンス

以下はHTTPレスポンスの例です。

```http
Status: HTTP/1.1 200 OK
Content-Type: text/html; charset=utf-8
Content-Length: 7887
Date: Thu, 19 Aug 2021 10:00:02 GMT
Last-Modified: Tue, 17 Aug 2021 14:00:11 GMT

<!DOCTYPE html>
<html lang="ja">
...
```

#### ステータス行

レスポンスの開始行は「ステータス行」(status line)と呼ばれます。ステータス行にはHTTPバージョン、「ステータスコード」(status code)、「リーズンフレーズ」(reason-phrase)を含みます。

ステータスコードはレスポンスの状態を表す3桁の整数値です。その多くはRFC 7231で定義されていますが、他のRFCで定義されるものもあります。リーズンフレーズはステータスの意味を自然言語で表現したものですが、便宜上添えられているに過ぎず、ユーザーエージェントはこれを無視します。

#### ステータスコード

よく使われるステータスコードには、以下のようなものがあります。

- 200(OK): リクエストに成功し、正常なレスポンスを返した状態
- 301(Moved Permanently): リクエストターゲットのリソースが別の場所に移動したことを表します。ユーザーエージェントは移動先を見に行きます。次回以降は移動先のほうを見に行くべきです
- 302(Found): 別の場所のリソースを見に行くべきであることを示します。301と似ていますが、恒久的な移動ではなく、次回以降も引き続きこのURLにアクセスすべきです
- 404(Not Found): 返すべきリソースが見つからなかった状態。ほとんどの場合、URLの誤りが原因
- 500(Internal Server Error): サーバー側で何らかのエラーが発生した状態。リクエストに問題があるわけではないので、再度同じリクエストをすると成功する可能性もあります。

#### レスポンスヘッダ

ステータス行の後にはヘッダフィールドが続きます。HTTPレスポンスのヘッダフィールドは「レスポンスヘッダ」と呼ばれることもあります。ヘッダフィールドの形式はリクエストと同じですが、利用されるフィールドは異なります。

HTTPレスポンスでよく利用されるヘッダフィールドには、以下のようなものがあります。

- Date: レスポンスをおこなった時刻を示します
- Last-Modified: コンテンツの最終更新日を示します
- Content-Length: メッセージボディが存在する場合、そのデータの長さを指定します<!--実はセキュリティ上重要で、レスポンス分割攻撃に使われる-->
- Location: ステータスが300系だった場合の移動先のURLを示します
- Contnet-Type: メッセージの種類を示すMIMEタイプを指定します。MIMEタイプについては後述します

#### レスポンスボディ

ヘッダフィールドの後にはメッセージボディが続きます。レスポンスのメッセージボディは「レスポンスボディ」と呼ぶこともあります。

HTTPレスポンスのメッセージボディには、リソース本体のデータが入ります。

状況によってはレスポンスボディが存在しないこともあります。リクエストがHEADメソッドだった場合や、レスポンスのステータスが204(No Content)だった場合などは、レスポンスボディを返しません。

## MIMEタイプ

HTTPで扱うリソースはHTMLだけではありません。画像、JavaScript、CSS、動画、JSONなど、さまざまな形式のデータを扱うことができます。

ユーザーエージェントは受け取ったリソースを処理しますが、処理の方法はリソースの種類によって異なり、種類を適切に判断しなければ正常に処理できません。そこで、HTTPではリソースの種類を明示できるようになっています。先に挙げたHTTPレスポンスのヘッダフィールドは以下のようになっていました。

```http
Content-Type: text/html; charset=utf-8
Content-Length: 7887
Date: Thu, 19 Aug 2021 10:00:02 GMT
Last-Modified: Tue, 17 Aug 2021 14:00:11 GMT
```

`Content-Type`という名前のフィールドに、`text/html; charset=utf-8`という値が指定されています。これがリソースの種類を示すフィールドです。

`Content-Type`フィールドに指定する値は、「メディアタイプ」（media type）と呼ばれます。メディアタイプは「MIMEタイプ」(MIME Type)と呼ばれることもあります。MIMEはMultipurpose Internet Mail Extensionsの略称で、元は電子メールのメッセージの種類を示すものでしたが、ウェブでもそのまま利用されています。MIMEタイプの仕様はRFC 2046[^9]で定義されています。

[^9]: <https://datatracker.ietf.org/doc/html/rfc2046>

MIMEタイプはIANAによって管理されており、IANAのウェブサイトのMedia Typesのページ[^10]で一覧を見ることができます。

[^10]: <https://www.iana.org/assignments/media-types/media-types.xhtml>

メディアタイプという呼び方は、CSSのメディアクエリーで記述するメディアタイプと紛らわしいという議論もあります[^11]。本書では今後、MIMEタイプと呼ぶことにします。

[^11]: MIME sniffing Standardでも指摘されています。 <https://mimesniff.spec.whatwg.org/#mime-type-representation>

### ウェブでよく利用されるMIMEタイプ

ここでは、ウェブで実際によく利用されるMIMEタイプをいくつか紹介します。より網羅的な情報が知りたい場合は、HTML仕様の索引にあるMIMEタイプの一覧[^12]を参照してください。それぞれのMIMEタイプの扱いはブラウザーやOSによって異なる場合がありますが、ここでは一般的な処理を紹介します。

[^12]: <https://html.spec.whatwg.org/multipage/indices.html#mime-types-2>

#### `text/html`

`text/html`はHTML文書を表します。ウェブコンテンツのほとんどはHTMLで提供されており、ユーザーが見ているウェブページの大半はこのMIMEタイプで配信されます。ブラウザーはHTMLを解析し、レンダリングして表示します。

#### `application/xhtml+xml`

`application/xhtml+xml`は、XML形式で配信されるXHTML文書を表します。XML構文で記述されているものとみなされ、XMLパーサーによる構文解析が行われます。レンダリングと表示は`text/html`と同様ですが、XMLの文法に誤りがある場合は補正されず、エラーとなってレンダリングに失敗します。

#### `application/pdf`

`application/pdf`はPDF文書を表します。多くのブラウザーはPDFをレンダリングして表示することができ、ブラウザーのウィンドウ内で文書として表示します。以前はPDFの表示に専用のプラグインを必要とすることがありましたが、近年ではプラグインが不要な場合がほとんどです。

PDFファイルを表示ではなくダウンロードさせたい場合、あえて`application/octet-stream`で配信することもあります。

#### `image/png`、`image/jpeg`、`image/gif`

`image/png`、`image/jpeg`、`image/gif`は、それぞれPNG画像、JPEG画像、GIF画像を表します。いずれも、ブラウザーは画像として表示します。多くの場合、HTML文書から`img`要素の`src`属性でサブリソースとして参照され、コンテンツに画像を埋め込む形で利用されます。

`a`要素の`href`属性で参照したり、画像のURLを直接ブラウザーのアドレスバーに入れた場合、ブラウザーのウィンドウで画像を直接表示します（俗に「画像直リンク」と呼ばれます）。この場合、代替テキストの情報が提供できないため、アクセシビリティ上の問題が生じるつながる場合があります。

#### `image/svg+xml`

`image/svg+xml`は、XML形式で配信されるSVG画像を表します。PNG画像などと異なり、SVGデータ自体に`title`要素によるタイトルや、`desc`要素による説明文のテキストを含んでいることがあります。また、`script`要素によるJavaScriptのデータを含むこともあります。

`img`要素の`src`属性で参照すると、画像として埋め込むことができます。この場合、タイトルや説明文などの情報は利用されず、JavaScriptも実行されません。代替テキストはHTML側で用意する必要があります。

#### `application/javascript`

`application/javascript`は、JavaScriptのスクリプトファイルを表します。`text/javascript`が利用されることもあります。推奨されていませんが、`text/x-javascript`などが利用されていることもあります。

<!-- security consideration -->
このMIMEタイプで配信されるJavaScriptは、`script`要素の`src`属性に指定してクロスオリジンで実行することが可能になります。特に、JSONをこのMIMEタイプで配信した場合、一定の条件が揃うと、「JSONハイジャック」と呼ばれる攻撃で情報を読み出される場合があるため注意が必要です。JSONデータは後述の`application/json`で配信してください。
<!-- /security consideration -->

#### `application/json`

`application/json`は、任意のJSON (JavaScript Object Notation)形式のデータを表します。近年のWeb APIではよく利用される形式です。以前は`text/json`が利用されることもありました。

JavaScriptとデータ形式が似ていますが、MIMEタイプは異なります。前述のように、`application/javascript`で配信するとセキュリティ上の問題が生じることがあります。

データの種類によっては、さらに専用のMIMEタイプが定義されている場合もあります。たとえば、JSON-LDによるメタデータをJSON形式で配信する場合は、`application/ld+json`を利用します。

#### `text/css`

`text/css`は、CSS (Cascading Style Sheets)によるスタイルシートデータを表します。HTMLの`link`要素を利用して外部スタイルシートを参照する場合に、この形式のデータを利用します。

#### `application/octet-stream`

`application/octet-stream`は、任意のバイナリーデータを表します。データが具体的に何なのかは不明です。ブラウザーは、これをMIMEタイプが不明なものとして扱います。後述の「MIMEタイプが不明な場合」を参照してください。

多くの場合はダウンロードを促しますが、レンダリングしようとすることもあります。明示的にファイルをダウンロードさせたい場合は、HTTPレスポンスヘッダーで`Content-Disposition: attachment`を指定します。

### MIMEタイプが不明な場合

MIMEタイプが指定されていなかったり、ブラウザーにとって未知なものであった場合、データの扱い方を判断できません。この場合、ブラウザーは、後述するMIME sniffingの処理を行ってデータの種類を判別しようとします。

それでも種類が不明な場合は、ユーザーにデータのダウンロードを促し、保存するかどうか尋ねることが一般的です。ただしモバイル端末など、ローカルにファイルを保存することができない環境もあります。その場合は、クラウドへの保存を促すこともあれば、何も起きないこともあります。

### MIME sniffing

状況によっては、アクセスしようとしているコンテンツの`Content-Type`が指定されていなかったり、ブラウザーにとって未知の値が指定されていることがあります。この場合、ブラウザーはコンテンツを実際に読み、その内容からMIMEタイプを推測します。この処理をMIME sniffingと呼びます。

従来、MIME sniffingの挙動はブラウザーの実装に依存していました。一部のブラウザーはURLに含まれる拡張子を手掛かりにしたり、`Content-Type`の指定を無視してsniffingの推測結果を優先することがありました。これはセキュリティ上の問題を引き起こすことがあります[^13][^14]。

[^13]: この問題への対応のため、`X-Content-Type-Options: nosniff`フィールドでsniffingを抑制する仕様が採用されました。現在では各ブラウザーも`X-Content-Type-Options`を解釈してsniffingを抑制するようになっています。

[^14]: <https://docs.microsoft.com/ja-jp/archive/blogs/ie/ie8-security-part-vi-beta-2-update#mime-handling-sniffing-opt-out>

各ウェブブラウザーが独自に異なるMIME sniffingを行う状況では、サーバー側でセキュリティの問題を回避するための十分な対策を施すのが困難でした。そのような背景もあり、現在ではこの挙動はMIME sniffing仕様[^15]として文書化され、標準化されています。

[^15]: <https://mimesniff.spec.whatwg.org/>

### charsetパラメーター

MIMEタイプによっては、追加のパラメーターを指定できる場合があります。たとえば、`text/html`や`application/javascript`などのMIMEタイプは、オプションとして`charset`パラメーターを持ちます。これは文字エンコーディングを指定するものです。文字エンコーディングについてはChapter2-5で詳しく説明します。

`text/html`に`charset`パラメーターを指定すると、たとえば以下のようになります。

```text
text/html; charset=UTF-16
text/html; charset=Shift_JIS
text/html; charset=ISO-2022-JP
```

"character set"という言葉は本来は文字集合を表すもので、文字エンコーディングを表す言葉は"character encoding"ですが、両者はよく混同されます。`charset`パラメーターもこの例に漏れず、実際に指定する値は文字集合ではなく、文字エンコーディングの名称です。

## コラム: セキュリティ上の留意点

MIMEタイプやcharsetパラメーターの指定は、セキュリティ上も重要な意味を持ちます。たとえば、プレーンテキストとしてアップロードされたはずのファイルがHTMLとして解釈されると、JavaScriptが実行され、意図しないクロスサイトスクリプティングの攻撃につながることがあります。このため、リソースの種類を正しく判定することが重要です。

### `Content-Type`の無視による攻撃が成立する例

`Content-Type`の適切な指定が無視され、ブラウザーのsniffingが優先されると攻撃が可能になる場合があります。具体例として、筆者が実際に発見・報告した脆弱性の例を紹介します。

- [JVN#91706484 Trac におけるクロスサイトスクリプティングの脆弱性](https://jvn.jp/jp/JVN91706484/)

>Trac の Wiki 機能には、利用者が Internet Explorer を利用している場合に、クロスサイトスクリプティングの脆弱性が存在します。

このアプリケーションにはWikiページの機能があり、任意のテキストを書くことができましたが、HTMLを書き込んでも適切にエスケープされていました。HTMLとして表示されたり、スクリプトが実行されることはありません。

このWikiにはデータをテキスト形式でダウンロードする機能もあり、ダウンロードファイルを`Content-Type: text/plain`で配信していました。HTMLが書かれていても、通常は単なるテキストと解釈され、HTMLとして解釈されることはありません。

ところが、Internet Explorerでは`Content-Type`を無視してHTMLとして解釈することがあります。ダウンロードURLへのリンクの方法を工夫することにより、Internet ExplorerではテキストファイルをHTMLと解釈させて、ブラウザー上で表示させることが可能でした。これを利用して、対象サービスのドメイン上で任意のJavaScriptを実行することが可能でした。

### `charset`パラメータの欠如により攻撃が成立する例

セキュリティ上、文字エンコーディングの指定は重要な意味を持ちます。文字エンコーディングを誤認させることで攻撃が可能になる場合があるからです。たとえば、UTF-8で符号化されたHTMLに以下の文字列が出力されているとします。

```html
+ADw-script+AD4-alert(+ACI-test+ACI-)+ADsAPA-/script+AD4-
```

これは単に意味不明な文字列にすぎず、無害です。しかし、これをUTF-7として解釈すると以下のようになり、JavaScriptが実行されます。

```html
<script>alert('test');</script>
```

HTMLに`charset`パラメーターが指定されていない場合、文字エンコーディングを誤認させることで攻撃が成立する場合があります。このような理由から、IPAの「安全なウェブサイトの作り方」[^16]では、`Content-Type`フィールドに必ず`charset`パラメーターを指定するように求めています。

[^16]: <https://www.ipa.go.jp/security/vuln/websecurity-HTML-1_5.html>
<!-- /security consideration -->
