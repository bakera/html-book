# URL

HTMLの属性には、属性値としてURLを指定するものが多数あります。ここでは、URLの構文について説明します。

## URLの基本構文

属性の中には、値としてURLを指定するものがあります。代表例は`a`要素の`href`属性です。

```html
<a href="https://www.w3.org/">W3C</a>
```

URLは、リソースの場所を特定するための汎用的な識別子です。URLの詳細はURL Standard[^1]で定義されています。

[^1]: https://url.spec.whatwg.org/

URLでまず連想されるのは、`https`で始まるものでしょう。

```text
https://example.com/
```

上記はシンプルな例ですが、もう少し複雑な例もあります。

```text
https://example.com:443/foo/bar.php?q=xxx#result
```

### URLスキーム

先頭の`https`の部分は「URLスキーム」(URL Scheme)と呼ばれ、このURLの種類を表します。IANAに登録されているスキームの一覧はUniform Resource Identifier (URI) Schemes[^2]で確認することができます。ウェブでは`https`の他に、以下のものがよく使われます。

[^2]: https://www.iana.org/assignments/uri-schemes/uri-schemes.xhtml

- http
- ftp
- file
- wss
- mailto

スキームは多くの場合、リソースの取得方法となるプロトコルを表しています。ただし、常にスキームが通信プロトコルを表すとは限りません。たとえば、`mailto`で実際に使われる通信プロトコルはSMTPです。`file`にいたっては通信が発生しません。また、IANAには登録されていませんが、`javascript`というスキームのURLが使われることもあり、こちらも通信は発生しません。後述の「リソースの取得」も参照してください。

スキームの後は、1文字の`:`で区切ります[^3]。その後に続く内容はスキームによって異なりますが、ここでは`https`（`http`も同様）の場合を紹介します。

[^3]: `:`の前までをスキームと呼ぶこともあれば、スキームであることを明確にするために、`:`まで含めて記述することもあります。本書では、URL Standardに従って、`:`を含めないものをスキームと呼びます。

### ホスト

`https`の場合、`https:`の直後に`//`を書き、その後に続いて「ホスト」(host)が書かれます。ホストは、ドメイン名かIPアドレスのいずれかです。多くの場合はドメイン名が使用されます。

```text
https://example.net
```

ドメイン名はFQDN (Fully Qualified Domain Name, 完全修飾ドメイン名)でなくても構いません。以下のように`localhost`を指定してローカルホストを参照することもあります。

```text
http://localhost
```

### ポート

ホストの後ろには「ポート」(port)の情報が来ることがあります。ポートを書く場合は`:`で区切って、0〜65535の整数（ポート番号）を記述します。

```text
http://localhost:8080
```

ポートは省略することができます。省略した場合はデフォルトのポート番号が使用されます。デフォルトのポート番号は、`http`なら80、`https`なら443です。ポート番号の一覧はIANAに登録されており、Service Name and Transport Protocol Port Number Registry[^4]で見ることができます。

[^4]: https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml

### パス

ホストの後ろ (ボートが記述されている場合はポートの後ろ) には、「パス」(path)の記述が続きます。パスは、そのホスト内でリソースを特定するための記述です。

パスは`/`で始まります。さらに複数の`/`で区切って階層化することもできます。たとえば以下のようになります。

```text
https://example.net/foo/bar/baz.html
```

"/"で区切られたそれぞれの部分を「URLパスセグメント」(URL path segment)と呼びます。URL StandardではURL-path-segment stringとして定義されています。上記の例では`foo`と`bar`と`baz.html`がURLパスセグメントにあたります。

特殊なURLパスセグメントとして、`.`（「単一ドットパスセグメント」(single-dot path segment)）と`..`（「二重ドットパスセグメント」(double-dot path segment)）があります。`.` は現在と同じ階層、`..` は親階層を表します。

`.`は現在の階層を表すので、`.`が出現する前のパスを指すことになります。つまり、以下はすべて同じリソースを指します。

```text
/foo/bar/
/foo/bar/./
/foo/bar/././
/foo/./bar/
/foo/./././bar/././././
```

`..`の場合は親階層を指します。以下は全て同じリソースを指します。

```text
/foo/
/foo/bar/../
/bar/../foo/
/bar/../baz/../foo/
```

こう見ると冗長なだけのように見えますが、この記述方法は後述するパス相対URLで活躍します。

### クエリ

パスの後ろには、「クエリ」(query) と呼ばれる文字列がつくことがあります。クエリをつける場合は、`?`の1文字で区切ります。

クエリとは、「問い合わせ」というような意味です。GETメソッドと呼ばれる方式のフォームを送信すると、フォームに入力したデータがURLの末尾につけられ、URLを通じてサーバに送信されます。これがクエリで、サーバに対する問い合わせに使うことからこの名前が来ています。現在では、クエリはフォーム送信の時だけでなく、アクセス元をトラッキングしたり、キャッシュを更新させる目的で使われることもあります。

### フラグメント

URLの末尾には、「フラグメント」(fragment)と呼ばれる文字列がつくことがあります。フラグメントをつける場合は、`#`一文字で区切ります。

フラグメントとは、「断片」という意味です。URLは特定のリソースを指しますが、そのリソース中のさらに特定の部分を指したい時にフラグメントを使用します。HTMLの場合は、`id`属性で指定された名前をフラグメントとして指定することで、HTML文書の特定の箇所を指すことができます。

フラグメントは「ハッシュ」(hash)と呼ばれることもあります。これは、区切りに使用する文字`#` (U+0023, "NUMBER SIGN") が、別名でハッシュとも呼ばれるためです。たとえば、JavaScriptでは`location.hash`でフラグメントの値を参照することができます。

## 相対URL

一般的にURLというと、前述したような、スキームから始まる表記を連想することが多いと思います。スキームから始まる完全な形式のURLを「絶対URL」(absolute URL)と呼びます。URL Standardではabsolute-URL stringとして定義されます。

一方、「相対URL」(relative URL)と呼ばれるURLの表記方法もあります。URL Standardではrelative-URL stringとして定義されます。これは、現在の場所からの相対位置を示します。HTML文書を閲覧している場合は、通常そのHTML文書自体のURLからの相対参照と解釈します。[^5]

[^5]: `base`要素でURLが指定される場合は、そのURLを「基準URL」(base URL)として、そこからの相対参照と解釈します。

相対URLは以下のようなものがあります。

- 「スキーム相対URL」(scheme relative URL)
- 「パス絶対URL」(path absolute URL)
- 「パス相対URL」(path relative URL)

### スキーム相対URL

スキーム相対URLは、絶対URLからURLスキームと`:`を取り除いたもので、URL Standardではscheme-relative-URL stringとして定義されています。先頭が`//`で始まり、ホスト名が続きます。以下のような形になります。

```text
//example.com/foo/bar.html
```

スキーム相対URLを使用した場合、スキームは基準URLと同じものとみなされます。たとえば、上記は、基準URLのスキームが`https`ならば`https://example.com/foo/bar.html`に、`http`ならば`http://example.com/foo/bar.html`と同じになります。


### パス絶対URL

パス絶対URLは、スキーム相対URLから`//`とホスト名の部分を取り除いたもので、URL Standardではpath-absolute-URL stringとして定義されています。先頭が`/`で始まり、パスの記述が続きます。

```text
/foo/bar.html
```

パス絶対URLを使用した場合、スキームとホスト名は基準URLと同じものとみなされます。

名前に“絶対”とありますが、これはURL全体が絶対という意味ではなく、パス部分が絶対パスで書かれているという意味です。パス絶対URLは絶対URLではなく、相対URLの一種です。

### パス相対URL

パス相対URLは、先頭が`/`で始まらないパスの記述で、URL Standardではpath-relative-URL stringとして定義されています。

```text
foo/bar.html
```

パス相対URLを使用した場合、スキームとホスト名は基準URLと同じとみなされ、基準URLからの相対パスとして解釈します。

パス相対URLでは、URLパスセグメントに`.`や`..`を使う記述が生きてきます。たとえば、基本URLのパスが`/foo/bar/baz.html`であるとき、以下のようになります。

- `./` → `/foo/bar/`
- `../` → `/foo/`
- `../../` → `/`
- `./baz2.html` → `/foo/bar/baz2.html`
- `../baz2.html` → `/foo/baz2.html`


## URLに使える文字

URLパスセグメントやクエリ、フラグメントに使える文字は、「URLコードポイント」(URL code points)として決められています。具体的には、次の文字になります。

- ASCII英数字
- 記号類: `!`, `$`, `&`, `'`, `(`, `)`, `*` , `+`, `,`, `-`, `.` `/`, `:`, `;`, `=`, `?`, `@`, `_`, `~`
- U+00A0〜U+10FFFDのUnicode文字。ただし、「サロゲート」(surrogates)と「非文字」(noncharacters)を除く

括弧`(`および`)`がURLに使用できる文字であることに注意してください。メール等で文中のURLがリンクになるような仕組みがありますが、`(https://example.com)`と書くと、末尾の`)`がURLの一部とみなされることがあります。不等号（`<`および`>`）はURLに使用できないため、URLを囲みたい場合は不等号を使うと誤認識を防げます。

### パーセントエンコード

URLに使用できない文字や、特別な意味に解釈される文字は、「パーセントエンコードバイト」(Percent-encoded bytes)として記述することができます。文字をパーセントエンコードバイトに変換することを「パーセントエンコード」(percent-encode)と言います。この記述方法は、「URLエンコード」、「パーセントエンコーディング」などと呼ばれることもあります。

パーセントエンコードバイトの記述は、`%`に続いて2桁の16進数で文字コードを表記します。たとえば、`<`は`%3C`、`>`は`%3E`となります。`%`文字そのものを書きたい場合は、`%25`と記述します。

非ASCII文字をパーセントエンコードする際には、原則としてUTF-8で符号化して扱います。たとえば、「日本語」という文字列の場合、UTF-8で符号化すると以下のようになります。

-「日」(U+65E5) → E6 97 A5
-「本」(U+672C) → E6 9C AC
-「語」(U+8A9E) → E8 AA 9E

これをパーセントエンコードすると以下のようになります。

```text
%E6%97%A5%E6%9C%AC%E8%AA%9E
```

### パーセントデコード

パーセントエンコードされた文字を元に戻すことを「パーセントデコード」(percent-decode)と言います。パーセントデコードの処理では、`%`に続いて2桁の16進数と解釈できる文字が出現した場合、それを元の文字に戻します。たとえば、`%2f`は`/`となります。

仕様上、`%`が単独で出現したり、後ろ2文字が16進数とは解釈できない文字だった場合は、そのまま`%`という文字とみなします。たとえば、`%xxx`という文字列は、そのまま`%xxx`と解釈されます。しかし、サーバーやプロキシの中には、このような処理を適切に行わず、`%`が単独で出現すると"400 bad request"エラーを返すものもあります。

パーセントエンコード・デコードの処理の詳細については、HTML仕様[^6]を参照してください。

[^6]: https://url.spec.whatwg.org/#percent-encoded-bytes


## リソースの取得
<!-- フェッチとカタカナで書くのはだいぶ違和感があるがどうするか。エンジニアは大体英語のまま fetch って書いている気がする。徳丸本の「クッキー」カタカナ表記も個人的に違和感があるがそれで押し切れているので、このまま押し切るのもありな気はしている -->
URLで示されるリソースを取得することを「フェッチ」(Fetch)と言います。リソース取得時のルールはFetch仕様[^7]で定められています。

[^7]: <https://fetch.spec.whatwg.org/>

URLのフェッチにはいくつかのパターンがあります。

### ナビゲーション

ブラウザーのアドレスバーにURLを直接入力すると、ブラウザーはそのURLのリソースを表示します。そしてハイパーリンクを辿れば、ブラウザーはリンク先のリソースを表示しようとします。このようにしてブラウザーが別の文書を表示することを「ナビゲーション」(navigation)と呼びます。ユーザーがハイパーリンクをクリックしたり、アドレスバーにURLを入力したりすると、指定されたURLへのナビゲーションが発生します。ナビゲーションが発生すると、ブラウザーは新しいリソースを表示すると同時に、アドレスバーに新しいリソースのURLを表示します。

ナビゲーションのためのフェッチを「ナビゲーションリクエスト」(navigation request)と呼びます。

### サブリソースの取得

リソースの中には、アドレスバーにURLが出ないものもあります。たとえば、Web上の画像の多くは、HTML文書の中に埋め込まれる形で表示され、そのURLはアドレスバーには表示されません。CSSファイルやJavaScriptファイルなども、HTMLの表示のために使われますが、アドレスバーには現れません。これらは、メインとなるHTML文書の表示のために必要なリソースであり、補助的なリソースという意味で「サブリソース」(subresources)と呼びます。

サブリソースを取得するためのフェッチを「サブリソースリクエスト」(subresource request)と呼びます。

逆に、サブリソースリクエストでないフェッチを「非サブリソースリクエスト」(non-subresource request)と呼びます。ナビゲーションリクエストはすべて非サブリソースリクエストです。非サブリソースリクエストの中には、ナビゲーションリクエストでないものも存在しますが、本書では紹介しません。詳しくはFetch仕様のnon-subresource-requestの項[^8]を参照してください。

[^8]: https://fetch.spec.whatwg.org/#non-subresource-request

なお、サブリソースのURLはメインのHTMLと異なるドメインのものであっても構いません。たとえば、Webフォントを配信しているサービスから直接読み込んだり、JavaScriptのライブラリを外部のCDNサービスから読み込んだりすることがよく行われます。

<!-- 外部のドメインからWebフォントやJavaScriptを読み込む例 -->
```html
<link rel="stylesheet" href="https://fonts.googleapis.com/css2?xxxx">
<script src="https://cdnjs.cloudflare.com/ajax/libs/xxx.js"></script>
```

ただし、異なるドメインへのサブリソースリクエストは制限を受ける場合もあります。後述の「同一オリジンポリシー」を参照してください。

### リソースを取得できるスキーム

URLスキームの中には、その性質上、リソースを取得できないものもあります。たとえば、`mailto`スキームはメール送信先のメールアドレスを示します。多くのブラウザーでは、`mailto`スキームのURLへのナビゲーションリクエストが発生すると、メーラーを起動しようとします。また、`javascript`スキームのURLへのナビゲーションが発生すると、JavaScriptが実行されます。たとえば、`a`要素の`href`属性に指定しておくと、そのリンクを辿ったときにメーラーが起動したり、JavaScriptが実行されたりします。

<!-- ハイパーリンクを辿ってナビゲーションが発生すると実行される -->
```html
<a href="mailto:foo@example.com">foo@example.com</a>
<a href="javascript:alert(1)">alert</a>
```

しかし、このURLからリソースを取得することはできません。これらへのサブリソースリクエストが発生しても、何も起きません。たとえば、`img`要素の`src`属性に指定した場合、リソースを取得できなかったものとして扱われ、多くのブラウザーでは壊れた画像のアイコンを表示します。

<!-- サブリソースとして取得しようとしても何も起きず、壊れた画像となる -->
```html
<img src="mailto:foo@example.com" alt="foo@example.com">
<img src="javascript:alert(1)" alt="alert">
```

Fetch仕様では、リソースの取得が可能な「Fetchスキーム」(fetch scheme)として、以下が挙げられています。

- `http`
- `https`
- `file`
- `about`
- `blob`
- `data`

`http`や`https`は、Webで一般的に利用されるものです。通信を行い、データをダウンロードすることでリソースを取得します。

`file`スキームは、ローカルファイルを指すURLです。この場合、ローカルのファイルシステムからリソースを取得します。

`about`スキームがフェッチ可能なのは`about:blank`の場合のみです。この場合、空のリソースが取得されます。その他の場合、たとえば`about:config`などは、サブリソースとして用いることはできません。

`blob`スキームは、JavaScriptで生成したデータをサブリソースとして利用できるように、URLを与えたものです。JavaScriptによってメモリ上に置かれたデータをリソースとして参照します。

`data`スキームは、データURLを表します。データURLとは、URLの中にデータを直接表現するもので、Fetch仕様で定義されています。以下は、データURLを用いてSVG画像を埋め込んだ例です。

```html
<img src="data:image/svg+xml,%3csvg%20xmlns%3d%22http%3a%2f%2fwww.w3.org%2f2000%2fsvg%22%20viewbox%3d%220%200%20100%20100%22%3e%3crect%20fill%3d%22%23ff3300%22%20width%3d%22100%22%20height%3d%22100%22%20rx%3d%2220%22%20ry%3d%2220%22%2f%3e%3c%2fsvg%3e" alt="">
```

MIMEタイプの後に、データURLとしてパーセントエンコーディングされたSVGが記載されています。また、データURLには、Base64エンコードを行ってバイナリーデータを埋め込むことも可能です。

```html
<img src="data:image/png,base64,[base64エンコードしたバイナリーデータ]" alt="">
```

## 認証情報の送信

Webサービスの中には、アクセスの際に認証を要求するものもあります。ユーザーが認証を済ませている場合、ブラウザーがURLのフェッチを行う際に、認証に関連する情報を送信する場合があります。

一般的に、Webでよく用いられる認証の方法は以下の2つです。

- 基本認証 (Basic認証)
- フォーム認証

それぞれで送られる情報の種類は異なりますが、これらをまとめて「クレデンシャル」(credential)と呼びます。

### 基本認証のクレデンシャル

基本認証 (Basic認証) は、サーバーから認証が必要だというHTTPレスポンスを返し、パスワードの入力を求めるものです。ブラウザーはユーザー名とパスワードを入力するダイアログを表示します。

![Basic認証のダイアログの例](../img/2-3-02.png)

基本認証では、クレデンシャルとして、ユーザー名とパスワードを送信します。

ユーザーが一度パスワードを入力すると、以後のリクエストでは、ブラウザーが自動的にクレデンシャルを送信するようになります。HTMLだけでなく、サブリソースのリクエストも含め、すべてのリクエストで毎回クレデンシャルが送られます。

#### クレデンシャルを含むURL

基本認証のユーザー名とパスワードをダイアログで入力する代わりに、URLに含めてしまう記法も存在します。IDとパスワードを`:`でつなぎ、後ろを`@`で区切り、その後にホストを続けます。具体的には以下のような形になります。

```text
https://user:password@example.com/
```

URLに認証情報を含めることはセキュリティ上の問題に繋がりやすいため、このようなURLはURL Standardでは認められていません。しかし、ブラウザは互換性の理由から、このような形式のURLを受け入れて解釈する場合があります。

このような形式のURLを使用した攻撃手法も存在します。プログラムでURLをチェックする場合には、ホストの前に認証情報がつくこともあるということを念頭に置いておきましょう。

### フォーム認証のクレデンシャル

今日の多くのサイトは、基本認証を利用せず、Webコンテンツ側で入力フォームを用意して、ユーザーにパスワードを入力させています。この場合、入力フォームはサイト側で自由に用意でき、デザインや入力項目はサイトによってさまざまです。

このように、サイト側で用意したフォームに認証情報を入力させるやり方を、基本認証と区別する意味で、一般的に「フォーム認証」と呼んでいます。

フォーム認証では、「クッキー」(Cookie)がクレデンシャルとして扱われます。クッキーは、サーバーから送信されてきた値をブラウザー側で記憶し、それをサーバーに対して送信する仕組みです。

一般的なフォーム認証では、認証に成功した際にユーザーを識別するための一時的なIDを発行して、クッキーとして記憶させます。以後、ブラウザーは、リクエストの際に自動的にクッキーを送信します。HTMLだけでなく、サブリソースのリクエストも含め、すべてのリクエストで毎回クッキーが送られます。

サーバー側では、このクッキーの値を見て、アクセスしてきたユーザーが認証済みであるかどうかを判定します。もし、認証済みのユーザーのクッキーが漏洩した場合、それを利用するとそのユーザーになりすましてアクセスできてしまう場合があります。このため、クッキーは機微な情報となり、クレデンシャルとして扱われます。

クッキー自体は認証を伴わないサイトでも利用されますが、一律、クレデンシャルとして扱われます。

## 同一オリジンポリシー
<!-- 徳丸本が「同一オリジンポリシー」なので用語を合わせておく -->

クレデンシャルは機微な情報です。認証を行ったサイトに対してはクレデンシャルを送信しなければなりませんが、万が一、悪意のあるサイトにクレデンシャルが送信されることがあれば、それを悪用され、なりすましを許すことになってしまいます。

悪意あるサイトに送信されると困るものは、クレデンシャルだけではありません。たとえば、`iframe`要素を利用すると、HTMLの中に他のHTML文書を読み込んで表示させることができます。そして、JavaScriptを利用すると、`iframe`要素の内容として表示されているコンテンツそのものを読み取ることができます。

<!-- 下の図は徳丸本 p.78 のもの。このまま使うのではなく、こんな感じのいい感じの図を想定。 -->
![図: iframeの内容を読み出すことができる](../img/2-3-01.png)

これが自サイト内のコンテンツであれば問題はありませんが、悪意あるサイトにコンテンツを読み取られると、秘密のはずの情報が漏洩することになります。

このように、あるサイトの内部では情報を送りたいが、他のサイトには絶対に送られないようにしたいことがあります。そのためには、あるURLと別のURLが同一のサイトであるかどうかを判断する必要があります。

### サイトとオリジン

ふたつのURLが「同一サイト」(same site) であるかどうかは、基本的に、URLのホスト部分を見て判断します。ほとんどの場合、URLのホスト部はIPアドレスではなくドメインで表記しますから、大雑把に言えば、ドメインを見て判断するということもできるでしょう。ただし、ホストが同一でも、ポートが異なる場合は別のサイトとみなします。つまり、同一サイトであるためには、ホストだけでなくポートも同一である必要があります。

しかし、これだけでは不足しています。同一サイトであっても、スキームが異なるとなりすましの可能性があるためです。本物のサイトが`https`であるとき、攻撃者は同一ドメイン・同一ポートで`http`のなりすましサイトを用意するかもしれません。スキームが異なるものを同一サービスとみなされては困ります。

そこで、ホストとポートだけでなく、スキームまで考慮したものを「オリジン」(Origin)と呼びます。originは起源、みなもとといった意味で、日本語では「生成源」「生成元」「起源」などと訳されることがあります。ふたつのURLのオリジンが同じである時、それらを「同一オリジン」(same origin)であると言います。オリジンの判定方法の詳細は、HTML仕様で定義されています[^9]。

[^9]: <https://html.spec.whatwg.org/multipage/origin.html#origin>

Webにおいては、原則としてオリジンの考え方にもとづいて判断し、オリジンが同一でない場合にはアクセスに制限を課すようにします。この考え方を「同一オリジンポリシー」(same-origin policy)と言います。同一オリジンポリシーの詳細は、MDNを参照するとよいでしょう[^10]。

[^10]: <https://developer.mozilla.org/ja/docs/Web/Security/Same-origin_policy>

ただし、オリジンではなくサイトの考え方を使うケースもあります。クッキーの送信がその例で、同一サイトかどうかで判定します。つまり、スキームが異なっても、同一サイトであればクッキーを送信する仕様となっています。このため、`https`スキームでクッキーを利用する場合は、クッキー側でsecure属性を指定するなどの配慮が必要になります。
<!--
基本認証の場合どうか:
https://datatracker.ietf.org/doc/html/rfc7235#section-2.2
>   A protection space is defined by the canonical root URI (the scheme
   and authority components of the effective request URI; see Section
   5.5 of [RFC7230]) of the server being accessed, in combination with
   the realm value if present. 

authorityの定義:
https://datatracker.ietf.org/doc/html/rfc3986#section-3.2
>authority   = [ userinfo "@" ] host [ ":" port ]

スキームとポート含むので基本はオリジンに従うと言える、ただしuserinfoやrealmも見て判定するので違うといえば違う
まあオリジンに従うと言っても間違いではない気がするので、特に書かなくて良いか
-->

このように、ドメイン、サイト、オリジンはそれぞれ異なる概念ですが、これらはあまり厳密に区別せずに使われることもあります。たとえば、「クロスドメイン」「クロスサイト」「クロスオリジン」という言葉は、厳密には異なる意味になりますが、ほとんど場合、同じ意味で使われています。

### クロスオリジンアクセスの制限

あるURLのリソースから、オリジンが異なるURLのリソースに対してアクセスしようとするとき、オリジンをまたがるという意味で「クロスオリジン」（Cross-Origin）と言います。先に述べたように、あまり厳密でない言い方で「クロスドメイン」「クロスサイト」と表現されることもあります。

クロスオリジンでのアクセスは、可能な場合とそうでない場合があります。単純にHTMLにサブリソースを埋め込む場合、通常はクロスオリジンでの参照が可能です。そのかわり、HTML側のJavaScriptからは、クロスオリジンで取得したサブリソースの内容を読み取ることができないようになっています。

JavaScriptで内容を読み取るケース、たとえばXMLHttpRequestやfetchのようなAPIを利用するケースでは、クロスオリジンでのアクセスは制限されています。クロスオリジンアクセスが必要な場合は、CORS (Cross-Origin Resource Sharing)と呼ばれる仕組みを利用して、サブリソースを提供する側で明示的にアクセスを許可する必要があります。CORSの詳しい説明はMDNを参照してください[^11]。

[^11]: <https://developer.mozilla.org/ja/docs/Web/HTTP/CORS>

## コラム: URLという言葉の歴史

URLという言葉は多くの読者に馴染みがあると思いますが、この言葉は混乱を乗り越えてきた歴史があります。

ティム・バーナーズ＝リーが最初に提唱したURLは、"Universal Resource Locator"の略称でした。後に、"Uniform Resource Locator"の略称とされ、最初期にはRFC 1630、次にRFC 1738として標準化されました。その後、リソースを場所ではなく名前で特定する「URN」(Uniform Resource Name)という方式が提唱され、RFC 2141で規定されます。さらにその後、URLとURNをあわせた一般的な概念として、「URI」(Uniform Resource Identifier)と呼ぶようになりました。URIは初めにRFC 2396、後にRFC 3986として標準化されました。古いHTML4の仕様では“URI”という表記が使われています。そのまたさらに後、URIの国際化表記である「IRI」(Internationalized Resource Identifier)がRFC 3987として標準化されています。

こうして、“URL”、“URI”、“IRI”という3種類の表記が生まれました。“URL”は“URI”の一種であり、“URI”は“IRI”の一種です。ですので、“URL”という言葉が使える文脈では、3つのどれを使っても意味が通じます。こうなると逆に使い分けが難しくなってきます。そして世間一般では、“URI”や“IRI”はそこまで知られておらず、“URL”という言葉が使われ続けていました。

また、様々な技術仕様で技術用語としてURIやIRIが用いられていましたが、各技術仕様で規定しているURIやIRIがそれぞれ微妙に異なることが知られています。URIやIRIは、技術的な内容も混乱していたという状況もありました。

いずれにせよ、単語としてURLが世間的によく使われているという状況も踏まえて、HTML5では改めて“URL”という名前で統合することにしました。ここで言うURLは、技術的にはRFC 1738のURLと同じものではありません。RFC 3986のURIやRFC 3987のIRIだけでなく、URLに関連する技術仕様も含めて、統合・整理したものとなっています。当初、このURLの仕様はHTML仕様の中で規定されていましたが、後にURL Standardとして独立したWHATWG標準になりました。

つまるところ、名称としてはURL→URI→IRIと変遷した上で、もう一度“URL”に戻ってきたということになります。
このような背景で成立したため、現在のWHATWG URLは"Uniform Resource Locator"の略ではなく、単にURLというものとして定義されています。
