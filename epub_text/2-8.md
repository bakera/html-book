---
title: "HTMLの細かい構文ルール"
---

# <span class="number">08</span> HTMLの細かい構文ルール

主にセキュリティの観点から、通常は行わないマークアップの解釈について、詳細な検討が必要となることがあります。ここでは、タグの書き方について、もう一歩踏み込んだ説明をします。

## HTMLの細かい構文ルール

HTMLパーサー(HTMLを解釈するプログラム)のルールは仕様で明確に定められています。仕様のParsing HTML documentsのセクション[^1]では、ある状況で特定の文字が出現した場合にどのように解釈するのか、というレベルまで挙動が規定されています。「このような書き方は可能か？」「このように書いた場合にどのように解釈されるのか？」という疑問は、ほとんどの場合、仕様をつぶさに読むことで解決できます。

[^1]: Parsing HTML documents  
<https://html.spec.whatwg.org/multipage/parsing.html>

## <a id="tagname-character">タグ名に使用できる文字</a>

*HTMLのタグ名は「ASCII 英字(ASCII alpha)」[^2]で始まる必要があり、数字で始まることは許されません。*つまり、\[01]のようなマークアップは構文エラーとなり、結果としてタグではなくテキストとして解釈されます\[02][^3]。

[^2]: ASCII英字は、a～zのアルファベット小文字とA～Zのアルファベット大文字です。  
<https://infra.spec.whatwg.org/#ascii-alpha>

[^3]: この場合、invalid-first-characterof-tag-name parse errorとなります。

<figure>
<figcaption>[01] タグ名が数字の開始タグを誤って記述した例</figcaption>

```html
<42>
```

</figure>
<figure>
<figcaption>[02] エラー処理による[01]の解釈</figcaption>

```html
&lt;42>
```

</figure>

*ASCII英字でなければならないのは1文字目だけです。*構文上、2文字目以降にはほとんどの数字や記号類が使用できます[^4]。2文字目以降に利用できない文字は、以下に挙げるものに限られます。

[^4]: タグ名の2文字目以降にASCII英字でない文字が使われている例としては、`h1`要素などがあります。

- `>`: タグの終了と解釈されます
- ASCII空白文字: 属性値との区切りと解釈されます
- `/`: 自己終了タグもしくは属性値との区切りと解釈されます

興味深いことに、タグの開始のマークである`<`も利用できる文字となっており、タグ名の一部として解釈されます。たとえば\[03]は、`<h1>`タグの`>`が抜けた形ですが、これは`h1<span`という名前の要素があるものとみなされ、\[04]のように解釈されます。

<figure>
<figcaption>[03] <code>&lt;h1></code>タグの<code>></code>が抜けた記述例</figcaption>

```html
<body>
<h1<span>test</span></h1>
</body>
```

</figure>

<figure>
<figcaption>[04] ブラウザーによる[03]の解釈</figcaption>

```html
<body>
<h1<span>test</h1<span>
</body>
```

</figure>

タグ名に`<`を含めることができるのは、SGMLやXMLとは互換性のない挙動です[^5]。SGMLでは、\[03]のようなケースを「閉じない開始タグ(unclosed start tag)」とみなし、`<h1><span>`と補います。XML構文の場合には、*Well-formed*[^6]ではないため、パースエラーとなります。

[^5]: \[03]は構文エラーですが、エラー処理により、対応する開始タグがない`</h1>`と`</span>`は無視され、`</body>`の前に`</h1<span>`の終了タグが補われています。

[^6]: WORD: Well-formed(整形式)  
XMLの文書について、タグの対応関係などの字句的ルールが満たされていること。語彙的ルールを満たすかどうかは問わない。

*セキュリティの観点から、タグ名に後続する`/`の扱いに注意が必要です。*\[05]のマークアップは構文エラーですが、`/`はタグ名の一部とはみなされません。エラー処理により、`/`の後が属性名とみなされ、\[06]のように解釈されます[^7]。タグ内部に空白を挿入できなくても、属性を挿入できる点に注意が必要です。

[^7]: この場合、unexpected-solidusin-tag parse errorとなります。

<figure>
<figcaption>[05] タグ名の後に<code>/</code>を含む記述例</figcaption>

```html
<span/onmouseover="alert(1);">test</span>
```

</figure>
<figure>
<figcaption>[06] エラー処理による[05]の解釈</figcaption>

```html
<span onmouseover="alert(1);">test</span>
```

</figure>

## 終了タグに属性は書けない

終了タグに属性を書くことはできません。終了タグに属性を書いた場合\[07]、エラーとなり、属性は無視されます[^8]。なお、終了タグ自体は有効に機能します。

[^8]: この場合、end-tag-with-attributes parse errorとなります。

<figure>
<figcaption>[07] 終了タグに誤って属性を記述した例</figcaption>

```html
<p>foo</p class="foo">
```

</figure>

## 終了タグ末尾の/

終了タグの末尾に`/`を書くことはできません。\[08]の場合はエラーとなり、単に`/`が無視されます[^9]。なお、終了タグ自体は有効に機能します。

[^9]: この場合、end-tag-with-trailing solidus parse errorとなります。

<figure>
<figcaption>[08] 終了タグ末尾に誤って<code>/</code>を記述した例</figcaption>

```html
<p>foo</p/>
```

</figure>

## 空タグ

SGMLでは*「空タグ(empty tag)」*と呼ばれる記述が許されており、理論上はHTML4でも使用可能でした[^10]。これは文字通り、タグ名部分を省略した空のタグです。空の開始タグと、空の終了タグがあり、直近に開いた要素の名前を参照します。\[09]は空タグの記述例です。

[^10]: もっとも、実際にはほとんどのブラウザーは空タグを仕様のとおりには処理していませんでした。

<figure>
<figcaption>[09] 空タグの記述例</figcaption>

```html
<p>テキスト</>
<>テキスト</>
```

</figure>

\[09]では、`<>`と`</>`は、それぞれ`<p>`と`</p>`の省略とみなされます。

しかし、*このような空タグは現在のHTML構文では使用できません。*空の開始タグはエラーとなり、`<>`という文字列のテキストノードになります。空の終了タグもエラーですが、こちらは終了タグが丸ごと無視されます。\[09]の場合、`p`要素が2つできることはなく、`"テキスト <>テキスト"`というテキストノードを持った1つの`p`要素になります。

## 開始タグを省略すると属性は書けない

開始タグは省略できる場合があります。その一方で、開始タグを省略した際に属性のみを書く方法は存在しません。つまり、*属性を指定したければ必ず開始タグを書かなければなりません。*

たとえば、`html`要素の開始タグは省略可能ですが、`lang`属性を指定したい場合は開始タグを書く必要があります\[10]。

<figure>
<figcaption>[10] 属性値を指定した開始タグの記述例</figcaption>

```html
<html lang="ja">
```

</figure>

## 重複する属性

同一の属性は複数指定できません。

\[11]は構文エラーとなり、後続の属性が無視されて\[12]のように解釈されます[^11]。

[^11]: この場合、duplicate-attribute parse errorとなります。

<figure>
<figcaption>[11] 同一属性を複数記述したエラーとなる例</figcaption>

```html
<body class="type1" class="type2">
```

</figure>
<figure>
<figcaption>[12] エラー処理による[11]の解釈</figcaption>

```html
<body class="type1">
```

</figure>

属性の種類によっては、1つの属性に複数の値を指定できる場合があります。`class`属性の場合、\[13]のようにASCII空白文字で区切って指定します。

<figure>
<figcaption>[13] <code>class</code>属性で複数の値を指定した例</figcaption>

```html
<body class="type1 type2 type3">
```

</figure>

## 属性値の省略

[CHAPTER 2-2<!--(P059)-->のブール型属性](2-2.xhtml#bool-attribute)でも触れましたが、空の属性値の記述は省略できます。\[14]の3つの`img`要素の書き方は同じ意味になります[^12]。

[^12]: `img`要素については[CHAPTER 3-8](3-8.xhtml)で詳しく説明します。

<figure>
<figcaption>[14] 属性値の省略例</figcaption>

```html
<img alt>
<img alt="">
<img alt=''>
```

</figure>

`<img alt="">`と書いた場合、ブラウザーの開発者ツールで調査してDOMツリーを見ると`<img alt>`と表示される場合があります。これは、もっとも短い書き方で正規化されているためです。

なお、属性自体を丸ごと省略した場合とは意味が異なることに注意してください。\[14]にある`img`要素の`alt`属性の場合は、属性を省略したときと意味が大きく異なり、ブール型属性の場合は意味が正反対となります。

## <a id="no-quote-attribute">引用符のない属性</a>

属性を書く場合には属性値を引用符で括るのが基本ですが、引用符を省略できる場合もあります。引用符を省略した場合、以下のようになります。

- タブ、改行、スペース、`>`が出現すると属性値の終了とみなされる
- `"`、`'`、`<`、`=`、<code>\`</code>が出現すると構文エラーとなるが[^13]、該当の文字は属性値の一部とみなされて処理される

[^13]: この場合、unexpected-characterin-unquoted-attribute-value parse errorとなります。

属性値を引用符で括った場合、対応する引用符(「`"`」もしくは「`'`」)で終了するのに対し、括らない場合はさまざまな文字で属性値が終了します。これは*クロスサイトスクリプティング(XSS)[^14]*脆弱性の原因となりやすいため、セキュリティ上の観点からは、属性値を引用符で括ることが強く推奨されています。

[^14]: クロスサイトスクリプティング(XSS)  
ユーザーが入力した内容を表示するようなウェブサイトで、不正な内容を表示させてHTMLの構文を破壊し、悪意のあるHTMLやスクリプトを挿入する攻撃。本物サイト上で偽情報が表示されたり、スクリプトが実行されて不正な操作、情報の詐取などが行われることがある。

## `plaintext`要素の処理

昔のHTMLでは`plaintext`要素が定義されていました。これはもともと、HTTP/0.9で`Content-Type`フィールドが存在しなかった時代に、データの先頭に`<plaintext>`と書くことで、プレーンテキストであることを明示するものでした。

現在のHTMLではこの要素は廃止されていますが[^15]、ブラウザーは`plaintext`というタグ名の開始タグに遭遇すると、以降をすべてプレーンテキストとして処理し、タグも文字参照も解釈しなくなります。`</plaintext>`という文字列があってもそのまま表示します。現在では、`Content-Type: text/plain`を指定してプレーンテキストであることを示せるため、`plaintext`要素を使う必要はありません。

[^15]: HTML Standardではobsolete feature(廃止された機能)として記載されています。

何らかの理由で`Content-Type`を適切に設定できない場合に、これを書くことで、`Content-Type`ヘッダーの誤判定によるXSSを回避できるケースがあるかもしれません。

## <a id="end-tag-error">終了タグを書き漏らした際のエラー</a>

終了タグを書き漏らした場合、特殊な方法で補われるケースがあります。\[15]は問題のないマークアップです。

<figure>
<figcaption>[15] 問題のないマークアップ例</figcaption>

```html
</b></p>
<p>bのないp</p>
```

</figure>

一方で、\[16]のように終了タグ`</b>`を書き忘れたとしましょう。

`b`要素の終了タグは省略できないため、これは構文エラーになります。エラー処理の結果、これは\[17]のように解釈されます。

終了タグが補われただけでなく、次の`p`要素の外側が`b`要素とみなされます。エラー修正のされ方は要素によっても異なり、かなり複雑です。後述のように、直感に反する挙動となることもあるため、エラーが起こらないようにマークアップすることをお勧めします。

<figure>
<figcaption>[16] <code>&lt;/b></code>を書き忘れた記述例</figcaption>

```html
<p><b>b開始タグ</p>
<p>bのないp</p>
```

</figure>

<figure>
<figcaption>[17] エラー処理による[16]の解釈</figcaption>

```html
<p><b>b開始タグ</b></p>
<b><p>bのないp</p></b>
```

</figure>

## 直感に反するエラー処理

HTML Standardのエラー処理には、直感に反する独特なルールがいくつかあります。

### ノアの箱舟ルール

\[16]に`<b>`の終了タグを書き忘れた例を紹介しました。

\[18]は、`<b>`を4つに増やした例です。これは\[19]のように補われます。

<figure>
<figcaption>[18] <code>&lt;b></code>を4つに増やした記述例</figcaption>

```html
<p><b><b><b><b>4つのb開始タグ</p>
<p>bのないp</p>
```

</figure>

<figure>
<figcaption>[19] エラー処理による[18]の解釈</figcaption>

```html
<p><b><b><b><b>4つのb開始タグ</b></b></b></b></p>
<b><b><b><p>bのないp</p></b></b></b>
```

</figure>

一見、`<b>`が1つのときと同じルールで補正されているように見えますが、よく見ると、2行目の`p`要素の外側に補われている`<b>`タグと`</b>`タグの数は3つしかありません。4つあったはずの`b`要素が1つ減っているのです。

これは、*要素をまたがって補われる際、同一要素名・同一クラス名の要素は3つまでしか復元されないというルールがあるからです。*

仕様の注記では、これは*「ノアの箱舟(Noah's Ark)」*[^16]であるとされています。

[^16]: ノアの箱舟は、旧約聖書で動物のつがいを1つずつ選ぶ話ですが、ここでは3つずつになります。  
99%のウェブサイトではフォント装飾要素の入れ子の数が3つ以下である、という調査結果からこの数が決められました。  
<https://www.w3.org/Bugs/Public/show_bug.cgi?id=10802>

### foster parenting

`table`要素にはfoster parentingと呼ばれる特殊なエラー処理があります。\[20]は`table`要素のマークアップの例です。

<figure>
<figcaption>[20] <code>table</code>要素のマークアップ例</figcaption>

```html
<table>
<tr>
<th>見出しセル</th>
<td>データセル</td>
</tr>
</table>
```

</figure>

`table`要素直下には、`caption`、`col`、`colgroup`、`thead`、`tbody`、`tfoot`要素といったテーブル関連要素を入れることができます[^17]。

[^17]: `table`要素直下には`tr`要素が出現してもかまいません。この場合は`tbody`要素が自動的に補われます。`th`要素や`td`要素が`table`要素直下に出現した場合は構文エラーとなりますが、エラー処理によって`tr`要素が補われます。

`table`要素の内部にテーブルとは関係のない要素が現れた場合はどうなるでしょうか。\[21]は、`table`要素の末尾に`p`要素を挿入しようとした例です。これは構文エラーとなり、\[22]のように解釈されます。

<figure>
<figcaption>[21] <code>table</code>要素の末尾に<code>p</code>要素を挿入した例</figcaption>

```html
<table>
<tr>
<th>見出しセル</th>
<td>データセル</td>
</tr>
<p>何かテキスト</p>
</table>
```

</figure>
<figure>
<figcaption>[22] エラー処理による[21]の解釈</figcaption>

```html
<p>何かテキスト</p>
<table>
<tr>
<th>見出しセル</th>
<td>データセル</td>
</tr>
</table>
```

</figure>

\[22]では、\[21]で下方にあった`p`要素が、`table`要素の前に移動されています。

通常、このような語彙的ルールの違反があってもそのままの形でDOMツリーが構築されるのですが、*`table`要素では不正な子孫要素が前に追い出される形になります。一見奇妙ですが、この処理は仕様に定められている正式な挙動で、foster parentingと呼ばれています[^18]。*

[^18]: foster parentは「里親」というような意味です。

テキストノードでも同様の処理が行われるため、注意が必要です。
\[23]は、一見すると問題のないマークアップですが、誤って全角スペース(U+3000)でインデントを行っている例です。

<figure>
<figcaption>[23] インデントに全角スペースを使用した例</figcaption>

```html
<p>以下の表をご覧ください。</p>
<table>
<tr>
[　]<td>日本</td>
</tr>
</table>
```

</figure>

*[　]の部分は全角スペースです。*全角スペースはASCII空白文字ではないため、`table`要素の直下に出現できないテキストノードとして扱われます。よって、foster parentingによって`table`要素の前に移動されます\[24]。

<figure>
<figcaption>[24] エラー処理による[23]の解釈</figcaption>

```html
<p>以下の表をご覧ください。</p>
[　]
<table>
<tr>
<td>日本</td>
</tr>
</table>
```

</figure>

結果として`p`要素と`table`要素の間に全角スペースのテキストノードが挿入され、余白ができることになります。このように、`table`要素の中に内容モデルに従わないものが存在すると、予想外の挙動になることがあります。
