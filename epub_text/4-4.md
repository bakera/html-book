---
title: "WAI-ARIAの実践"
---

# <span class="number">04</span> WAI-ARIAの実践

ここでは、実際にウェブでよく使われるウィジェットの事例を通じて、WAI-ARIAをどのように利用するのか、その検討の過程や考え方について紹介します。

## 事例1： ハンバーガーメニューを改良する

モバイル用のページでは、通常はメニューを隠しておき、ボタンを押すことでメニューが開く仕組みがよく見られます[^1]。\[01]のように、メニューを開くボタンが3本の横棒で表現されたものは*「ハンバーガーメニュー」*と呼ばれます[^2]。一般的なハンバーガーメニューは、以下のような機能を持ちます。

[^1]: 詳細なコード例についてはWAI-ARIA Authoring Practicesなどを参照してください。  
<https://www.w3.org/TR/wai-ariapractices/>

- ユーザーがボタンを押すと、メニューが出現する
- メニューにはサイト内の主要なコンテンツへのリンクが含まれる
- メニューはコンテンツに覆いかぶさるような形で現れ、メニューが開いている間はメニューの外のコンテンツは利用できない
- メニューが出現すると、メニューを開くボタンはメニューを閉じるボタンに変化する
- 閉じるボタンを押すとメニューは消え、元の状態に戻る

<figure>
<figcaption>[01] 一般的なハンバーガーメニューの例（左：閉じた状態　右：開いた状態）</figcaption>
<img src="../image/C4_04_01_1_1C.png" alt="" />
<img src="../image/C4_04_01_2_1C.png" alt="" />
</figure>

[^2]: 参考サイト  
弁護士ドットコム - 無料法律相談や弁護士、法律事務所の検索  
<https://www.bengo4.com/>

多くのサイトで見られるパーツですが、アクセシビリティ上の留意点がいくつかあります。深く考えずに作られたハンバーガーメニューは、たとえば\[02]のようなマークアップになっていることがあります。

<figure>
<figcaption>[02] ハンバーガーメニューのマークアップ例</figcaption>

```html
<div class="hamburgerMenu">
  <div class="button">
    <!-- 閉じている場合にのみ表示され、開くとdisplay:noneになる -->
    <span class="menu-icon"></span>
    <!-- 開いている場合にのみ表示され、閉じるとdisplay:noneになる -->
    <span class="close-icon"></span>
  </div>
  <ul>
    <li><a href="/">ホーム</a></li>
    <!-- メニュー -->
  </ul>
</div>
```

</figure>

`<div class="button">`がボタンに相当します。中に入っている2つの`span`要素は、それぞれハンバーガーアイコンと閉じるアイコンに相当し、CSSの`background-image`プロパティを使用してアイコン画像を表示します。そして、\[03]のような*JavaScriptで`div`要素に`click`イベントのイベントハンドラーを付け、動くようにします。*

<figure>
<figcaption>[03] ハンバーガーメニュー用のJavaScript例</figcaption>

```javascript
const hamburgerMenu = document.querySelector('.hamburgerMenu');
const hamburgerMenuButton = hamburgerMenu.querySelector('.button');
hamburgerMenuButton.addEventListener('click', event => {
  hamburgerMenu.classList.toggle('js-opened');
});
```

</figure>

さまざまなJavaScriptの実装方法が考えられますが、ここでは単純に、外側の`div`要素に`js-opened`クラスを付けたり外したりしています。そして、\[04]のようなCSSでメニュー項目の`ul`要素を非表示にし、`js-opened`クラスが付いたときだけ表示されるようにします。

<figure>
<figcaption>[04] ハンバーガーメニューのCSS例</figcaption>

```css
.hamburgerMenu ul{
  display: none;
}
.hamburgerMenu.js-opened ul{
  display: block;
}
```

</figure>

これでメニューボタンは動作しますが、このメニューにはアクセシビリティ上の問題点が複数あります。ここでは、このマークアップで作成されたメニューが既に存在すると仮定して、アクセシビリティを向上していく過程の考え方を紹介します[^3]。

[^3]: アクセシビリティを向上する手段の代表例がWAI-ARIAですが、CHAPTER 4-3で紹介したように、WAI-ARIAを利用することが必ずしも望ましいとは限りません。ここでは、WAI-ARIAを利用する方法、しない方法の両方を含めて検討していきます。

### キーボード操作を可能にする

このメニューの最大の問題は、キーボードで操作できないことです[^4]。メニューボタンは`div`要素で実装されています。`click`イベントを付けているため、マウスでのクリックやタップには反応します。しかし、キーボードでは、そもそもボタンにフォーカスを当てることができません。

[^4]: キーボード操作は、WCAG 2.1の達成基準2.1.1「キーボード」で要求されているアクセシビリティ上の重要事項です。  
<https://www.w3.org/TR/WCAG21/#keyboard>  
CHAPTER 4-3の「マウスやタッチで操作可能なものはキーボードでも操作可能にする」（P310）も参照してください。

キーボード操作を可能にする方法はいくつかあります。

#### 方法1：button要素を使用する

CHAPTER 4-3でも触れてきたように、WAI-ARIAを使う前に、まずHTMLのネイティブ機能が使えないか検討すべきです。ここでは\[05]のように、HTMLの`button`要素を使うことができます。

<figure>
<figcaption>[05] <code>button</code>要素を仕様した例</figcaption>

```html
<button>
  <span class="menu-icon"></span>
  <span class="close-icon"></span>
</button>
```

</figure>

これだけでキーボード操作が可能になります。`role`属性も`tabindex`属性も`keypress`イベントも必要ありません。`button`要素はそれらの機能を既に備えているからです。

#### 方法2：a要素を使用する（非推奨）

おすすめはしませんが、`a`要素でもフォーカスを受け取ることはできます。`a`要素に`role=button`を指定すると、ボタンであると宣言することができます。

`role`属性の指定は単に役割を宣言するだけです。`role=button`を指定しても、ボタンと同じ挙動にはならないことに注意してください。

`a`要素は`button`要素とは動作が異なります。たとえば、`button`要素ではフォーカスしたあとにスペースキーでボタンを押すことができますが、`a`要素ではできません。可能な限り`button`要素を利用するべきです。

#### 方法3：divのままキーボード操作可能にする（非推奨）

まったくおすすめしませんが、何らかの理由で`button`要素が利用できない場合、`div`要素のままキーボード操作を可能にする方法もあります。

\[06]のように、`tabindex=0`と`role=button`を指定すると、フォーカスが当たるようになり、スクリーンリーダーでも「ボタン」と読み上げられます。

<figure>
<figcaption>[06] <code>tabindex=0</code>を指定した例</figcaption>

```html
<div class="button" role="button" tabindex="0">
  <span class="menu-icon"></span>
  <span class="close-icon"></span>
</div>
```

</figure>

さらに、キーボード操作に対応するために、\[07]のようなJavaScriptで`keypress`イベントを付けます。

<figure>
<figcaption>[07] <code>keypress</code>イベントをJavaScriptで追記する例</figcaption>

```javascript
hamburgerMenuButton.addEventListener('keypress', event => {
  // Enterキーやスペースキーでボタンが押せ、かつTabキーではボタンが押されないような実装...
});
```

</figure>

このイベント内では、押されたキーを判定して、<kbd>Enter</kbd>キーやスペースキーならばボタンが押されるように、かつ<kbd>Tab</kbd>キーなどの操作を横取りしないように実装します。

繰り返しになりますが、この方法はおすすめしません。

### 何のボタンかわかるようにする

`button`要素を利用すると、スクリーンリーダーを使ってボタンにフォーカスを当てたとき、「ボタン」と読み上げられます。しかし、単に「ボタン」と読み上げられても、これが何をするボタンかはわかりません。

*何のボタンかわかるようにするために、ボタンにラベルを与える必要があります。*たとえば、「メニュー」というラベルを与えると、「メニューボタン」などと読み上げられ、何のボタンか伝わります[^5]。

[^5]: 「メニュー」や「閉じる」アイコンは意味を持つ画像コンテンツと考えられます。WCAG 2.1達成基準1.1.1「非テキストコンテンツ」では、テキストによる代替を提供することが求められています。  
<https://www.w3.org/TR/WCAG21/#non-text-content>

ボタンにラベルを与える方法はいくつかあります。

#### 方法1：画像をimg要素にしてaltでテキストを指定する

CHAPTER 3-11で紹介したとおり、`button`要素は、内容に含まれるテキストをラベルとして扱います。アイコンをCSSの背景画像で実装することをやめて、\[08]のように`img`要素の`alt`属性[^6]で代替テキストを提供すれば、ラベルとして扱われることになります。

[^6]: `img`要素の`alt`属性については、CHAPTER 3-8（P182）も参照してください。

<figure>
<figcaption>[08] <code>alt</code>属性でテキストを指定した例</figcaption>

```html
<button>
  <!-- 閉じている場合にのみ表示され、開くとdisplay:noneになる -->
  <span class="menu-icon"><img src="menu.png" alt="メニュー"></span>
  <!-- 開いている場合にのみ表示され、閉じるとdisplay:noneになる -->
  <span class="close-icon"><img src="close.png" alt="閉じる"></span>
</button>
```

</figure>

このようにすると、スクリーンリーダーで読み上げられることに加え、画像が表示できないケースや、通信速度の問題で画像を表示しないようにしている場合などに代替テキストが利用されることが期待されます。ただし、ブラウザーによっては代替テキストを表示しないこともあります。

なお、`img`要素を用いるこの方法は、サイトの高速化を意図した「CSSスプライト」と呼ばれる技法と相性が悪いという問題があります。最近はCSSスプライトが使われることも少なくなってきましたが、CSSスプライトの利用が必須である場合は、他の方法を考えましょう。

#### 方法2：スクリーンリーダー用テキストを入れる

`button`要素の中にテキストがあれば、ラベルとして扱われます。それは必ずしも、視覚的に見えている必要はありません。\[09]のように、スクリーンリーダーで読み上げさせる専用のテキストを入れる方法もあります。

<figure>
<figcaption>[09] スクリーンリーダー用テキストの記述例</figcaption>

```html
<button>
  <span class="visually-hidden">メニュー</span>
  <span class="menu-icon"></span>
  <span class="close-icon"></span>
</button>
```

</figure>

`visually-hidden`は、視覚環境で表示されず、かつスクリーンリーダーでは読み上げられるようなスタイルを定義したクラスです。詳細はCHAPTER 4-3の「スクリーンリーダー向けテキストを提供する」（P315）を参照してください。

なお、単純にCSSの`display:none`の指定を用いると、スクリーンリーダーからも参照できなくなり、読み上げられなくなるため注意が必要です。

#### 方法3：aria-label属性を利用する

別の選択肢として、\[10]のように`aria-label`属性を利用する方法もあります。

<figure>
<figcaption>[10] <code>aria-label</code>属性の記述例</figcaption>

```html
<button aria-label="メニュー">
  <span class="menu-icon"></span>
  <span class="close-icon"></span>
</button>
```

</figure>

このようにすると、`aria-label`属性に対応しているスクリーンのリーダーでは「メニューボタン」と読み上げることが期待できます。

ただし、`aria-label`属性で指定したラベルは、支援技術のユーザーにしか伝わらないという問題があります。視覚環境において、何らかの理由でCSSが無効になった場合、方法1や方法2ではボタンのアイコンやラベルが見えますが、この方法ではボタンの内容がまったく表示されなくなります。

`aria-label`属性の利用はスマートな方法に見えますが、おすすめできるものではありません。

#### 方法4：aria-haspopup属性を利用する

ボタンの意味を伝える方法には、ボタンにラベルを与える以外のアプローチもあります。\[11]は、メニューボタンに`aria-haspopup`属性を指定した例です。

<figure>
<figcaption>[11] <code>aria-haspopup</code>属性を指定する記述例</figcaption>

```html
<button aria-haspopup="menu">
  <span class="menu-icon"></span>
  <span class="close-icon"></span>
</button>
```

</figure>

こうすると、`aria-haspopup`属性に対応したスクリーンリーダーでは、「ボタンメニューポップアップ」などと読み上げられます。ボタンにラベルはありませんが、押せばポップアップメニューが出現することは伝わります[^7]。

ボタンにラベルがある場合、それもあわせて読み上げられます。ラベルが「メニュー」の場合は、「メニューボタン メニュー ポップアップ」と読み上げられます（「メニュー」が2回出現しますが、前者はボタンのラベル、後者は`aria-haspopup`属性の値です）。これは冗長になるため、ボタンのラベルだけで動作が十分に伝わる場合は、`aria-haspopup`属性を指定すべきでないという考え方もあります。

[^7]: `aria-haspopup`属性は、あくまでポップアップが現れることを知らせるものです。メニューがポップアップするのではなく、他の方法で出現する場合は、`aria-haspopup`属性を使用するべきではありません。

なお、このボタンが閉じるボタンに変化する場合、「メニュー ポップアップ」と読み上げられると混乱を招くため、動作にあわせて`aria-haspopup`属性を削除する必要があります。

### メニューの開閉状態がわかるようにする

ここまでで、キーボード操作ができ、ボタンも「メニュー ボタン」と読み上げられるようになりました。これで、メニューボタンを利用できる最低限の条件は満たしています。

メニューを開いた際、視覚的には、メニューが開いたことは一目瞭然です。しかし、*スクリーンリーダーのユーザーには、メニューが開いたかどうかはわかりません。*

今回はボタンに「メニュー」というラベルを付けましたから、メニューが開いただろうと想像はできるでしょう。しかし、実際にどこがどう変化したかはわかりませんし、メニューの開閉状態、つまりメニューが開いているのか、閉じているのかもわかりません。

この問題について、対応を検討していきましょう。

#### 方法1：開いたメニューにフォーカスを移す

メニューが開いたことを伝える方法の1つは、開いたメニューにキーボードフォーカスを移してしまうことです。先のスクリプトにあったボタンクリック時のイベントに、\[12]のようなフォーカス移動の処理を追加します[^8]。

[^8]: WCAG 2.1の達成基準 3.2.5「要求による変化」では、フォーカス移動のようなコンテキストの変化は、ユーザーの要求によってだけ生じるようにすることが望ましいとされています。この例では、ユーザーが「メニュー」というボタンを押すことによってフォーカスが移動しますから、この達成基準には抵触しません。  
<https://waic.jp/docs/WCAG21/#change-on-request>

<figure>
<figcaption>[12] 先頭の<code>a</code>要素にフォーカスを移動するコード例</figcaption>

```javascript
hamburgerMenuButton.addEventListener('click', event => {
  hamburgerMenu.classList.toggle('js-opened');
  hamburgerMenu.querySelector('ul a').focus(); // この行を追加
});
```

</figure>

こうすると、メニューを開くと同時に、メニューの先頭の項目にフォーカスが移動します。スクリーンリーダーはメニューの先頭の項目を読み上げ始めるので、メニューが開いたことは確実に伝わるでしょう。

この方法はわかりやすい反面、フォーカスを強制的に移動させる点に注意が必要です。HTMLソースコード上で、ボタンの直後にメニューが存在する場合は、直後の要素にフォーカスが移るだけで、元の位置に戻ることもできるため、大きな問題はないでしょう[^9]。

[^9]: HTMLソースコード上、メニューがボタンとかけ離れた場所にある場合、WCAG 2.1達成基準1.3.2「意味のある順序」の観点でも問題となる場合があります。  
<https://www.w3.org/TR/WCAG21/#meaningful-sequence>

メニューがボタンから離れている場合は、慎重な設計が必要です。メニューを開いたあと、ユーザーは<kbd>Shift+Tab</kbd>キーでフォーカスを戻そうとするかもしれません。フォーカス移動先がHTMLのDOMツリー上で離れた位置にあると、<kbd>Shift+Tab</kbd>キーの操作では元に戻れない場合があります。出現するメニューは、メニューボタンの直後に置くことが望ましいでしょう。

#### 方法2：ボタンのラベルで状態を伝える

フォーカスを移さない場合、ボタンのラベルで現在の状態を伝える方法もあります。たとえば\[13]のように、メニューが開くと同時にボタンのラベルを「メニューを閉じる」に変えるようにします。

<figure>
<figcaption>[13] ボタンのラベルを変更する例</figcaption>

```html
<button>
  <!-- 閉じている場合にのみ表示され、開くとdisplay:noneになる -->
  <span class="menu-icon"><img src="menu.png" alt="メニュー"></span>
  <!-- 開いている場合にのみ表示され、閉じるとdisplay:noneになる -->
  <span class="close-icon"><img src="close.png" alt="メニューを閉じる"></span>
</button>
```

</figure>

こうすると、ボタンを再度読み上げさせれば「メニューを閉じる ボタン」と読み上げられ、現在メニューが開いている（だから閉じることができる）と推測できるでしょう[^10]。

[^10]: 見た目上はボタンの隣にメニューが表示され、しかしHTMLソースコード上ではボタンと離れた場所にメニューが存在する場合、フォーカス移動先が予想外の要素になることがあります。その場合、WCAG 2.1達成基準2.4.3「フォーカス順序」の問題も生じます。  
<https://www.w3.org/TR/WCAG21/#focus-order>

ただし、メニューが開いたことがわかっても、実際にメニューに移動できるかどうかは別の話です。HTMLソースコード上、ボタンの直後にメニューを挿入するか、前述の方法1のように、フォーカスを制御するとよいでしょう。

#### 方法3：aria-expanded属性を利用する

WAI-ARIAには開閉状態を通知する`aria-expanded`属性があります。メニューが開いた際、\[14]のように`aria-expanded=true`を追加します。

<figure>
<figcaption>[14] <code>aria-expanded</code>属性を利用する例</figcaption>

```html
<button aria-expanded="true">
```

</figure>

こうすると「メニュー ボタン 開いています」などと読み上げられます。同様に、メニューが閉じた際に`aria-expanded=false`を指定すると「メニュー ボタン 閉じています」などと読み上げられます（「隠されました」などと読み上げることもあります）。

`aria-haspopup`属性と同様、ボタンのラベルとあわせて読み上げることに注意してください。メニューが既に開いていて、ボタンのラベルが「メニューを閉じる」となっている場合、`aria-expanded=true`を指定すると、「メニューを閉じるボタン開いています」と読み上げられます。これは冗長ですし、むしろ混乱を招くことがあります[^11]。

初期状態では`aria-expanded`属性を付けないようにしておき、開いたときだけ`aria-expanded=true`を付ける方法もあります。この場合、メニューが閉じているときは「メニューボタン」と読み上げられ、開いているときは「メニューボタン開いています」と読み上げられます。

この方法は、開いたメニューがページ内のどこに存在するかはわかりません。`aria-controls`属性[^12]で制御対象を明示する方法もあり、それ自体は望ましいことですが、その機能に頼るべきではありません。基本的に、出現するメニューはメニューボタンの直後に置くことが望ましいでしょう。

[^11]: 実際にユーザーに伝わるかどうかは、文脈にもよります。ボタンのラベルや他のARIA属性も合わせた状態で実際に読み上げさせて、ボタンの挙動が伝わるか検討するとよいでしょう。情報が不足している場合だけでなく、情報が多すぎて冗長になっている場合にも伝わらないことがある点に注意してください。

[^12]: CHAPTER 4-2の`aria-controls`属性も参照してください。

### メニューの裏側にフォーカスが当たらないようにする

一般的に、メニューを開いたとき、視覚環境ではメニューがコンテンツに覆いかぶさります。コンテンツはメニューの裏側に隠れて見えなくなり、メニューに隠されない部分があっても、グレーアウトして操作できない状態になります[^13]。

[^13]: 見えない要素にフォーカスが当たってしまう状況は、ユーザーにとって予想外のフォーカス移動になるため、WCAG 2.1の達成基準2.4.3「フォーカス順序」の問題となります。  
<https://www.w3.org/TR/WCAG21/#focus-order>

しかしキーボード操作の場合、メニューが開いた状態でも背後のコンテンツにフォーカスを移せてしまう場合があります。メニューの裏側の要素にフォーカスが移ると、視覚環境のキーボードユーザーはフォーカスを見失い、混乱することがあります。*スクリーンリーダーのユーザーの場合、メニューが開いたままであることに気づかず、普通に利用できてしまうことが多いでしょう。*

このようなフォーカス順序の問題を避ける方法を検討していきます。

#### 方法1：メニューの外の要素をすべてフォーカス不可能にする

メニューが開いたときに、メニューの外の要素をすべてフォーカス不可能にするという方法です。実装方法は複数存在しますが、ここでは方針だけ紹介します。

- メニューの外側のフォーカス可能な要素すべてに`tabindex=-1`を指定
- メニューの外側の要素すべてを`display: none;`や`visibility: hidden`などで削除
- メニューを`dialog`要素として実装し、`showModal()`メソッドで呼び出す[^14]

[^14]: `dialog`要素については、CHAPTER 3-12の`dialog`要素の項を参照してください。また、詳細な実装方法についてはWAI-ARIA Authoring Practicesを参照してください。

`aria-hidden`属性はこの目的では利用できないことに注意してください。`aria-hidden`属性を指定してもフォーカス移動には影響せず、フォーカスを受け取ってしまいます。スクリーンリーダーのユーザーは読み上げられない要素にフォーカスを奪われ、混乱することになります。

#### 方法2：フォーカス移動するときにメニューの先頭に戻す

メニューからフォーカスが外に出るのは、メニューの最後の要素からさらにフォーカス移動しようとしたタイミングです。そのタイミングで<kbd>Tab</kbd>キーの挙動をフックして、メニューの先頭に戻してしまえば、フォーカスはメニューの外に出られなくなります。

メニューの最後の要素に`keypress`イベントを付けてフックする方法もありますが、フォーカストラップを利用する方法もあります。たとえば\[15]のように、メニューの前後に`tabindex`属性を指定した`div`を挿入します。

<figure>
<figcaption>[15] <code>tabindex</code>属性を指定した<code>div</code>要素を挿入した例</figcaption>

```html
<div tabindex="0"></div>
  <ul id="menu01">
    <li><a href="/">ホーム</a></li>
    <!-- メニュー -->
  </ul>
<div tabindex="0"></div>
```

</figure>

キーボード操作でメニューの外にフォーカスを出そうとした際、この`div`要素にフォーカスが当たります。この`div`要素に`focus`イベントを付けておき、フォーカスが当たったタイミングでフォーカスをメニューの先頭、もしくは末尾に移動します。

*この際、フォーカスが脱出不能にならないように注意してください。[^15]*メニューを閉じるボタンが押せなくなると、キーボードユーザーは操作不可能になってしまいます。また、ユーザーはブラウザーのアドレスバーにフォーカスしたい場合に<kbd>Shift+Tab</kbd>キーで戻ることもあります。先頭の要素から前に戻ろうとすることは許容してもよいでしょう[^16]。

[^15]: フォーカスが脱出不能になると、WCAG 2.1達成基準2.1.2「キーボードトラップなし」の要件を満たせなくなります。これはレベルAの要求で、「非干渉」の条件でもある重要な基準です。WCAGへの対応が求められる場合には、この基準を必ず満たさなければなりません。  
<https://www.w3.org/TR/WCAG21/#no-keyboard-trap>

[^16]: スクリーンリーダーのユーザーは<kbd>Tab</kbd>キーを使用せずにフォーカスを移動できる場合もあります。また、フォーカスを移動せずに外の要素を読み上げられることもあります。もっとも、スクリーンリーダーのユーザーは視覚的にフォーカスを見失っても困らないため、そこまで気にしなくてもよいでしょう。

### 方法3：フォーカス移動しようとした場合にメニューを自動的に閉じる

方法2と似ていますが、フォーカスをメニューの先頭に戻す代わりに、メニューを閉じるという方法もあります。実装方法は基本的に方法2と同様で、フォーカスをトラップした際の処理を、メニューを閉じる処理に変更するだけです。

ただし、メニュー項目にフォーカスしたままメニューを閉じると、フォーカスの当たった要素が`display:none`になることでフォーカスが外れてしまい、どこにもフォーカスが当たっていない状態になります。これを避けるために、メニューを開く直前にフォーカスがあった場所、つまりメニューボタンにフォーカスを戻すとよいでしょう。

ただし、この方法には欠点もあります。*ユーザーはメニューが閉じることを予測できませんし、メニューが閉じたことに気づかないことがあります。*これは混乱の原因になります。たとえば、メニューが閉じたあとで<kbd>Shift+Tab</kbd>キーを押しても、直前のメニュー項目に戻ることはできず、予想外の場所にフォーカスが移ってしまいます。

また、メニューが長い場合、閉じてしまったメニューを開き直した上で、もう一度メニュー項目を先頭から読み上げていくことになります。ユーザーが大きなストレスを感じることもあるでしょう。

## 事例2：カルーセルのライブラリーを選定する

*「カルーセル（carousel）」*とは、回転木馬、メリーゴーランドの意味です。ウェブでは、画像やカードなどが横に並び、左右に移動して順繰りに表示される、\[16]のようなコンポーネントを指します。スライドショーと呼ばれたり、イメージローテーターと呼ばれることもあります。

<figure>
<figcaption>[16] 左右のスライドが見切れているカルーセルの例</figcaption>
<img src="../image/C4_03_16.png" alt="" />
</figure>

カルーセルにはさまざまなパターンがありますが、一般的には以下のような機能を持ちます[^17]。

[^17]: カルーセル関連のパーツにはさまざまな呼び方があり、名前は必ずしも統一されていません。たとえば、スライドは「カルーセル項目」「パネル」などと呼ばれることもあります。本書の用語はWAI-ARIA Authoring Practicesにならっています。  
<https://www.w3.org/TR/wai-ariapractices/#carousel>

- 複数の「スライド（slide）」を持つ。個々のスライドには画像やカードなど、視覚的に提示される項目が含まれる
- 一度に表示するスライドは1つだけ（ただし、左右に見切れた状態で前後のスライドが表示されることはある）
- ユーザーの操作により、次のスライド、前のスライドを表示させることができる。この操作を、回転木馬の回転になぞらえて「ローテーション（rotation）」と呼ぶ。多くの場合、カルーセル領域の左右に矢印状のボタンが表示され、これを押すことでローテーションする
- 表示されているスライドをクリックすると、そのスライドに対応するリンク先に遷移する

また、これらに加えて以下の機能を持つケースも見られます。

- スライドピッカーコントロール（slide picker control）を持つ。これはスライドが全部で何枚あり、現在表示中のものが何番目かを示すインジケーターであり、インジケーター部分をクリックすると、対応するスライドを直接表示させることもできる。多くの場合、カルーセル領域の下部に、円が横に並んだ形で表示される
- ページが読み込まれると同時に、ユーザーが操作しなくても自動的にカルーセルがローテーションを始め、一定の速度でローテーションし続ける
- スライドにマウスポインターが乗った場合や、キーボードフォーカスが移った場合に、カルーセルの自動ローテーションを停止する
- ローテーションコントロール（rotation control）を持つ。これは、カルーセルの自動ローテーションを停止・再開できる機能で、多くの場合、オーディオ機器の一時停止・再生ボタンを模したボタンで表現される[^18]

[^18]: すべてのカルーセルが自動ローテーション機能を持つわけではありません。たとえば、ショッピングサイトで複数の商品画像を表示するケースなど、ユーザーが手動でローテーションすることを想定しているものもあります。

このように、カルーセルは多数の機能を持つ複雑なものです。これらすべてを自前で実装するのは大変です。*実際には、カルーセルを扱う専用のライブラリーを利用するケースが多いでしょう。*カルーセルのライブラリーにはさまざまなものがあり、アクセシビリティに配慮したものも、そうでないものもあります。

ここでは、ライブラリーを選定するときに注意したいポイントを見ていくことにしましょう[^19]。

[^19]: すべてを自前で実装する必要がある場合は、WAI-ARIA Authoring PracticesやWeb Accessibility Tutorials を参考にするとよいでしょう。  
3.6 Carousel (Slide Show or Image Rotator)  
<https://www.w3.org/TR/wai-ariapractices/#carousel>  
Web Accessibility Tutorials Carousel  
<https://www.w3.org/WAI/tutorials/carousels/>

### キーボード操作が可能か

カルーセルもキーボードで操作できなければなりません。ライブラリー選定時には、動作サンプルをキーボードで実際に操作してみるとよいでしょう。特に問題になりやすいのは以下の点です。

- 現在表示されているスライドにフォーカスし、リンクをたどることができるか
- 隠れているスライドにフォーカスが当たってしまい、フォーカスを見失うことはないか
- 次のスライド/前のスライドボタンにフォーカスし、操作できるか
- スライドピッカーコントロールにフォーカスし、操作できるか
- ローテーションコントロールにフォーカスし、操作できるか

キーボードフォーカスが見えず、事実上操作できないケースもよく見かけます。*フォーカスが明確に見えるかどうかも確認しましょう。*

### フォーカス時のローテーション停止

カルーセルが自動ローテーションする場合、スライドにフォーカスを移したタイミングでローテーションが行われると、フォーカスを見失うことがあります。*多くのカルーセル実装では、スライドにフォーカスしたときに自動ローテーションを止めることで、これを防いでいます。*

同様に、マウスポインターがスライドに乗ったときにも自動ローテーションを止めることが一般的です。スライドをクリックする瞬間にローテーションが行われると、意図しない遷移先に移動してしまうためです。このような配慮がなされているかどうかも確認しておきましょう。

### スクリーンリーダーで操作できるか

視覚環境だけでなく、スクリーンリーダーで問題なく操作できるかどうかを確認しましょう。

- 現在表示されているスライドが適切に読み上げられるか
- 各種のボタンにラベルが付けられているか
- 隠れているスライドが読み上げられて混乱することはないか

実装方法によっては、隠れているスライドまで読み上げてしまうことがあります。スライドの内容によっては大きな問題がないケースもありますが、多くの場合は混乱を招きます[^20]。

[^20]: 自前で実装する場合は、隠れているスライドに`aria-hidden`属性を適用するのも1つの方法です。ただし、`aria-hidden`属性だけではキーボードフォーカスは当たってしまうことに注意してください。

### 他の箇所の読み上げを妨害しないか

カルーセルが自動ローテーションする場合、1つ重要な注意点があります。自動ローテーション時に、現在の読み上げを妨害しないかという点です。

カルーセルのライブラリーの中には、カルーセル領域をライブリージョンとして実装するものがあります。たとえば、Slick[^21]というライブラリーの古いバージョンでは、\[17]のように、カルーセル領域に`aria-live=polite`を指定していました[^22]。

[^21]: Slick  
<https://kenwheeler.github.io/slick/>

[^22]: カルーセルにライブリージョンを採用しているライブラリーは使うべきではありませんが、どうしても使わざるを得ない場合、スライドのテキストを工夫する方法もあります。たとえば、テキストの頭に「【広告】」と入れれば、現在の読み上げとは無関係の広告を読み上げたとわかり、混乱をやわらげる可能性があります。

<figure>
<figcaption>[17] カルーセル領域に<code>aria-live=polite</code>を指定した例</figcaption>

```html
<div aria-live="polite" class="slick-list draggable">
  <!-- カルーセル領域 -->
</div>
```

</figure>

`aria-live=polite`の指定によって、この領域はライブリージョンとして扱われます。カルーセルがローテーションすると、ライブリージョンの内容が変化するため、その都度、内容が読み上げられます。手動でローテーションした場合は問題ありませんが、カルーセルが自動ローテーションしたタイミングでも読み上げられることになります。

`aria-live=polite`の場合、現在の読み上げが一段落したところで割り込んで内容を読み上げます。たとえば、見出しを読み上げているときにカルーセルが切り替わると、見出しのテキストを読み上げ終えたあと、すぐに続けてカルーセルの内容を読み上げます。これはユーザーを混乱させます。

*カルーセルを自前で実装する場合、ライブリージョンを使う必要があるかどうかは慎重に検討してください。*どうしても利用する必要がある場合は、ユーザーがカルーセル領域から離れたときに`aria-live=off`に切り替えるか、カルーセルの自動ローテーションを止めるとよいでしょう。

### ローテーションコントロールがあるか

ローテーションコントロールは、自動ローテーションするカルーセルを停止する機能です。WCAG 2.1の達成基準2.2.2「一時停止、停止、非表示」は、動き続けるコンテンツを停止できることを求めています[^23]。

[^23]: WCAG 2.1の達成基準2.2.2「一時停止、停止、非表示」はレベルAの要求で、「非干渉」の条件でもある重要な基準です。WCAGへの対応が求められる場合には、この基準を必ず満たさなければなりません。  
<https://www.w3.org/TR/WCAG21/#pause-stop-hide>

カルーセルが自動ローテーションする場合、ローテーションコントロールが提供されていること、それがアクセシブルであることを確認しましょう。

## 事例3：タブのマークアップを検討する

「タブ（tabs）」は、複数のコンテンツを切り替えて表示する機能です。典型的には\[18]のように、コンテンツが入る*「タブパネル（tab panel）」*を複数持っており、その表示を切り替えるためのタブ（tab）を持ちます。タブは、*「タブリスト（tab list）」*としてグループ化されます[^24]。

[^24]: WAI-ARIA Authoring Practicesでは、タブコンポーネント全体のタブ（tabs）と、個別のタブ（tab）を区別しています。  
Tabs  
<https://www.w3.org/TR/wai-ariapractices/#tabpanel>

<figure>
<figcaption>[18] タブの例（WAI-ARIA Authoring Practicesより）</figcaption>
<img src="../image/C4_04_18_1C.png" alt="" />
</figure>

タブは以下のような機能を持ちます。

- 複数のタブとタブパネルから構成される。タブとタブパネルは1対1対応している
- タブリスト内のすべてのタブは見えている状態になっており、初期状態ではいずれか1つのタブが選択されている
- タブパネルは、選択されているタブに対応したものだけが表示され、他のタブパネルは見えない
- 他のタブをクリックすると、そのタブが選択状態になり、選択したタブに対応するタブパネルが表示される。他のタブパネルは表示されなくなる

タブがキーボード操作を受け付ける場合、以下の操作が一般的です。

- タブリストにフォーカスを移すと、選択されているタブがアクティブになる
- キーボードの左右キーを押すと、左右にある他のタブが選択される[^25]

[^25]: キーボードの左右キーによる操作は、他のウェブコンポーネントではあまり見られませんが、OSが提供するタブコントロールの操作に合わせたものです。

ウェブコンテンツでは、タブの表現はよく使われます。ここでは、タブのマークアップについて、いくつかのパターンを検討しながら、考え方の過程を見ていきます。

### タブのマークアップと実装

WAI-ARIAには、タブの部品に対応するロールが用意されています。

- タブ：`tab`
- タブリスト：`tablist`
- タブパネル：`tabpanel`

WAI-ARIAの基本はネイティブの機能を利用することですが、HTMLにはこれらのロールを持つネイティブ要素がないため、既存のHTMLの要素を利用し、`role`属性でこれらのロールを指定することになります。

では、HTMLのどの要素を使うべきでしょうか。ここでは、実際にどのようなマークアップにするべきかを検討していきましょう。

#### タブ

タブはユーザーの操作の対象となる要素です。タブをクリックしたとき、タブパネルが切り替わるようにする必要があります。また、キーボードフォーカスを受け取る必要もあります。フォーカスを受け取れる要素、`a`要素か`button`要素のいずれかを使うべきでしょう[^26]。

[^26]: WAI-ARIA Authoring Practicesのタブの例では`button`要素を使用しています。  
WAI-ARIA Authoring Practices tabpanel  
<https://www.w3.org/TR/wai-ariapractices/#tabpanel>

タブが3つある場合、たとえば\[19]のようなマークアップになります。`aria-selected`属性と`tabindex`属性はJavaScriptで動的に付けられている想定です。

<figure>
<figcaption>[19] 3つのタブがある場合のマークアップした例</figcaption>

```html
<button type="button" role="tab" id="tab01" aria-controls="tabpanel01"
 aria-selected="true">タブその1</button>
<button type="button" role="tab" id="tab02" aria-controls="tabpanel02"
 aria-selected="false" tabindex="-1">タブその2</button>
<button type="button" role="tab" id="tab03" aria-controls="tabpanel03"
 aria-selected="false" tabindex="-1">タブその3</button>
```

</figure>

\[19]のコードについて、もう少し詳しく見ていきましょう。

タブには`aria-controls`属性を指定して、このタブに対応するタブパネルを示します。一部のスクリーンリーダーでは、対応するタブパネルにジャンプできるようになります。

`id`属性を指定しておくと、タブのラベルを`aria-labelledby`属性で参照できるようになります。これは後述のタブパネルで利用します[^27]。

[^27]: `aria-labelledby`属性についてはCHAPTER 4-2を参照してください。

また、JavaScriptで以下の属性を付けます。これらの値は、タブが切り替わったときに動的に変化する想定です。

- `aria-selected`属性 : このタブが現在選択されているかどうかを示します。選択されているタブには"`true`"、そうでないタブには"`false`"を指定
- `tabindex`属性 : 選択されていないタブに`tabindex=-1`を指定します。前述のように、キーボード操作ではタブにフォーカスしてから左右キーでタブを切り替える想定となるため、選択されていないタブには直接フォーカスが当たらないようにする

*タブには、必ずアクセシブルな名前を付けてください。*上記の例のように、`button`要素の中にラベルテキストが入っていれば問題ありません。テキストを持たせられない場合、タブパネルに含まれている見出しにIDを付けて`aria-labelledby`属性で参照してもよいでしょう。

#### タブリスト

タブリストは、タブが列挙される部分です。*`tablist`ロールを適用しますが、*どの要素を採用するかは議論の余地があります。

ARIA in HTMLでは、`menu`、`ol`、`ul`、`nav`要素に`tablist`ロールが適用できることになっています[^28]。ほかにも、すべてのロール（any role）が適用可能とされている要素、たとえば`p`要素や`div`要素なども利用できます。なお、`dl`要素には`tablist`ロールを指定できないため、採用できません。

[^28]: 画面幅によって表現を切り替える場合、`ul`要素が便利な面もあります。後述の「タブと他の表現を切り替える」も参照してください。

タブリストにはタブが複数列挙されますし、名前に「リスト」と付いていますから、`ul`要素は有力候補です。しかし、WAI-ARIAの`tablist`ロールは`list`ロールと派生関係になく、`listitem`ロールの親にはなれません。`ul`要素のロールを`tablist`に変更すると、`li`要素の`listitem`ロールが宙に浮くことになります。`li`要素に`tab`ロールを指定することも可能ですが、先に述べたように*`tab`ロールは`button`要素か`a`要素に指定したほうがよいでしょう。*

この場合、`li`要素には`role=presentation`を指定することになります。`ul`要素を使っても、結局はリストの意味を失わせることになります。

最初から`div`要素を使うという考え方も有力です。実際、WAI-ARIA Authoring Practicesのタブの例では`div`要素を使用しています。どちらが正解というわけでもなく、前後の文脈や互換性など、周辺の事情を考えて採用するとよいでしょう。

#### タブパネル

タブパネルは実際に表示される内容を含む部分で、*`tabpanel`ロールを適用します。*

ARIA in HTMLでは、`section`要素に`tabpanel`ロールが適用できることになっています[^29]。ほかにも、すべてのロールが適用可能とされている`p`要素や`div`要素なども利用できます。ただし、タブパネルの中にさまざまな要素が入る可能性を考えると`p`要素は使い勝手に難があり、事実上、`section`要素と`div`要素のどちらかになるでしょう。タブパネルの中に見出しが入ってセクションとして成立しているならば`section`要素、そうでなければ`div`要素を利用するとよいでしょう。

[^29]: 以前は`section`要素に`tabpanel`ロールを指定できませんでしたが、現在は指定可能です。  
WAI-ARIA Authoring Practicesのタブの例では、タブパネルに`div`要素を使用しています。

\[20]は、タブパネルを`div`要素としてマークアップした例です。

<figure>
<figcaption>[20] タブパネルのマークアップ例</figcaption>

```html
<div tabindex="0" role="tabpanel" id="tabpanel01" aria-labelledby="tab01">
<!-- タブパネルの内容 -->
</div>
<div tabindex="0" role="tabpanel" id="tabpanel02" aria-labelledby="tab02" hidden>
<!-- タブパネルの内容 -->
</div>
<div tabindex="0" role="tabpanel" id="tabpanel03" aria-labelledby="tab03" hidden>
<!-- タブパネルの内容 -->
</div>
```

</figure>

\[20]のコードについて、もう少し詳しく見ていきましょう。

それぞれのタブパネルには、`id`属性を指定しています。これは、タブの`aria-controls`属性で対応するタブパネルを参照するためです。

タブパネルをフォーカス可能にする場合、タブパネルにはラベルを付ける必要があります。この例では、タブのラベルがそのまま使えるため、`aria-labelledby`属性でタブのIDを参照しています。タブパネルの中に見出しが含まれる場合は、その見出しにIDを付けて参照してもよいでしょう。ラベルにふさわしいテキストがどこにもない場合は、`aria-label`属性でラベルを付けることも可能です。

`hidden`属性が指定されているタブパネルは、現在非表示となっているものです。JavaScriptで`hidden`属性を与えたり、取り除いたりして表示・非表示を切り替えます。CSSの優先度によっては、`hidden`属性で要素を隠せないこともあるかもしれません。その場合は、`class`属性でクラス名を与えてCSSで非表示にしてもよいでしょう。

通常、`aria-hidden`属性を利用する必要はありません。*非表示のタブパネルは視覚環境からも隠されるべきもので、典型的にはCSSの`display:none`を適用して、視覚環境とスクリーンリーダーの双方から隠されるようにします。*演出上の都合など何らかの理由で`display:none`を適用できず、非表示のタブパネルがスクリーンリーダーで読み上げられてしまうような場合には、`aria-hidden`属性の利用を検討してもよいでしょう。

#### スクリプト実装

これでマークアップは完成です。あとは、JavaScriptを実装して動作するようにします。

具体的なコード例については WAI-ARIA Authoring Practicesに譲りますが、タブがクリックされた場合だけでなく、タブにフォーカスしたときのキーボード操作も忘れずに実装してください。`keypress`イベントではカーソルキーの操作を取得できないため、`keydown`イベントと`keyup`イベントを利用します。

#### タブと他の表現を切り替える

タブを利用する目的の1つは、画面スペースの節約です。タブ操作によって表示を切り替えることで、狭いスペースで多くの情報を見せることができます。画面スペースが十分にある場合、むしろ、タブで表現しないほうが望ましいかもしれません。

レスポンシブデザインを採用し、画面が狭いときはタブで表現し、広いときはすべてを展開して見せたいケースもあるでしょう。このような場合、`ul`要素を利用すると便利です。

\[21]のマークアップは、ページ内リンクの目次を`ul`要素で表現したものです。リンク先は`section`要素内の見出しになっています。

<figure>
<figcaption>[21] タブインターフェイスの記述例</figcaption>

```html
<ul>
  <li><a href="#section01">セクション1</a></li>
  <li><a href="#section02">セクション2</a></li>
  <li><a href="#section03">セクション3</a></li>
</ul>
<section>
  <h2 id="section01">セクション1</h1>
  <p>セクション1の内容...</p>
</section>
<section>
  <h2 id="section02">セクション2</h1>
  <p>セクション2の内容...</p>
</section>
<section>
  <h2 id="section03">セクション3</h1>
  <p>セクション2の内容...</p>
</section>
```

</figure>

このような目次とページ内リンクの構造は、タブに対応させることができます。目次のリストがタブリストに、目次内の個々のリンクがタブに、リンク先のセクションがタブパネルに対応します。\[21]のマークアップに対し、JavaScriptで`role`属性などを付与すると、\[22]のようになります。

<figure>
<figcaption>[22] [21]に<code>role</code>属性を付与した例</figcaption>

```html
<ul role="tablist">
  <li role="none"><a role="tab" href="#section01">セクション1</a></li>
  <li role="none"><a role="tab" href="#section02">セクション2</a></li>
  <li role="none"><a role="tab" href="#section03">セクション3</a></li>
</ul>
<section role="tabpanel" aria-labelledby="section01">
  <h2 id="section01">セクション1</h1>
  <p>セクション1の内容...</p>
</section>
<section role="tabpanel" aria-labelledby="section02">
  <h2 id="section02">セクション2</h1>
  <p>セクション2の内容...</p>
</section>
<section role="tabpanel" aria-labelledby="section03">
  <h2 id="section03">セクション3</h1>
  <p>セクション2の内容...</p>
</section>
```

</figure>

\[22]にはほかにも属性やイベントを付ける必要はありますが、タブとして成立することはわかるでしょう。このようにすると、状況によってページ内リンクの表示方法とタブの表現とを切り替えることが可能になります。また、JavaScriptが動作しない環境でも、ページ内リンクとして成立し、動作します。

#### タブの操作方法をあえて実装しない選択

\[22]の例は、ページ内リンクの目次だったものをタブとして動作させています。このとき、キーボードでの操作方法は変化します。ページ内リンクだった場合は、<kbd>Tab</kbd>キーでリンクに次々とフォーカスしていき、希望のリンクを選択するという操作でした。タブになると、現在選択されているタブにフォーカスし、左右キーでタブを選ぶという操作になります。

この操作方法の変更は本当に必要なのでしょうか。表現だけ変えて操作は変えず、ロールも変えず、そのままページ内リンクとして操作させるという考え方もあります。

タブを提供するコンテンツがウェブアプリケーションであり、デスクトップアプリケーションと同じ操作感が求められる場合は、タブとして操作できたほうがよいでしょう。そうではなく、単に単に省スペースを目的としているだけであれば、ページ内リンクの操作方法でも問題ないことが多いでしょう。

ただし、*タブの表現にはアクセシビリティ上の課題もあることに注意してください。ページ内リンクの場合、リンクをクリックすると該当箇所までスクロールし、明確に画面が変化するのが基本の動作です。それに対し、タブ切り替えでは通常、画面はスクロールしません。画面を拡大しているユーザーの場合、タブの部分を画面いっぱいに拡大していると、その外で起きた変化に気づかないことがあります[^30]。

[^30]: これは、先に挙げたメニューボタンの例において、開いたメニューがどこにあるのかわからないケースと類似した問題です。メニューの例と同様、`aria-controls`属性だけでは不十分なので、タブとタブパネルを隣接させる、フォーカスを移動させるといった対応をするとよいでしょう。

## 事例 4：モーダルダイアログ

*「ダイアログ（dialog）」*[^31]は、ウェブコンテンツの上に覆いかぶさるように出現するウィンドウ領域です。基本的には、ユーザーに対して注意を促し、何かを入力させるために用います。

[^31]: dialogという英単語は「対話」という意味で、ユーザーに通知をし、かつユーザーからの操作を受け付けることからこの名があります。ユーザー操作を受け付けない通知領域は、ダイアログとは呼びません。

ダイアログには、大きく分けて2つのモードがあります。

- モーダルダイアログ（modal dialog）：ダイアログが出現している間、ダイアログ以外の要素を操作できなくなるもの
- モードレスダイアログ（modeless dialog）：ダイアログが出ても他のコンテンツを引き続き操作できるもの

モーダルダイアログの場合、\[23]のようにダイアログの外をグレーアウトさせて、他のコンテンツが操作できないことが視覚的にわかるようにすることが一般的です。

<figure>
<figcaption>[23] モーダルダイアログのイメージ</figcaption>
<img src="../image/C4_04_23_1C.png" alt="" />
</figure>

ウェブではモードレスダイアログはあまり利用されません。他のコンテンツを引き続き操作できる場合、ダイアログではない表示をすることが多いでしょう。

ここでは、モーダルダイアログの実装について、いくつかの方法をとりあげ、内容を見ていくことにします。

### window.confirm()メソッドによる簡易なダイアログ

簡易なダイアログであれば、JavaScriptの機能だけで簡単に実装できます。`window.confirm()`メソッドを利用すると、ユーザーにOKかキャンセルかの2択を問うモーダルダイアログを出すことができます。\[24]は、フォームをリセットする場合に警告のダイアログを出す例です。表示例は\[25]のようになります。

<figure>
<figcaption>[24] 警告のダイアログの例</figcaption>

```html
<form onreset="return confirm('フォームの内容をすべて初期化します。よろしいですか?')">
  <input value="初期値">
  <button>送信</button>
  <button type="reset">リセット</button>
</form>
```

</figure>
<figure>
<figcaption>[25] ブラウザーによる[24]の表示例</figcaption>
<img src="../image/C4_04_25_1C.png" alt="" />
</figure>

ユーザーがキャンセルボタンを押した場合は`confirm()`メソッドの戻り値が`false`となり、`return false`が実行されてリセットの動作がキャンセルされます[^32]。

[^32]: `onreset`属性はイベントハンドラーコンテンツ属性の1つで、フォームがリセットされる際に実行されます。CHAPTER 4-1のイベントハンドラーコンテンツ属性（P287）も参照してください。

このダイアログはブラウザーの機能で表示されるため、コンテンツ制作者は見た目を制御できません。ブラウザーによっても異なりますが、ほとんどの場合、シンプルで事務的な見た目になります。簡潔にYes/Noを問うだけでよい場合は、これで十分でしょう。

### dialog要素によるダイアログ

HTMLには、ダイアログを表示するための`dialog`要素が用意されています。`showModal()`メソッドを呼ぶとモーダルダイアログとして機能します。詳細はCHAPTER 3-12の`dialog`要素（P260）を参照してください。

`dialog`要素を利用すると、それだけで、モーダルダイアログの外にある要素を暗く表示し、操作できないようにするところまで実現できます。

なお、初期状態でダイアログを隠す処理も実現されていますが、これは単にユーザーエージェントのスタイルシートで`dialog:not([open]){display:none;}`というスタイルが与えられているだけです。より強いセレクターで`display`プロパティを上書きすると、ダイアログが表示されてしまうこともあるので注意してください。

### WAI-ARIAを駆使した実装

`dialog`要素をサポートしないブラウザーを想定した場合、他の要素とWAI-ARIAを組み合わせて自前でダイアログを実装する選択肢が現実的になります。ダイアログのマークアップは、たとえば\[26]のようになります。

<figure>
<figcaption>[26] WAI-ARIAを使ったダイアログのマークアップ例</figcaption>

```html
<div id="dialog_layer" class="dialogs">
  <div tabindex="0"></div>
  <div id="dialog4" class="dialog"
    role="dialog"
    aria-labelledby="dialog_label"
    aria-describedby="dialog_desc"
    aria-modal="true">
    <h2 id="dialog_label">ダイアログの見出し</h2>
    <p id="dialog_desc">
      ダイアログのメッセージ...
    </p>
    <!-- その他さまざまな中身が入る -->
    <button type="button"
      id="dialog_close_button">
      <img src="close.png" alt="閉じる">
    </button>
  </div>
  <div tabindex="0"></div>
</div>
```

</figure>

\[26]のコード例を少し詳しく見ていきましょう。

一番外側の`div`要素は、ダイアログ全体のラッパーです。その中にダイアログ本体の`div`要素が入っていますが、キーボードフォーカスの制御のために、ダイアログの前後に`<div tabindex="0"></div>`を挿入しています。これは、ハンバーガーメニューの事例で紹介したフォーカストラップです（P326）。JavaScriptによるDOM操作で`div`要素を挿入して`focus`イベントを付けておき、フォーカスをトラップする制御を行います。

ダイアログ本体となる`div`要素には、`role`属性で`dialog`ロールを指定して、ダイアログであることを示しています[^33]。

[^33]: ダイアログが重要な警告やエラーを通知する場合は、`alertdialog`ロールを指定してもよいでしょう。なお、ユーザーの入力を受け付けない（ボタンでダイアログを閉じる必要もない）ような場合は、そもそもダイアログではないため、`alert`ロールがより適切です。

*`dialog`ロールには、必ずアクセシブルな名前を与えなければなりません。*この例では、ダイアログの内部に見える形で見出しが存在しているため、`aria-labelledby`属性を利用して結び付けています。見える形のテキストラベルがない場合は、`aria-label`属性などを利用してもよいでしょう。

同様に、`aria-describedby`属性でアクセシブルな説明を提供しています。これは必須ではありませんが、スクリーンリーダーでは、ダイアログにフォーカスした際に、見出しに続けてメッセージが読み上げられるようになります。

`aria-modal="true"`の指定は、このダイアログがモーダルであることを示すものです。`aria-modal`属性に対応した支援技術の場合、これだけでモーダルの外の要素を操作できないようにする場合があります。とはいえ、この処理は仕様上必須とはされておらず、対応していない支援技術もあるため、モーダルダイアログの外の要素を読み上げないようにしたり、キーボードフォーカスを制御する処理の実装も必要です。

モーダルダイアログの内部には、閉じるボタンを置きます。`aria-modal`属性を指定するとダイアログの外側にアクセスできなくなることがあるため、ダイアログを開いたボタンをトグルさせたい場合などは、ボタンが必ずダイアログの内部に来るように配慮してください。また、<kbd>Esc</kbd>キーが押されたときにダイアログが閉じるようにしておくとよいでしょう。

あとはJavaScriptで動作を制御するだけですが、コードは長くなるため、ここでは紹介しません。具体的なJavaScriptのコードやその他の細部については、WAI-ARIA Authoring Practicesのdialogの例を参考にしてください[^34]。

[^34]: WAI-ARIA Authoring Practices dialog  
<https://www.w3.org/TR/waiaria-practices/examples/dialogmodal/dialog.html>

## 事例5：インライン SVGのアクセシビリティを担保する

SVGは、XML形式のデータでベクター形式の画像を表現する技術です。SVG画像を表示するには、`img`要素の`src`属性でSVGファイルを参照するか、`svg`要素を利用してインラインでSVGを埋め込みます。インラインで埋め込んだ場合、JavaScriptによるDOM操作でSVGの内容を制御できるため、さまざまな表現が可能になります。

ここでは、`svg`要素を利用してSVGをインラインで記述する場合のアクセシビリティの考慮点について見ていきます。

### svg要素のロール

SVGの用途はさまざまですが、ウェブコンテンツでは、純粋に画像として利用するケースが多いでしょう。

この場合、`svg`要素のデフォルトのロールが`img`要素とは異なる点に注意が必要です。（SVGの次期バージョンである）SVG2の仕様[^35]、およびARIA in HTML仕様では、`svg`要素はデフォルトで`graphics-document`ロール[^36]を持つとされています。

[^35]: SVG2 5.13.4. Implicit and Allowed ARIA Semantics  
<https://www.w3.org/TR/SVG2/struct.html#implicit-ariasemantics>

[^36]: graphics-document \(role)  
<https://www.w3.org/TR/graphics-aria/#graphics-document>

*`graphics-document`ロールは文書を表す`document`ロールから派生したもので、画像よりも文書に近い性質を持つものです。*このロールはWAI-ARIA仕様ではなく、WAI-ARIA Graphics Module仕様で定義されています。

SVGは一般的に画像を表現するために利用されますが、テキストを含めて、テキストのレイアウトに用いることもできます。ウェブコンテンツでSVGを利用する場合、SVGの用途を確認しましょう。単に画像として扱っている場合は、`role=img`を指定して、明示的に`img`ロールを付与するとよいでしょう。

## 画像の代替テキストと説明を提供する

意味のある画像には代替テキストを与える必要があります。`img`要素の`src`属性でSVGファイルを参照した場合には、`alt`属性で代替テキストを与えます。

`svg`要素を使ってインラインでSVGを記述した場合、`alt`属性は利用できません。`svg`要素には`title`属性も指定できません。

\[27]のようなインラインSVGの場合、`svg`要素直下の`title`要素がアクセシブルな名前として利用されます[^37]。

[^37]: SVGにおけるアクセシブルな名前の算出方法について
は、SVG-AAM仕様の8.special Processing Requiring Additional Computationを参照してください。  
8.special Processing Requiring Additional Computation
<https://w3c.github.io/svg-aam/#mapping_additional>

<figure>
<figcaption>[27] インラインSVGの記述例</figcaption>

```xml
<svg role="img">
  <title>図: XX会社の組織図</title>
  ...
</svg>
```

</figure>

なお、`svg`要素には、`aria-label`属性や`aria-labelledby`属性を指定することも可能です。それらの属性があれば、そちらが優先されます。説明文についても同様です。

`aria-describedby`属性が利用できるほか、\[28]のようにSVG内に`desc`要素があれば、アクセシブルな説明として利用されます。

<figure>
<figcaption>[28] SVG内に<code>desc</code>要素を記述した例</figcaption>

```xml
<svg role="img">
  <title>図: XX会社の組織図</title>
  <desc>XX会社の組織図です。頂点にはXX組織があり...</desc>
</svg>
```

</figure>

インラインでSVGを使用するときは、画像の代替テキストと説明文をSVGの中で与えるようにしましょう。それができない場合は、`aria-label`属性や`aria-describedby`属性を利用します。

### 装飾的なSVG画像を無視させる

SVGが意味を持たない、純粋に装飾的な画像である場合は、支援技術に無視させる必要があります。`img`要素の場合は`alt=""`を指定しますが、`svg`要素の場合は\[29]のように`aria-hidden`属性を利用します。この場合、`role`属性を指定する必要はありません。

<figure>
<figcaption>[29] <code>svg</code>要素に<code>aria-hidden</code>属性を指定した例</figcaption>

```xml
<svg aria-hidden="true">
  <!-- 純粋に装飾的な画像 -->
  ...
</svg>
```

</figure>

## テストを行う

ここまで、WAI-ARIAを利用する事例を紹介してきました。HTMLだけでアクセシビリティを担保できない場合に、WAI-ARIAを利用することで、アクセシビリティを向上できることがあります。

しかし、常にWAI-ARIAを利用することがよいわけではありません。ARIAを不適切に利用するくらいならば、使わないほうがよいといえます。しかし残念ながら、不適切なARIA利用は多いのが現状です。

では、WAI-ARIAの使用が適切かどうかは、どうやって判断すればよいのでしょうか。筆者は、実際に動作検証をすることが重要だと考えています。実際にスクリーンリーダーなどの支援技術を用いてアクセスすることは難しくありません。

ここで紹介してきたような複雑な事例では、ユーザビリティの観点も重要になります。実際にユーザーに触れてもらい、テストを行うことが、より重要になってくるでしょう。
